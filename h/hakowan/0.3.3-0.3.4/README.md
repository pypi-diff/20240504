# Comparing `tmp/hakowan-0.3.3-py3-none-any.whl.zip` & `tmp/hakowan-0.3.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,80 +1,81 @@
-Zip file size: 502415 bytes, number of entries: 78
--rw-r--r--  2.0 unx      546 b- defN 24-Apr-06 19:38 hakowan/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 24-Apr-06 19:38 hakowan/py.typed
--rw-r--r--  2.0 unx       27 b- defN 24-Apr-06 19:38 hakowan/common/__init__.py
--rw-r--r--  2.0 unx     1965 b- defN 24-Apr-06 19:38 hakowan/common/color.py
--rw-r--r--  2.0 unx      265 b- defN 24-Apr-06 19:38 hakowan/common/default.py
--rw-r--r--  2.0 unx      135 b- defN 24-Apr-06 19:38 hakowan/common/envmaps.py
--rw-r--r--  2.0 unx      131 b- defN 24-Apr-06 19:38 hakowan/common/exception.py
--rw-r--r--  2.0 unx      117 b- defN 24-Apr-06 19:38 hakowan/common/logger.py
--rw-r--r--  2.0 unx     6543 b- defN 24-Apr-06 19:38 hakowan/common/named_colors.py
--rw-r--r--  2.0 unx      691 b- defN 24-Apr-06 19:38 hakowan/common/to_color.py
--rw-r--r--  2.0 unx        0 b- defN 24-Apr-06 19:38 hakowan/common/colormap/__init__.py
--rw-r--r--  2.0 unx     2614 b- defN 24-Apr-06 19:38 hakowan/common/colormap/colorbrewer2.py
--rw-r--r--  2.0 unx     1235 b- defN 24-Apr-06 19:38 hakowan/common/colormap/colormap.py
--rw-r--r--  2.0 unx    19025 b- defN 24-Apr-06 19:38 hakowan/common/colormap/coolwarm.py
--rw-r--r--  2.0 unx    11519 b- defN 24-Apr-06 19:38 hakowan/common/colormap/inferno.py
--rw-r--r--  2.0 unx    11515 b- defN 24-Apr-06 19:38 hakowan/common/colormap/magma.py
--rw-r--r--  2.0 unx      575 b- defN 24-Apr-06 19:38 hakowan/common/colormap/named_colormaps.py
--rw-r--r--  2.0 unx    11517 b- defN 24-Apr-06 19:38 hakowan/common/colormap/plasma.py
--rw-r--r--  2.0 unx    10794 b- defN 24-Apr-06 19:38 hakowan/common/colormap/turbo.py
--rw-r--r--  2.0 unx    11519 b- defN 24-Apr-06 19:38 hakowan/common/colormap/viridis.py
--rw-r--r--  2.0 unx      106 b- defN 24-Apr-06 19:38 hakowan/compiler/__init__.py
--rw-r--r--  2.0 unx    10577 b- defN 24-Apr-06 19:38 hakowan/compiler/attribute.py
--rw-r--r--  2.0 unx     7476 b- defN 24-Apr-06 19:38 hakowan/compiler/channel.py
--rw-r--r--  2.0 unx     4044 b- defN 24-Apr-06 19:38 hakowan/compiler/color.py
--rw-r--r--  2.0 unx     2548 b- defN 24-Apr-06 19:38 hakowan/compiler/compile.py
--rw-r--r--  2.0 unx     2030 b- defN 24-Apr-06 19:38 hakowan/compiler/scene.py
--rw-r--r--  2.0 unx     8690 b- defN 24-Apr-06 19:38 hakowan/compiler/texture.py
--rw-r--r--  2.0 unx    11916 b- defN 24-Apr-06 19:38 hakowan/compiler/transform.py
--rw-r--r--  2.0 unx      478 b- defN 24-Apr-06 19:38 hakowan/compiler/utils.py
--rw-r--r--  2.0 unx     9320 b- defN 24-Apr-06 19:38 hakowan/compiler/view.py
--rw-r--r--  2.0 unx      292 b- defN 24-Apr-06 19:38 hakowan/envmaps/README.md
--rw-r--r--  2.0 unx   426040 b- defN 24-Apr-06 19:38 hakowan/envmaps/museum.exr
--rw-r--r--  2.0 unx        0 b- defN 24-Apr-06 19:38 hakowan/grammar/__init__.py
--rw-r--r--  2.0 unx      104 b- defN 24-Apr-06 19:38 hakowan/grammar/channel/__init__.py
--rw-r--r--  2.0 unx     3152 b- defN 24-Apr-06 19:38 hakowan/grammar/channel/channel.py
--rw-r--r--  2.0 unx      476 b- defN 24-Apr-06 19:38 hakowan/grammar/channel/curvestyle.py
--rw-r--r--  2.0 unx      250 b- defN 24-Apr-06 19:38 hakowan/grammar/channel/material/__init__.py
--rw-r--r--  2.0 unx     3766 b- defN 24-Apr-06 19:38 hakowan/grammar/channel/material/material.py
--rw-r--r--  2.0 unx      366 b- defN 24-Apr-06 19:38 hakowan/grammar/channel/material/medium.py
--rw-r--r--  2.0 unx       48 b- defN 24-Apr-06 19:38 hakowan/grammar/dataframe/__init__.py
--rw-r--r--  2.0 unx     1279 b- defN 24-Apr-06 19:38 hakowan/grammar/dataframe/dataframe.py
--rw-r--r--  2.0 unx       25 b- defN 24-Apr-06 19:38 hakowan/grammar/layer/__init__.py
--rw-r--r--  2.0 unx    13160 b- defN 24-Apr-06 19:38 hakowan/grammar/layer/layer.py
--rw-r--r--  2.0 unx      416 b- defN 24-Apr-06 19:38 hakowan/grammar/layer/layer_spec.py
--rw-r--r--  2.0 unx       46 b- defN 24-Apr-06 19:38 hakowan/grammar/mark/__init__.py
--rw-r--r--  2.0 unx      375 b- defN 24-Apr-06 19:38 hakowan/grammar/mark/mark.py
--rw-r--r--  2.0 unx      158 b- defN 24-Apr-06 19:38 hakowan/grammar/scale/__init__.py
--rw-r--r--  2.0 unx     1301 b- defN 24-Apr-06 19:38 hakowan/grammar/scale/attribute.py
--rw-r--r--  2.0 unx      285 b- defN 24-Apr-06 19:38 hakowan/grammar/scale/offset.py
--rw-r--r--  2.0 unx     2887 b- defN 24-Apr-06 19:38 hakowan/grammar/scale/scale.py
--rw-r--r--  2.0 unx       23 b- defN 24-Apr-06 19:38 hakowan/grammar/texture/__init__.py
--rw-r--r--  2.0 unx     3154 b- defN 24-Apr-06 19:38 hakowan/grammar/texture/texture.py
--rw-r--r--  2.0 unx       25 b- defN 24-Apr-06 19:38 hakowan/grammar/transform/__init__.py
--rw-r--r--  2.0 unx     3737 b- defN 24-Apr-06 19:38 hakowan/grammar/transform/transform.py
--rw-r--r--  2.0 unx      361 b- defN 24-Apr-06 19:38 hakowan/render/__init__.py
--rw-r--r--  2.0 unx     9953 b- defN 24-Apr-06 19:38 hakowan/render/bsdf.py
--rw-r--r--  2.0 unx      200 b- defN 24-Apr-06 19:38 hakowan/render/color.py
--rw-r--r--  2.0 unx     1344 b- defN 24-Apr-06 19:38 hakowan/render/emitter.py
--rw-r--r--  2.0 unx      623 b- defN 24-Apr-06 19:38 hakowan/render/film.py
--rw-r--r--  2.0 unx     1798 b- defN 24-Apr-06 19:38 hakowan/render/integrator.py
--rw-r--r--  2.0 unx      950 b- defN 24-Apr-06 19:38 hakowan/render/medium.py
--rw-r--r--  2.0 unx     4133 b- defN 24-Apr-06 19:38 hakowan/render/render.py
--rw-r--r--  2.0 unx      587 b- defN 24-Apr-06 19:38 hakowan/render/sampler.py
--rw-r--r--  2.0 unx     1057 b- defN 24-Apr-06 19:38 hakowan/render/sensor.py
--rw-r--r--  2.0 unx    14360 b- defN 24-Apr-06 19:38 hakowan/render/shape.py
--rw-r--r--  2.0 unx      593 b- defN 24-Apr-06 19:38 hakowan/render/spectrum.py
--rw-r--r--  2.0 unx     4662 b- defN 24-Apr-06 19:38 hakowan/render/texture.py
--rw-r--r--  2.0 unx      137 b- defN 24-Apr-06 19:38 hakowan/setup/__init__.py
--rw-r--r--  2.0 unx     3410 b- defN 24-Apr-06 19:38 hakowan/setup/config.py
--rw-r--r--  2.0 unx     1096 b- defN 24-Apr-06 19:38 hakowan/setup/emitter.py
--rw-r--r--  2.0 unx     1144 b- defN 24-Apr-06 19:38 hakowan/setup/film.py
--rw-r--r--  2.0 unx     3123 b- defN 24-Apr-06 19:38 hakowan/setup/integrator.py
--rw-r--r--  2.0 unx     1009 b- defN 24-Apr-06 19:38 hakowan/setup/sampler.py
--rw-r--r--  2.0 unx     1441 b- defN 24-Apr-06 19:38 hakowan/setup/sensor.py
--rw-r--r--  2.0 unx    11335 b- defN 24-Apr-06 19:37 hakowan-0.3.3.dist-info/LICENSE
--rw-r--r--  2.0 unx       81 b- defN 16-Jan-01 00:00 hakowan-0.3.3.dist-info/WHEEL
--rw-r--r--  2.0 unx     1266 b- defN 16-Jan-01 00:00 hakowan-0.3.3.dist-info/METADATA
--rw-r--r--  2.0 unx     6640 b- defN 16-Jan-01 00:00 hakowan-0.3.3.dist-info/RECORD
-78 files, 680586 bytes uncompressed, 491899 bytes compressed:  27.7%
+Zip file size: 505031 bytes, number of entries: 79
+-rw-r--r--  2.0 unx      546 b- defN 24-May-04 21:01 hakowan/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-04 21:01 hakowan/py.typed
+-rw-r--r--  2.0 unx       27 b- defN 24-May-04 21:01 hakowan/common/__init__.py
+-rw-r--r--  2.0 unx     1965 b- defN 24-May-04 21:01 hakowan/common/color.py
+-rw-r--r--  2.0 unx      265 b- defN 24-May-04 21:01 hakowan/common/default.py
+-rw-r--r--  2.0 unx      135 b- defN 24-May-04 21:01 hakowan/common/envmaps.py
+-rw-r--r--  2.0 unx      131 b- defN 24-May-04 21:01 hakowan/common/exception.py
+-rw-r--r--  2.0 unx      117 b- defN 24-May-04 21:01 hakowan/common/logger.py
+-rw-r--r--  2.0 unx     6543 b- defN 24-May-04 21:01 hakowan/common/named_colors.py
+-rw-r--r--  2.0 unx      691 b- defN 24-May-04 21:01 hakowan/common/to_color.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-04 21:01 hakowan/common/colormap/__init__.py
+-rw-r--r--  2.0 unx     2614 b- defN 24-May-04 21:01 hakowan/common/colormap/colorbrewer2.py
+-rw-r--r--  2.0 unx     1235 b- defN 24-May-04 21:01 hakowan/common/colormap/colormap.py
+-rw-r--r--  2.0 unx    19025 b- defN 24-May-04 21:01 hakowan/common/colormap/coolwarm.py
+-rw-r--r--  2.0 unx    11519 b- defN 24-May-04 21:01 hakowan/common/colormap/inferno.py
+-rw-r--r--  2.0 unx    11515 b- defN 24-May-04 21:01 hakowan/common/colormap/magma.py
+-rw-r--r--  2.0 unx      575 b- defN 24-May-04 21:01 hakowan/common/colormap/named_colormaps.py
+-rw-r--r--  2.0 unx    11517 b- defN 24-May-04 21:01 hakowan/common/colormap/plasma.py
+-rw-r--r--  2.0 unx    10794 b- defN 24-May-04 21:01 hakowan/common/colormap/turbo.py
+-rw-r--r--  2.0 unx    11519 b- defN 24-May-04 21:01 hakowan/common/colormap/viridis.py
+-rw-r--r--  2.0 unx      106 b- defN 24-May-04 21:01 hakowan/compiler/__init__.py
+-rw-r--r--  2.0 unx    10577 b- defN 24-May-04 21:01 hakowan/compiler/attribute.py
+-rw-r--r--  2.0 unx     8519 b- defN 24-May-04 21:01 hakowan/compiler/channel.py
+-rw-r--r--  2.0 unx     4044 b- defN 24-May-04 21:01 hakowan/compiler/color.py
+-rw-r--r--  2.0 unx     2548 b- defN 24-May-04 21:01 hakowan/compiler/compile.py
+-rw-r--r--  2.0 unx     2054 b- defN 24-May-04 21:01 hakowan/compiler/scene.py
+-rw-r--r--  2.0 unx     8690 b- defN 24-May-04 21:01 hakowan/compiler/texture.py
+-rw-r--r--  2.0 unx    11628 b- defN 24-May-04 21:01 hakowan/compiler/transform.py
+-rw-r--r--  2.0 unx      478 b- defN 24-May-04 21:01 hakowan/compiler/utils.py
+-rw-r--r--  2.0 unx    11311 b- defN 24-May-04 21:01 hakowan/compiler/view.py
+-rw-r--r--  2.0 unx      292 b- defN 24-May-04 21:01 hakowan/envmaps/README.md
+-rw-r--r--  2.0 unx   426040 b- defN 24-May-04 21:01 hakowan/envmaps/museum.exr
+-rw-r--r--  2.0 unx        0 b- defN 24-May-04 21:01 hakowan/grammar/__init__.py
+-rw-r--r--  2.0 unx      127 b- defN 24-May-04 21:01 hakowan/grammar/channel/__init__.py
+-rw-r--r--  2.0 unx     4375 b- defN 24-May-04 21:01 hakowan/grammar/channel/channel.py
+-rw-r--r--  2.0 unx      476 b- defN 24-May-04 21:01 hakowan/grammar/channel/curvestyle.py
+-rw-r--r--  2.0 unx      250 b- defN 24-May-04 21:01 hakowan/grammar/channel/material/__init__.py
+-rw-r--r--  2.0 unx     3766 b- defN 24-May-04 21:01 hakowan/grammar/channel/material/material.py
+-rw-r--r--  2.0 unx      366 b- defN 24-May-04 21:01 hakowan/grammar/channel/material/medium.py
+-rw-r--r--  2.0 unx       48 b- defN 24-May-04 21:01 hakowan/grammar/dataframe/__init__.py
+-rw-r--r--  2.0 unx     1279 b- defN 24-May-04 21:01 hakowan/grammar/dataframe/dataframe.py
+-rw-r--r--  2.0 unx       25 b- defN 24-May-04 21:01 hakowan/grammar/layer/__init__.py
+-rw-r--r--  2.0 unx    14156 b- defN 24-May-04 21:01 hakowan/grammar/layer/layer.py
+-rw-r--r--  2.0 unx      416 b- defN 24-May-04 21:01 hakowan/grammar/layer/layer_spec.py
+-rw-r--r--  2.0 unx       46 b- defN 24-May-04 21:01 hakowan/grammar/mark/__init__.py
+-rw-r--r--  2.0 unx      375 b- defN 24-May-04 21:01 hakowan/grammar/mark/mark.py
+-rw-r--r--  2.0 unx      158 b- defN 24-May-04 21:01 hakowan/grammar/scale/__init__.py
+-rw-r--r--  2.0 unx     1301 b- defN 24-May-04 21:01 hakowan/grammar/scale/attribute.py
+-rw-r--r--  2.0 unx      285 b- defN 24-May-04 21:01 hakowan/grammar/scale/offset.py
+-rw-r--r--  2.0 unx     2887 b- defN 24-May-04 21:01 hakowan/grammar/scale/scale.py
+-rw-r--r--  2.0 unx       23 b- defN 24-May-04 21:01 hakowan/grammar/texture/__init__.py
+-rw-r--r--  2.0 unx     3328 b- defN 24-May-04 21:01 hakowan/grammar/texture/texture.py
+-rw-r--r--  2.0 unx       25 b- defN 24-May-04 21:01 hakowan/grammar/transform/__init__.py
+-rw-r--r--  2.0 unx     3737 b- defN 24-May-04 21:01 hakowan/grammar/transform/transform.py
+-rw-r--r--  2.0 unx      361 b- defN 24-May-04 21:01 hakowan/render/__init__.py
+-rw-r--r--  2.0 unx    10517 b- defN 24-May-04 21:01 hakowan/render/bsdf.py
+-rw-r--r--  2.0 unx      200 b- defN 24-May-04 21:01 hakowan/render/color.py
+-rw-r--r--  2.0 unx     1344 b- defN 24-May-04 21:01 hakowan/render/emitter.py
+-rw-r--r--  2.0 unx      623 b- defN 24-May-04 21:01 hakowan/render/film.py
+-rw-r--r--  2.0 unx     3095 b- defN 24-May-04 21:01 hakowan/render/icosphere.py
+-rw-r--r--  2.0 unx     1798 b- defN 24-May-04 21:01 hakowan/render/integrator.py
+-rw-r--r--  2.0 unx      950 b- defN 24-May-04 21:01 hakowan/render/medium.py
+-rw-r--r--  2.0 unx     4023 b- defN 24-May-04 21:01 hakowan/render/render.py
+-rw-r--r--  2.0 unx      587 b- defN 24-May-04 21:01 hakowan/render/sampler.py
+-rw-r--r--  2.0 unx     1057 b- defN 24-May-04 21:01 hakowan/render/sensor.py
+-rw-r--r--  2.0 unx    17387 b- defN 24-May-04 21:01 hakowan/render/shape.py
+-rw-r--r--  2.0 unx      593 b- defN 24-May-04 21:01 hakowan/render/spectrum.py
+-rw-r--r--  2.0 unx     4731 b- defN 24-May-04 21:01 hakowan/render/texture.py
+-rw-r--r--  2.0 unx      137 b- defN 24-May-04 21:01 hakowan/setup/__init__.py
+-rw-r--r--  2.0 unx     3410 b- defN 24-May-04 21:01 hakowan/setup/config.py
+-rw-r--r--  2.0 unx     1096 b- defN 24-May-04 21:01 hakowan/setup/emitter.py
+-rw-r--r--  2.0 unx     1144 b- defN 24-May-04 21:01 hakowan/setup/film.py
+-rw-r--r--  2.0 unx     3123 b- defN 24-May-04 21:01 hakowan/setup/integrator.py
+-rw-r--r--  2.0 unx     1009 b- defN 24-May-04 21:01 hakowan/setup/sampler.py
+-rw-r--r--  2.0 unx     1441 b- defN 24-May-04 21:01 hakowan/setup/sensor.py
+-rw-r--r--  2.0 unx    11335 b- defN 24-May-04 21:01 hakowan-0.3.4.dist-info/LICENSE
+-rw-r--r--  2.0 unx       81 b- defN 16-Jan-01 00:00 hakowan-0.3.4.dist-info/WHEEL
+-rw-r--r--  2.0 unx     1266 b- defN 16-Jan-01 00:00 hakowan-0.3.4.dist-info/METADATA
+-rw-r--r--  2.0 unx     6726 b- defN 16-Jan-01 00:00 hakowan-0.3.4.dist-info/RECORD
+79 files, 692503 bytes uncompressed, 494385 bytes compressed:  28.6%
```

## zipnote {}

```diff
@@ -171,14 +171,17 @@
 
 Filename: hakowan/render/emitter.py
 Comment: 
 
 Filename: hakowan/render/film.py
 Comment: 
 
+Filename: hakowan/render/icosphere.py
+Comment: 
+
 Filename: hakowan/render/integrator.py
 Comment: 
 
 Filename: hakowan/render/medium.py
 Comment: 
 
 Filename: hakowan/render/render.py
@@ -216,20 +219,20 @@
 
 Filename: hakowan/setup/sampler.py
 Comment: 
 
 Filename: hakowan/setup/sensor.py
 Comment: 
 
-Filename: hakowan-0.3.3.dist-info/LICENSE
+Filename: hakowan-0.3.4.dist-info/LICENSE
 Comment: 
 
-Filename: hakowan-0.3.3.dist-info/WHEEL
+Filename: hakowan-0.3.4.dist-info/WHEEL
 Comment: 
 
-Filename: hakowan-0.3.3.dist-info/METADATA
+Filename: hakowan-0.3.4.dist-info/METADATA
 Comment: 
 
-Filename: hakowan-0.3.3.dist-info/RECORD
+Filename: hakowan-0.3.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## hakowan/__init__.py

```diff
@@ -1,10 +1,10 @@
 """ Hakowan: A 3D data visualization grammer """
 
-__version__ = "0.3.3"
+__version__ = "0.3.4"
 
 from .common import logger
 from .setup import Config as config
 from .grammar import dataframe, mark, channel, scale, texture, transform
 from .grammar.layer import Layer as layer
 from .grammar.scale import Attribute as attribute
 from .grammar.channel import material
```

## hakowan/compiler/channel.py

```diff
@@ -4,15 +4,17 @@
 from .texture import apply_texture
 from .utils import unique_name
 
 from ..common import logger
 from ..grammar.channel import (
     BumpMap,
     Channel,
+    Covariance,
     Normal,
+    NormalMap,
     Position,
     Size,
     VectorField,
 )
 from ..grammar.channel.material import (
     Conductor,
     Dielectric,
@@ -28,15 +30,15 @@
     ThinPrincipled,
 )
 from ..grammar.channel.curvestyle import Bend
 from ..grammar.dataframe import DataFrame
 from ..grammar.mark import Mark
 from ..grammar import scale
 from ..grammar.scale import Attribute, Normalize
-from ..grammar.texture import Texture, Uniform, ScalarField
+from ..grammar.texture import Texture, Uniform, ScalarField, Image
 
 import lagrange
 import numpy as np
 from numpy.linalg import norm
 
 ### Public API
 
@@ -78,20 +80,26 @@
                     view.normal_channel = channel
             case Size():
                 if view.size_channel is None:
                     view.size_channel = channel
             case VectorField():
                 if view.vector_field_channel is None:
                     view.vector_field_channel = channel
+            case Covariance():
+                if view.covariance_channel is None:
+                    view.covariance_channel = channel
             case Material():
                 if view.material_channel is None:
                     view.material_channel = channel
             case BumpMap():
                 if view.bump_map is None:
                     view.bump_map = channel
+            case NormalMap():
+                if view.normal_map is None:
+                    view.normal_map = channel
             case _:
                 raise NotImplementedError(
                     f"Channel type {type(channel)} is not supported"
                 )
 
     # Generate default material channel if not specified.
     if view.material_channel is None:
@@ -129,34 +137,49 @@
         match view.vector_field_channel.style:
             case Bend():
                 style = view.vector_field_channel.style
                 if isinstance(style.direction, str):
                     style.direction = Attribute(style.direction)
                 compute_scaled_attribute(df, style.direction)
                 view._active_attributes.append(style.direction)
+    if view.covariance_channel is not None:
+        assert isinstance(view.covariance_channel, Covariance)
+        assert isinstance(view.covariance_channel.data, Attribute)
+        attr = view.covariance_channel.data
+        compute_scaled_attribute(df, attr)
+        view._active_attributes.append(attr)
     if view.bump_map is not None:
         tex = view.bump_map.texture
         assert tex is not None
         if isinstance(tex, Texture):
             view._active_attributes += apply_texture(df, tex, view.uv_attribute)
             view.uv_attribute = tex._uv
+    if view.normal_map is not None:
+        tex = view.normal_map.texture
+        assert tex is not None
+        if isinstance(tex, Texture):
+            if isinstance(tex, Image):
+                if not tex.raw:
+                    logger.warn("Normal map texture image not in raw format may lead to incorrect result")
+            view._active_attributes += apply_texture(df, tex, view.uv_attribute)
+            view.uv_attribute = tex._uv
     if view.material_channel is not None:
         match view.material_channel:
             case Diffuse():
                 if isinstance(view.material_channel.reflectance, Texture):
                     tex = view.material_channel.reflectance
                     view._active_attributes += apply_texture(df, tex, view.uv_attribute)
                     view.uv_attribute = tex._uv
                     apply_colormap(df, tex)
             case RoughConductor() | RoughDielectric():
                 if isinstance(view.material_channel.alpha, Texture):
                     tex = view.material_channel.alpha
                     view._active_attributes += apply_texture(df, tex, view.uv_attribute)
                     view.uv_attribute = tex._uv
-                    apply_colormap(df, tex) # TODO: is this needed?
+                    apply_colormap(df, tex)  # TODO: is this needed?
             case Conductor() | Dielectric() | ThinDielectric() | Hair():
                 # Nothing to do.
                 pass
             case RoughPlastic() | Plastic():
                 if isinstance(view.material_channel.diffuse_reflectance, Texture):
                     tex = view.material_channel.diffuse_reflectance
                     view._active_attributes += apply_texture(df, tex, view.uv_attribute)
```

## hakowan/compiler/scene.py

```diff
@@ -69,8 +69,8 @@
         # factor = max_side / diag
         scale = np.eye(4)
         scale[0:3, 0:3] *= 2 / diag
 
         global_transform = scale @ translation
 
         for view in self.views:
-            view.global_transform = global_transform
+            view.global_transform = global_transform @ view.global_transform
```

## hakowan/compiler/transform.py

```diff
@@ -152,34 +152,25 @@
     view.initialize_bbox()
 
 
 def _apply_affine_transform(view: View, transform: Affine):
     df = view.data_frame
     assert df is not None
     assert transform is not None
-    mesh = df.mesh
 
     if np.shape(transform.matrix) == (4, 4):
         matrix = np.array(transform.matrix, order="F", dtype=np.float64)
     elif np.shape(transform.matrix) == (3, 3):
         matrix = np.eye(4, dtype=np.float64)
         matrix[:3, :3] = np.array(transform.matrix, order="F", dtype=np.float64)
     else:
         raise RuntimeError(
             f"Invalid affine transformation matrix with shape {np.shape(transform.matrix)}."
         )
-    lagrange.transform_mesh(mesh, matrix)
-
-    # Transform ROI box if it exists.
-    if df.roi_box is not None:
-        df.roi_box = np.array(df.roi_box, dtype=np.float64)
-        M = np.array(transform.matrix)[:3, :3]
-        df.roi_box = (M @ df.roi_box.T).T
-        if M.shape == (4, 4):
-            df.roi_box += M[:3, 3].T
+    view.global_transform = matrix @ view.global_transform
 
     # BBox must be updated after affine transform.
     logger.debug("Updating view bbox due to affine transform.")
     view.initialize_bbox()
 
 
 def _apply_compute_transform(view: View, transform: Compute):
```

## hakowan/compiler/view.py

```diff
@@ -1,8 +1,17 @@
-from ..grammar.channel import Channel, Position, Normal, Size, VectorField, BumpMap
+from ..grammar.channel import (
+    Channel,
+    Position,
+    Normal,
+    Size,
+    VectorField,
+    Covariance,
+    BumpMap,
+    NormalMap,
+)
 from ..grammar.channel.material import Material
 from ..grammar.dataframe import DataFrame
 from ..grammar.mark import Mark
 from ..grammar.scale import Attribute
 from ..grammar.transform import Transform
 from ..common import logger
 
@@ -20,41 +29,68 @@
     transform: Transform | None = None
     global_transform: npt.NDArray = field(default_factory=lambda: np.eye(4))
 
     _position_channel: Position | None = None
     _normal_channel: Normal | None = None
     _size_channel: Size | None = None
     _vector_field_channel: VectorField | None = None
+    _covariance_channel: Covariance | None = None
     _material_channel: Material | None = None
     _uv_attribute: Attribute | None = None
     _bump_map: BumpMap | None = None
+    _normal_map: NormalMap | None = None
 
     _active_attributes: list[Attribute] = field(default_factory=list)
     _bbox: npt.NDArray | None = None
 
     def initialize_bbox(self):
         assert self.data_frame is not None
         if self.data_frame.roi_box is not None:
-            self.bbox = np.asarray(self.data_frame.roi_box)
-            assert self.bbox.shape == (2, 3)
+            # df.roi_box remains the same in object reference frame.
+            transformed_roi_box = np.array(df.roi_box, dtype=np.float64)
+            assert transformed_roi_box.shape == (2, 3)
+            roi_min = transformed_roi_box[0]
+            roi_max = transformed_roi_box[1]
+            roi_corner = np.array(
+                [
+                    [roi_min[0], roi_min[1], roi_min[2], 1],
+                    [roi_min[0], roi_min[1], roi_max[2], 1],
+                    [roi_min[0], roi_max[1], roi_min[2], 1],
+                    [roi_min[0], roi_max[1], roi_max[2], 1],
+                    [roi_max[0], roi_min[1], roi_min[2], 1],
+                    [roi_max[0], roi_min[1], roi_max[2], 1],
+                    [roi_max[0], roi_max[1], roi_min[2], 1],
+                    [roi_max[0], roi_max[1], roi_max[2], 1],
+                ]
+            )
+            roi_corner = (self.global_transform @ roi_corner.T).T[:, :3]
+            self.bbox = np.array(
+                [
+                    np.amin(roi_corner, axis=0),
+                    np.amax(roi_corner, axis=0),
+                ],
+                dtype=np.float64,
+            )
         else:
             mesh = self.data_frame.mesh
             if mesh.num_vertices == 0:
                 return
 
-            bbox_min = np.amin(mesh.vertices, axis=0)
-            bbox_max = np.amax(mesh.vertices, axis=0)
+            vertices = mesh.vertices
+            vertices = (self.global_transform[:3, :3] @ vertices.T).T + self.global_transform[:3, 3].T
+            bbox_min = np.amin(vertices, axis=0)
+            bbox_max = np.amax(vertices, axis=0)
             self.bbox = np.stack([bbox_min, bbox_max])
 
     def validate(self):
         """Validate the currvent view is complete.
         A view is complete if data_frame and mark are both not None
         """
-        assert self.data_frame is not None, "View must have data_frame"
-        assert self.mark is not None, "View must have mark"
+        assert self.data_frame is not None, "Data component is not specified"
+        assert self.mark is not None, "Mark component is not specified"
 
     def finalize(self):
         """Finalize the view by updating the data frame.
 
         This function will ensure all attributes are either vertex or facet attribute.
         """
         mesh = self.data_frame.mesh
@@ -215,14 +251,26 @@
         assert isinstance(channel, VectorField)
         if isinstance(channel.data, str):
             channel.data = Attribute(name=channel.data)
         assert isinstance(channel.data, Attribute)
         self._vector_field_channel = channel
 
     @property
+    def covariance_channel(self) -> Covariance | None:
+        return self._covariance_channel
+
+    @covariance_channel.setter
+    def covariance_channel(self, channel: Covariance):
+        assert isinstance(channel, Covariance)
+        if isinstance(channel.data, str):
+            channel.data = Attribute(name=channel.data)
+        assert isinstance(channel.data, Attribute)
+        self._covariance_channel = channel
+
+    @property
     def material_channel(self) -> Material | None:
         return self._material_channel
 
     @material_channel.setter
     def material_channel(self, channel: Material):
         assert isinstance(channel, Material)
         self._material_channel = channel
@@ -246,13 +294,21 @@
         return self._bump_map
 
     @bump_map.setter
     def bump_map(self, bump_map: BumpMap | None):
         self._bump_map = bump_map
 
     @property
+    def normal_map(self) -> NormalMap | None:
+        return self._normal_map
+
+    @normal_map.setter
+    def normal_map(self, normal_map: NormalMap | None):
+        self._normal_map = normal_map
+
+    @property
     def bbox(self) -> npt.NDArray | None:
         return self._bbox
 
     @bbox.setter
     def bbox(self, value: npt.NDArray):
         self._bbox = value
```

## hakowan/grammar/channel/__init__.py

```diff
@@ -1,2 +1,2 @@
-from .channel import Channel, Position, Normal, Size, VectorField, BumpMap
+from .channel import Channel, Position, Normal, Size, VectorField, Covariance, BumpMap, NormalMap
 from .material import Medium
```

## hakowan/grammar/channel/channel.py

```diff
@@ -83,19 +83,53 @@
     data: AttributeLike
     refinement_level: int = 0
     style: CurveStyle | None = None
     end_type: str = "point"
 
 
 @dataclass(slots=True)
+class Covariance(Channel):
+    """ Covariance channel
+
+    This class is used to specify the mapping from an attribute to the covariance matrix channel.
+    The covariance channel only applies to point mark. It is represented as a per-vertex 3x3
+    symmetric matrix, which defines the stretch and rotation of the point marks.
+
+    Attributes:
+        data (AttributeLike): The attribute used to encode the covariance matrix.
+        full: (bool): If True, the full covariance matrix is stored in the attribute.
+            If False, its "square root", M, is stored. The full covariance matrix is ∑ := M @ M^T.
+            The matrix M represenst the stretch and rotation transform applied on each mark.
+        base_shape (str): The base shape of the covariance matrix. Options include "sphere" and
+            "cube". The default value is "sphere".
+    """
+
+    data: AttributeLike
+    full: bool = False
+    base_shape: str = "sphere"
+
+
+@dataclass(slots=True)
 class BumpMap(Channel):
     """Bump map channel
 
     This class specifies the bump map channel.
 
     Attributes:
         texture (TextureLike | None): The texture used to encode the bump map.
         scale (float): The scale of the bump map. The default value is 1.0.
     """
 
     texture: TextureLike
     scale: float = 1.0
+
+@dataclass(slots=True)
+class NormalMap(Channel):
+    """Normal map channel
+
+    This class specifies the normal map channel.
+
+    Attributes:
+        texture (TextureLike | None): The texture used to encode the normal map.
+    """
+
+    texture: TextureLike
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## hakowan/grammar/layer/layer.py

```diff
@@ -1,11 +1,20 @@
 from .layer_spec import LayerSpec
 from ..dataframe import DataFrame, DataFrameLike
 from ..mark import Mark
-from ..channel import Channel, Position, Normal, Size, VectorField, BumpMap
+from ..channel import (
+    Channel,
+    Position,
+    Normal,
+    Size,
+    VectorField,
+    Covariance,
+    BumpMap,
+    NormalMap,
+)
 from ..channel.material import (
     Material,
     Diffuse,
     Conductor,
     RoughConductor,
     Plastic,
     RoughPlastic,
@@ -14,14 +23,15 @@
     Dielectric,
     ThinDielectric,
     RoughDielectric,
     Hair,
 )
 from ..transform import Transform, Affine
 from ..scale import Attribute
+from ..texture import TextureLike
 
 from dataclasses import dataclass, field
 from pathlib import Path
 from typing import Optional, Sequence
 import lagrange
 import numpy as np
 import numpy.typing as npt
@@ -152,26 +162,30 @@
     def channel(
         self,
         *,
         position: Position | str | None = None,
         normal: Normal | str | None = None,
         size: float | str | Size | None = None,
         vector_field: VectorField | str | None = None,
+        covariance: Covariance | str | None = None,
         material: Material | None = None,
-        bump_map: BumpMap | None = None,
+        bump_map: BumpMap | TextureLike | None = None,
+        normal_map: NormalMap | TextureLike | None = None,
         in_place: bool = False,
     ) -> "Layer":
         """Overwrite a channel component of this layer.
 
         Args:
             position (Position | str, optional): The new position channel.
             normal (Normal | str, optional): The new normal channel.
             size (float | str | Size, optional): The new size channel.
             vector_field (VectorField | str, optional): The new vector field channel.
             material (Material, optional): The new material channel.
+            bump_map (BumpMap | TextureLike, optional): The new bump map channel.
+            normal_map (NormalMap | TextureLike, optional): The new normal map channel.
             in_place (bool, optional): Whether to modify the current layer in place or create new
                 layer. Defaults to False (i.e. create a new layer).
 
         Returns:
             result (Layer): The layer object with the channel component overwritten.
         """
         l = self.__get_working_layer(in_place)
@@ -188,30 +202,43 @@
             l._spec.channels.append(convert(position, Position))
         if normal is not None:
             assert isinstance(
                 normal, (Normal, str)
             ), f"Unsupported normal type: {type(normal)}!"
             l._spec.channels.append(convert(normal, Normal))
         if size is not None:
-            if isinstance(size, float):
-                l._spec.channels.append(Size(data=size))
+            if isinstance(size, (int, float)):
+                l._spec.channels.append(Size(data=float(size)))
             else:
                 assert isinstance(
                     size, (Size, str)
                 ), f"Unsupported size type: {type(size)}!"
                 l._spec.channels.append(convert(size, Size))
         if vector_field is not None:
             assert isinstance(
                 vector_field, (VectorField, str)
             ), f"Unsupported vector_field type: {type(vector_field)}!"
             l._spec.channels.append(convert(vector_field, VectorField))
+        if covariance is not None:
+            assert isinstance(
+                covariance, (Covariance, str)
+            ), f"Unsupported covariance type: {type(covariance)}!"
+            l._spec.channels.append(convert(covariance, Covariance))
         if material is not None:
             l._spec.channels.append(material)
         if bump_map is not None:
-            l._spec.channels.append(bump_map)
+            if isinstance(bump_map, BumpMap):
+                l._spec.channels.append(bump_map)
+            else:
+                l._spec.channels.append(BumpMap(bump_map))
+        if normal_map is not None:
+            if isinstance(normal_map, NormalMap):
+                l._spec.channels.append(normal_map)
+            else:
+                l._spec.channels.append(NormalMap(normal_map))
         return l
 
     def material(self, type: str, *args, in_place: bool = False, **kwargs) -> "Layer":
         """Overwrite material for this layer.
 
         Args:
             type (str): The material type.
```

## hakowan/grammar/texture/texture.py

```diff
@@ -31,18 +31,21 @@
 @dataclass(slots=True)
 class Image(Texture):
     """The image texture uses a texture image to provide a color field.
 
     Attributes:
         filename (PathLike): The path to the texture image.
         uv (AttributeLike): The attribute to use as the texture coordinates.
+        raw (bool): Whether to use the raw image data, i.e. use linear color transfer function.
+            This should be set to True for normal maps.
     """
 
     filename: PathLike
     uv: AttributeLike | None = None
+    raw: bool = False
 
 
 @dataclass(slots=True)
 class Checkerboard(Texture):
     """The checkerboard texture provides a checkerboard color/value field.
 
     Attributes:
```

## hakowan/render/__init__.py

```diff
@@ -1,14 +1,14 @@
 from .render import render
 from ..common import logger
 
 import mitsuba as mi
 
 if mi.variant() is None:
-    for variant in ["cuda_ad_rgb", "scalar_rgb", "llvm_ad_rgb"]:
+    for variant in ["scalar_rgb", "cuda_ad_rgb", "llvm_ad_rgb"]:
         if variant in mi.variants():
             try:
                 mi.set_variant(variant)
                 break
             except:
                 pass
     assert mi.variant() is not None
```

## hakowan/render/bsdf.py

```diff
@@ -12,15 +12,15 @@
     Principled,
     RoughConductor,
     RoughDielectric,
     RoughPlastic,
     ThinDielectric,
     ThinPrincipled,
 )
-from ..grammar.channel import BumpMap
+from ..grammar.channel import BumpMap, NormalMap
 from ..grammar.texture import Texture
 from ..common.color import ColorLike
 
 from typing import Any
 import lagrange
 
 
@@ -145,15 +145,15 @@
             n = len(metallic["values"])
         else:
             assert n == len(metallic["values"])
         get_metallic = lambda i: metallic["values"][i]
     else:
         get_metallic = lambda i: metallic
 
-    mat_name = "principled" if not thin else "thinprincipled"
+    mat_name = "principled" if not thin else "principledthin"
     base_config: dict[str, Any] = {
         "anisotropic": mat.anisotropic,
         "spec_trans": mat.spec_trans,
         "eta": mat.eta,
         "spec_tint": mat.spec_tint,
         "sheen": mat.sheen,
         "sheen_tint": mat.sheen_tint,
@@ -245,14 +245,27 @@
     return {
         "type": "bumpmap",
         "bump_texture": generate_float_color_texture_config(mesh, bump_map.texture),
         "scale": bump_map.scale,
         "bsdf": mi_config,
     }
 
+def add_normal_map(
+    mi_config: dict[str, Any],
+    mesh: lagrange.SurfaceMesh,
+    normal_map: NormalMap,
+    is_primitive: bool,
+) -> dict[str, Any]:
+    assert "type" in mi_config, "Normal map can only be applied over a single BSDF"
+    return {
+        "type": "normalmap",
+        "normalmap": generate_float_color_texture_config(mesh, normal_map.texture),
+        "bsdf": mi_config,
+    }
+
 
 def generate_bsdf_config(view: View, is_primitive=False) -> dict[str, Any]:
     assert view.data_frame is not None
     assert view.material_channel is not None
     mesh = view.data_frame.mesh
     material_config: dict[str, Any] = {}
     match view.material_channel:
@@ -305,8 +318,13 @@
         material_config = make_material_two_sided(material_config)
 
     if view.bump_map is not None:
         material_config = add_bump_map(
             material_config, mesh, view.bump_map, is_primitive
         )
 
+    if view.normal_map is not None:
+        material_config = add_normal_map(
+            material_config, mesh, view.normal_map, is_primitive
+        )
+
     return material_config
```

## hakowan/render/render.py

```diff
@@ -34,28 +34,24 @@
         mi_config[f"emitter_{i:03}"] = generate_emitter_config(config.emitters[i])
 
     return mi_config
 
 
 def generate_view_config(view: View, stamp: str, index: int):
     """Generate a Mitsuba shape description dict from a View."""
-    shapes = []
 
     # Generate shape.
     match view.mark:
         case mark.Point:
-            shapes = generate_point_config(view)
+            mi_config = generate_point_config(view, stamp, index)
         case mark.Curve:
-            shapes.append(generate_curve_config(view, stamp, index))
+            mi_config = generate_curve_config(view, stamp, index)
         case mark.Surface:
-            shapes.append(generate_surface_config(view, stamp, index))
+            mi_config = generate_surface_config(view, stamp, index)
 
-    mi_config = {
-        f"view_{index:03}_shape_{i:06}": shape for i, shape in enumerate(shapes)
-    }
     return mi_config
 
 
 def generate_scene_config(scene: Scene) -> dict:
     """Generate a mitsuba scene description dict from a Scene."""
     stamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
     scene_config: dict[str, Any] = {}
```

## hakowan/render/shape.py

```diff
@@ -1,8 +1,9 @@
 from .bsdf import generate_bsdf_config
+from .icosphere import create_icosphere
 from .medium import generate_medium_config
 from ..common import logger
 from ..compiler import View
 from ..grammar.scale import Attribute
 from ..grammar.channel.curvestyle import Bend
 from ..grammar.channel.material import Dielectric
 
@@ -42,52 +43,121 @@
                 raise NotImplementedError(
                     f"Unsupported size channel type: {type(view.size_channel.data)}"
                 )
     else:
         return default_size
 
 
-def generate_point_config(view: View):
+def extract_transform_from_covariances(view: View):
+    """Extract the affine transform from covariance attribute from a view.
+
+    :param view: The view to extract covariance from.
+
+    :return: A list of n 3x3 affine transform matrices, M,
+        where the covariance matrix is M @ M^T.
+    """
+    assert view.data_frame is not None
+    mesh = view.data_frame.mesh
+
+    assert view.covariance_channel is not None
+    assert isinstance(view.covariance_channel.data, Attribute)
+    attr_name = view.covariance_channel.data._internal_name
+    assert attr_name is not None
+    assert mesh.has_attribute(attr_name)
+
+    attr = mesh.attribute(attr_name)
+    assert attr.element_type == lagrange.AttributeElement.Vertex
+    assert attr.data.shape[1] == 9
+    if view.covariance_channel.full:
+        sigma = attr.data.reshape(-1, 3, 3)
+        U, S, Vh = np.linalg.svd(sigma)
+        S_diag = np.apply_along_axis(lambda _s: np.diag(_s), 1, S)
+        return U @ np.sqrt(S_diag)
+    else:
+        return attr.data.reshape(-1, 3, 3)
+
+
+def generate_point_config(view: View, stamp: str, index: int):
     """Generate point cloud shapes from a View."""
     assert view.data_frame is not None
     mesh = view.data_frame.mesh
     shapes: list[dict[str, Any]] = []
+    shape_group: dict[str, Any] = {}
 
-    # Compute radii
-    radii = extract_size(view)
-    if np.isscalar(radii):
-        radii = [radii] * mesh.num_vertices
-
-    # Generate spheres.
-    assert len(radii) == mesh.num_vertices
-    global_transform = mi.ScalarTransform4f(view.global_transform)  # type: ignore
-    shapes = list(
-        map(
-            lambda itr: {
-                "type": "sphere",
-                "center": itr[1].tolist(),
-                "radius": radii[itr[0]],
-                "to_world": global_transform,
-            },
-            enumerate(mesh.vertices),
+    if view.covariance_channel is None:
+        # Compute radii
+        radii = extract_size(view)
+        if np.isscalar(radii):
+            radii = [radii] * mesh.num_vertices
+        assert len(radii) == mesh.num_vertices
+
+        # Generate spheres.
+        global_transform = mi.ScalarTransform4f(view.global_transform)  # type: ignore
+        shapes = list(
+            map(
+                lambda itr: {
+                    "type": "sphere",
+                    "center": itr[1].tolist(),
+                    "radius": radii[itr[0]],
+                    "to_world": global_transform,
+                },
+                enumerate(mesh.vertices),
+            )
         )
-    )
+    else:
+        # Generate base shape config.
+        match view.covariance_channel.base_shape:
+            case "sphere":
+                # Generate point mark shape.
+                sphere = create_icosphere(1)
+                tmp_dir = pathlib.Path(tempfile.gettempdir())
+                filename = tmp_dir / f"{stamp}-view-{index:03}.ply"
+                logger.debug(f"Saving point mark shape to '{str(filename)}'.")
+                lagrange.io.save_mesh(filename, sphere)  # type: ignore
+                base_shape_config = {
+                    "type": "ply",
+                    "filename": str(filename.resolve()),
+                    "face_normals": False,
+                }
+            case "cube":
+                base_shape_config = {"type": "cube"}
+
+        # Compute radii, with default radii as 1.
+        radii = extract_size(view, 1)
+        if np.isscalar(radii):
+            radii = [radii] * mesh.num_vertices
+        assert len(radii) == mesh.num_vertices
+
+        M = extract_transform_from_covariances(view)
+        global_transform = mi.ScalarTransform4f(view.global_transform)  # type: ignore
+        for i, v in enumerate(mesh.vertices):
+            local_transform = np.eye(4)
+            local_transform[:3, :3] = M[i] * radii[i]
+            local_transform[:3, 3] = v
+            local_transform = mi.ScalarTransform4f(local_transform)  # type: ignore
+            shape = base_shape_config.copy()
+            shape["to_world"] = global_transform @ local_transform
+            shapes.append(shape)
 
     # Generate bsdf
     bsdfs = generate_bsdf_config(view, is_primitive=True)
     if "type" in bsdfs:
         # Single bsdf
         bsdf = bsdfs
         for shape in shapes:
             shape["bsdf"] = bsdf
     else:
         assert len(bsdfs) == len(shapes)
         for (bsdf_id, bsdf), shape in zip(bsdfs.items(), shapes):
             shape[bsdf_id] = bsdf
-    return shapes
+
+    mi_config: dict[str, Any] = {
+        f"view_{index:03}_shape_{i:06}": shape for i, shape in enumerate(shapes)
+    }
+    return mi_config
 
 
 def extract_vector_field(view: View):
     assert view.data_frame is not None
     mesh = view.data_frame.mesh
 
     assert view.vector_field_channel is not None
@@ -276,18 +346,20 @@
                 fout.write(f"{p3[0]} {p3[1]} {p3[2]} {s3 * scale_correction_factor}\n")
                 fout.write(f"{p3[0]} {p3[1]} {p3[2]} {s3 * scale_correction_factor}\n")
                 fout.write(
                     f"{p3[0]} {p3[1]} {p3[2]} {s3 * scale_correction_factor}\n\n"
                 )
 
     mi_config = {
-        "type": curve_type,
-        "filename": str(filename.resolve()),
-        "bsdf": generate_bsdf_config(view, is_primitive=False),
-        "to_world": mi.ScalarTransform4f(view.global_transform),  # type: ignore
+        f"view_{index:03}_shape_000000": {
+            "type": curve_type,
+            "filename": str(filename.resolve()),
+            "bsdf": generate_bsdf_config(view, is_primitive=False),
+            "to_world": mi.ScalarTransform4f(view.global_transform),  # type: ignore
+        }
     }
     return mi_config
 
 
 def _rename_attributes(mesh: lagrange.SurfaceMesh, active_attributes: list[Attribute]):
     """Rename generic scalar and vector attribute with suffix "_0". This is required by mitsuba to
     correct parse them from a ply file.
@@ -375,8 +447,9 @@
     if (
         view.material_channel is not None
         and isinstance(view.material_channel, Dielectric)
         and view.material_channel.medium is not None
     ):
         mi_config["interior"] = generate_medium_config(view)
 
+    mi_config = {f"view_{index:03}_shape_000000": mi_config}
     return mi_config
```

## hakowan/render/texture.py

```diff
@@ -37,17 +37,20 @@
 
 
 def generate_image_config(tex: Image) -> dict:
     filename = Path(tex.filename)
     mi_config: dict[str, Any] = {
         "type": "bitmap",
         "filename": str(filename.resolve()),
+        "raw": tex.raw,
         # Note that we need to flip the image vertically to match the
         # orientation of the Mitsuba coordinate system.
-        "to_uv": mi.ScalarTransform3f([[1, 0, 0], [0, -1, 0], [0, 0, 1]]),  # type: ignore
+        "to_uv": mi.ScalarTransform4f(  # type: ignore
+            [[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
+        ),
     }
     return mi_config
 
 
 def generate_checker_board_config(
     mesh: lagrange.SurfaceMesh, tex: Checkerboard, is_color: bool
 ) -> dict:
```

## Comparing `hakowan-0.3.3.dist-info/LICENSE` & `hakowan-0.3.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `hakowan-0.3.3.dist-info/METADATA` & `hakowan-0.3.4.dist-info/METADATA`

 * *Files 18% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 Metadata-Version: 2.1
 Name: hakowan
-Version: 0.3.3
+Version: 0.3.4
 Summary: Hakowan: A 3D data visualization grammer 
 Author-email: Qingnan Zhou <qnzhou@gmail.com>, Zhicheng Liu <leozcliu@umd.edu>
 Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 Classifier: License :: OSI Approved :: Apache Software License
-Requires-Dist: lagrange-open~=6.21
+Requires-Dist: lagrange-open~=6.22
 Requires-Dist: mitsuba~=3.4
 Requires-Dist: numpy>=1.22
 
 # Hakowan
 Hakowan is a 3D data visualization grammar. It is inspired by the grammar of graphics, and it is
 designed for easily creating beautiful 3D visualizations.
```

## Comparing `hakowan-0.3.3.dist-info/RECORD` & `hakowan-0.3.4.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-hakowan/__init__.py,sha256=OM4dLEUModmIh-_pTUAZ3778zeirxBNrSIM9TukmlXs,546
+hakowan/__init__.py,sha256=2_Dx1JirMPAHeitjjYhEPMPaIGNy4muMQ9meAUNuPt8,546
 hakowan/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 hakowan/common/__init__.py,sha256=Es4t__Ougt4aIMVKMOgjGs9aOXiEJrs5teaNhaMPQwQ,27
 hakowan/common/color.py,sha256=OYVuD8LeWn6Loa7Dj6k_Rm6s8shU_mBAxim8thchD7s,1965
 hakowan/common/default.py,sha256=h-4Xlqzd9T7QV3_NMy_tcKHGLX1jTcx0tMqav5rUN0s,265
 hakowan/common/envmaps.py,sha256=Jr3lEsdQfJOQzDkP4NwrKTXUFECTLHZpji-9dBhwix8,135
 hakowan/common/exception.py,sha256=DtdFVsD2dcqJkOdMKYlzBU4VoIC2IE0u4Hi7VbNACIE,131
 hakowan/common/logger.py,sha256=NSoSPOVvjpOwWCzrb9GQjYXG1NHgsBQj5KcyoqMaHS8,117
@@ -16,63 +16,64 @@
 hakowan/common/colormap/magma.py,sha256=YHBr21VsBJUi4w9M8ssaobGJcN069UcHXEGDpnU5tgM,11515
 hakowan/common/colormap/named_colormaps.py,sha256=nlUscHOuyHU2DrOAhe2ERFNPv7eifTGdXdukwkWL810,575
 hakowan/common/colormap/plasma.py,sha256=UtOEEi2bDnJze6I4QBC6EbMU7nPPXQkkP_zs5H8nqss,11517
 hakowan/common/colormap/turbo.py,sha256=q9IEw3A2SQvJvjsREqLnnRan2QKfD5G8zjUheo_4Aok,10794
 hakowan/common/colormap/viridis.py,sha256=41EUbAYyUrPImo6vmWN7Y4CNE1e1WZ6Oa2wSlwENH4Y,11519
 hakowan/compiler/__init__.py,sha256=tA-nLriuWMbhV0WtcFUPmzGYI3zWEIfgU88WjTzeNxs,106
 hakowan/compiler/attribute.py,sha256=zhQZvUV2n3MaJduMy9xXoUw3owZdT1CTBejRWM1ebCo,10577
-hakowan/compiler/channel.py,sha256=u673eSx-gu6sE26ZwrsYG4Ex2LqHYIUgoIF2CYkO6Mg,7476
+hakowan/compiler/channel.py,sha256=lzg1nySwGwvkGMvpiVEtMy_Q6SqnpEx2Nzpah1ID_A0,8519
 hakowan/compiler/color.py,sha256=dP3xsToRoWVBpk7h6bvegx1ZXOloVz27BBPDwWMkUXU,4044
 hakowan/compiler/compile.py,sha256=3A_Ea-86azpReUJU99gghc5WfeYwDXcnT8GqS25Key0,2548
-hakowan/compiler/scene.py,sha256=RRQJ6eWUULvgQwjU-PhkKawa0MLAvi-7lKpE_ULPztI,2030
+hakowan/compiler/scene.py,sha256=Zlf5mqgw_Ia__3Ed8oFmov4RsVa6IM3-UGuvusD150Q,2054
 hakowan/compiler/texture.py,sha256=-wrINMWkyhN8i4dk7lzGxmQxMa94GlZ5LjC5kex1RiI,8690
-hakowan/compiler/transform.py,sha256=6AsZzNG8U7LFcuaPxI6-fkal1T9NM2h77yhFcqeGtJM,11916
+hakowan/compiler/transform.py,sha256=Kj6wgHaPD3GUVIOzV7jdGgXWRaMk37WahdbM6djl4K4,11628
 hakowan/compiler/utils.py,sha256=_FPSZwRAO6sDfZZEbSlQ8voKYU7qfop59h02EtSgVYI,478
-hakowan/compiler/view.py,sha256=F-01fWfv4Vquxgu96-k8JcXQAYrudmmf6PxrFkWmL1s,9320
+hakowan/compiler/view.py,sha256=OVDm1aJ3SCQJ_ZgimRQz9e7KzrkXOcjRxSQx30sbYXU,11311
 hakowan/envmaps/README.md,sha256=II8qn_GiLnrMP1dme2jz7gw2H7CgE93_NCNfAqNPFyI,292
 hakowan/envmaps/museum.exr,sha256=jji5kECaqM5KbOloAay-uuvxw8mVFPsPrBuQnuPTV9k,426040
 hakowan/grammar/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-hakowan/grammar/channel/__init__.py,sha256=hu3XUiAc6E3in2ZSoG5YD7LP0FP_1Fk_alTXd2IoPMU,104
-hakowan/grammar/channel/channel.py,sha256=injxVn5FAqqFrd87n4jBa3w8nJJxBGxK7k0AKm0touc,3152
+hakowan/grammar/channel/__init__.py,sha256=r4B7q9GGvXFb5mw957SrATv8zPLj0DoNIBf0r3L21EQ,127
+hakowan/grammar/channel/channel.py,sha256=-2J9TCkyTrPQw27DkMMp5JlXSEKGjkopB3HqVZPEO80,4375
 hakowan/grammar/channel/curvestyle.py,sha256=um0-id1cf2y76osuP0psxlRK6lSvdTWXssXse0Ftrrs,476
 hakowan/grammar/channel/material/__init__.py,sha256=l4wAnbE8F9agPWkwmui7C6GrtfSgR4tofyDF_m7XodY,250
 hakowan/grammar/channel/material/material.py,sha256=qfYv75FiOZmegswRSCDWff6BAO1YblVaIAG7MrU1PSc,3766
 hakowan/grammar/channel/material/medium.py,sha256=l2BRc7RxFmY5shliMqe4ZxTikubn6sWu3IZSWqnL_-Q,366
 hakowan/grammar/dataframe/__init__.py,sha256=FSTbsha_pZPaVYQlZDj6c1O0S0OR9YxduO4g4_ZKnWI,48
 hakowan/grammar/dataframe/dataframe.py,sha256=-8I5UfknuaEIBUXNAnwVLPNay5iNMDW_dvg_pxhQBZw,1279
 hakowan/grammar/layer/__init__.py,sha256=rUK8cKRc_4TLUve8KToqkRDT08nGAdyhRJXNnS_WET4,25
-hakowan/grammar/layer/layer.py,sha256=bjJxBe0dY-wz7Gtv7JiHfXpfKjvOjbHUcdF_psRAlkg,13160
+hakowan/grammar/layer/layer.py,sha256=SKiRCRNUDkI8Nt9-qqx_94O-xhZUhwth9CJ_kxW21Do,14156
 hakowan/grammar/layer/layer_spec.py,sha256=b9HxiVCq35GatEuab_I6GbYx3zKCKvw23TpDw1AC_hA,416
 hakowan/grammar/mark/__init__.py,sha256=dTMweYPxH1N_SzlpFmDQttk6OHFZRRtjOVLNjpiJe0Y,46
 hakowan/grammar/mark/mark.py,sha256=gDJl9ZYoT2QFsNuhkwpdPoFiu_EM0flCR7IVxMylx7w,375
 hakowan/grammar/scale/__init__.py,sha256=JhKpNd03udnmkcqg6FFrQ9xOgCn9ttM0W9Ok-yLGGOs,158
 hakowan/grammar/scale/attribute.py,sha256=Rye5DSRAt4dOPjrbAWONzBekRYNZ2e6H0g_xrK3pTxI,1301
 hakowan/grammar/scale/offset.py,sha256=k74iahzhD9OoeQhgIHozdbDD5DmQW7RsnyXPOd2pS7c,285
 hakowan/grammar/scale/scale.py,sha256=UF0YgXJZQXiCpdAD_QLgbtvjdYqpZCfE2V_b7OMjtt0,2887
 hakowan/grammar/texture/__init__.py,sha256=22AvZjOML-F14nsVXopKGXPasdIxtIxybiJQUQ01k5I,23
-hakowan/grammar/texture/texture.py,sha256=T_Am7STfU5AAHdXN2UAujURnuzjfOt2S_wNeG__gIvU,3154
+hakowan/grammar/texture/texture.py,sha256=SoLcCJvL2yJ8BnUlaNmEeyVraPs7fLEWHnmD8Xa8hmk,3328
 hakowan/grammar/transform/__init__.py,sha256=dENM5wNH4Xils3v7SAh-xc5BVR5awJltaqjI-SEJhQU,25
 hakowan/grammar/transform/transform.py,sha256=hYwZpvdOkgze3LsuxPJBVpzUTnKUmNDJd0FdCVLymLs,3737
-hakowan/render/__init__.py,sha256=cdlmUJlayqdbxpUXLw8ZRCRMo63PNnmKQT0X5WmQQtc,361
-hakowan/render/bsdf.py,sha256=-DIQBFke3SBDQ157TXxoHYQZ1Fadye-GY34b8NWCqPc,9953
+hakowan/render/__init__.py,sha256=yyuJL_k1dQH5hAmcslrlLtym0V4gu1lnrL0BdSkUHMo,361
+hakowan/render/bsdf.py,sha256=ldK7Sd9sfDi4lbetEZdjd0DvkD-78brDZFW7g97Fvt4,10517
 hakowan/render/color.py,sha256=vYggCpD8p_ixmyj80Amw_A1-TdvHQbDfgz9H7A3IMpg,200
 hakowan/render/emitter.py,sha256=3hREbf-Ri_9lZdG_nbHNw_vBvcict-4bdjqmeABUCco,1344
 hakowan/render/film.py,sha256=PEiqPkbvQmn1dwyI-kXy6vHiAflCTLtagMMs7ysIdsE,623
+hakowan/render/icosphere.py,sha256=MvaU4gD4tl0biLergDLttuOgbNbcvekxS13VkR8-Mrc,3095
 hakowan/render/integrator.py,sha256=hp7kZtoXbTSmMqP6XQZaDbBdC8DeaHiYn1mqTfr3Flg,1798
 hakowan/render/medium.py,sha256=-S1vk4dMfTeXFT26hl9KfwbbnAjzHYv2ooiLMHxy5xs,950
-hakowan/render/render.py,sha256=RkJ_UVwHQC_7jWY3dEd7eeZGBlOz8tGLhGjZnBUBZu8,4133
+hakowan/render/render.py,sha256=-aw86oyuKS1dcYHcj1DfseL1aRHsRBCFwLiUvBk6zu4,4023
 hakowan/render/sampler.py,sha256=3UCcVgqPbTMc-JkB9E5_ud5DFoM5Lr80Bb92Gxm7mIo,587
 hakowan/render/sensor.py,sha256=U_sEVoDiK_kH-XZEeGiDEYLcf-HZMl5_GEL71mYOZ3g,1057
-hakowan/render/shape.py,sha256=x_AA7Z-VPiGak4ZAsYldcwo9OdiNun8TtyJDOVmswJQ,14360
+hakowan/render/shape.py,sha256=csDffoMV4bn1TbbL-9mXS-sFfbK1fK91KvZ8d_WLYS4,17387
 hakowan/render/spectrum.py,sha256=Y2Dee9Ld8s0pbKPtfIjhRsFOKhDjRCfBMz_PPj_oJ9w,593
-hakowan/render/texture.py,sha256=EcFIFsh1EUpeuA8y168qYB6_Z_a64o8GoNXDIwRVSVU,4662
+hakowan/render/texture.py,sha256=nb_chofhfs1v8NSI7RbZBuyDJhLgKMGIecQRY9RiTn4,4731
 hakowan/setup/__init__.py,sha256=nD9QWvUI4fRlQeAfsUuMJOB93cT3xSIrsthAb5695NE,137
 hakowan/setup/config.py,sha256=HVITR-k3fRwq4OJqYpczpV_cnoNimslvSvxBgSI-U0s,3410
 hakowan/setup/emitter.py,sha256=Hs-WN1cPABCMu-AhdGmE6fwFkE010_xtOQQDoEBNvQc,1096
 hakowan/setup/film.py,sha256=HwdV2930tfFElp58rrmYg7tRhMR4cMoi6rus7VfE4CQ,1144
 hakowan/setup/integrator.py,sha256=KlWcwrYFyil7mXd6jyGNlN6GoUYkxXtmfvNQBgC7OKQ,3123
 hakowan/setup/sampler.py,sha256=iyZdHyZsnxOsBOKs8934dG9GzggaZ-WLmX8dJj5NEpg,1009
 hakowan/setup/sensor.py,sha256=SSPu__qxSGafaaToBqP1QutHCOzedezg1JQijUk-UtA,1441
-hakowan-0.3.3.dist-info/LICENSE,sha256=hr3V2vq3dFEES2_W0u-rI-NBDOZY6wl_BMBPT1Su1i8,11335
-hakowan-0.3.3.dist-info/WHEEL,sha256=EZbGkh7Ie4PoZfRQ8I0ZuP9VklN_TvcZ6DSE5Uar4z4,81
-hakowan-0.3.3.dist-info/METADATA,sha256=1-EoUkz9-Px9Axw6BVPL4Uhpe5BINIhDDfpBWt29kwg,1266
-hakowan-0.3.3.dist-info/RECORD,,
+hakowan-0.3.4.dist-info/LICENSE,sha256=hr3V2vq3dFEES2_W0u-rI-NBDOZY6wl_BMBPT1Su1i8,11335
+hakowan-0.3.4.dist-info/WHEEL,sha256=EZbGkh7Ie4PoZfRQ8I0ZuP9VklN_TvcZ6DSE5Uar4z4,81
+hakowan-0.3.4.dist-info/METADATA,sha256=pfg4dwrmHb4clEZvmFu-eNtTtU5-gq1lBTxuW0F8ixk,1266
+hakowan-0.3.4.dist-info/RECORD,,
```

