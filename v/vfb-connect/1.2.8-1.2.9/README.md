# Comparing `tmp/vfb_connect-1.2.8.tar.gz` & `tmp/vfb_connect-1.2.9.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/vfb_connect-1.2.8.tar", last modified: Wed Jun  1 11:41:10 2022, max compression
+gzip compressed data, was "dist/vfb_connect-1.2.9.tar", last modified: Thu Feb 23 13:05:08 2023, max compression
```

## Comparing `vfb_connect-1.2.8.tar` & `vfb_connect-1.2.9.tar`

### file list

```diff
@@ -1,29 +1,29 @@
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/
--rw-r--r--   0 runner    (1001) docker     (116)    35149 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/LICENSE
--rw-r--r--   0 runner    (1001) docker     (116)     2636 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (116)     1902 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/README.md
--rw-r--r--   0 runner    (1001) docker     (116)       38 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (116)     1878 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/src/
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/src/vfb_connect/
--rw-r--r--   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/src/vfb_connect/__init__.py
--rw-r--r--   0 runner    (1001) docker     (116)    19426 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/src/vfb_connect/cross_server_tools.py
--rw-r--r--   0 runner    (1001) docker     (116)      346 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/src/vfb_connect/default_servers.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/src/vfb_connect/neo/
--rw-r--r--   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/src/vfb_connect/neo/__init__.py
--rw-r--r--   0 runner    (1001) docker     (116)    10447 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/src/vfb_connect/neo/neo4j_tools.py
--rw-r--r--   0 runner    (1001) docker     (116)    20748 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/src/vfb_connect/neo/query_wrapper.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/src/vfb_connect/neo/test/
--rw-r--r--   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/src/vfb_connect/neo/test/__init__.py
--rw-r--r--   0 runner    (1001) docker     (116)     2673 2022-06-01 11:41:02.000000 vfb_connect-1.2.8/src/vfb_connect/neo/test/neo_tools_tests.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/src/vfb_connect/owl/
--rw-r--r--   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:03.000000 vfb_connect-1.2.8/src/vfb_connect/owl/__init__.py
--rw-r--r--   0 runner    (1001) docker     (116)     7113 2022-06-01 11:41:03.000000 vfb_connect-1.2.8/src/vfb_connect/owl/owlery_query_tools.py
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/src/vfb_connect/resources/
--rw-r--r--   0 runner    (1001) docker     (116)    35955 2022-06-01 11:41:03.000000 vfb_connect-1.2.8/src/vfb_connect/resources/VFB_TermInfo_queries.json
-drwxr-xr-x   0 runner    (1001) docker     (116)        0 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/src/vfb_connect.egg-info/
--rw-r--r--   0 runner    (1001) docker     (116)     2636 2022-06-01 11:41:09.000000 vfb_connect-1.2.8/src/vfb_connect.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (116)      632 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/src/vfb_connect.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (116)        1 2022-06-01 11:41:09.000000 vfb_connect-1.2.8/src/vfb_connect.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (116)       28 2022-06-01 11:41:09.000000 vfb_connect-1.2.8/src/vfb_connect.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (116)       12 2022-06-01 11:41:10.000000 vfb_connect-1.2.8/src/vfb_connect.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/
+-rw-r--r--   0 runner    (1001) docker     (116)    35149 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (116)     2636 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (116)     1902 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/README.md
+-rw-r--r--   0 runner    (1001) docker     (116)       38 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (116)     1878 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/
+drwxr-xr-x   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect/
+-rw-r--r--   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (116)    19426 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/cross_server_tools.py
+-rw-r--r--   0 runner    (1001) docker     (116)      346 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/default_servers.py
+drwxr-xr-x   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect/neo/
+-rw-r--r--   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/neo/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (116)    10447 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/neo/neo4j_tools.py
+-rw-r--r--   0 runner    (1001) docker     (116)    20717 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/neo/query_wrapper.py
+drwxr-xr-x   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect/neo/test/
+-rw-r--r--   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/neo/test/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (116)     2673 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/neo/test/neo_tools_tests.py
+drwxr-xr-x   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect/owl/
+-rw-r--r--   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/owl/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (116)     7113 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/owl/owlery_query_tools.py
+drwxr-xr-x   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect/resources/
+-rw-r--r--   0 runner    (1001) docker     (116)    44699 2023-02-23 13:05:06.000000 vfb_connect-1.2.9/src/vfb_connect/resources/VFB_TermInfo_queries.json
+drwxr-xr-x   0 runner    (1001) docker     (116)        0 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (116)     2636 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (116)      632 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (116)        1 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (116)       28 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (116)       12 2023-02-23 13:05:08.000000 vfb_connect-1.2.9/src/vfb_connect.egg-info/top_level.txt
```

### Comparing `vfb_connect-1.2.8/LICENSE` & `vfb_connect-1.2.9/LICENSE`

 * *Files identical despite different names*

### Comparing `vfb_connect-1.2.8/PKG-INFO` & `vfb_connect-1.2.9/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: vfb_connect
-Version: 1.2.8
+Version: 1.2.9
 Summary: Wrapper for querying VirtualFlyBrain servers.
 Home-page: https://github.com/VirtualFlyBrain/VFB_connect
 Author: David Osumi-Sutherland
 Author-email: dosumis@gmail.com
 Project-URL: Bug Reports, https://github.com/VirtualFlyBrain/VFB_connect/issues
 Project-URL: Source, https://github.com/VirtualFlyBrain/VFB_connect
 Project-URL: Documentation, https://vfb-connect.readthedocs.io/en/stable/
```

### Comparing `vfb_connect-1.2.8/README.md` & `vfb_connect-1.2.9/README.md`

 * *Files identical despite different names*

### Comparing `vfb_connect-1.2.8/setup.py` & `vfb_connect-1.2.9/setup.py`

 * *Files identical despite different names*

### Comparing `vfb_connect-1.2.8/src/vfb_connect/cross_server_tools.py` & `vfb_connect-1.2.9/src/vfb_connect/cross_server_tools.py`

 * *Files identical despite different names*

### Comparing `vfb_connect-1.2.8/src/vfb_connect/neo/neo4j_tools.py` & `vfb_connect-1.2.9/src/vfb_connect/neo/neo4j_tools.py`

 * *Files identical despite different names*

### Comparing `vfb_connect-1.2.8/src/vfb_connect/neo/query_wrapper.py` & `vfb_connect-1.2.9/src/vfb_connect/neo/query_wrapper.py`

 * *Files 0% similar despite different names*

```diff
@@ -406,26 +406,26 @@
         else:
             return self._query(qs)
 
     def _get_anatomical_individual_TermInfo_by_type(self, classification, summary=False):
         typ = 'Get JSON for Individual:Anatomy_by_type'
         qs = Template(self.queries[typ]).substitute(ID=classification)
         if summary:
-            return self._termInfo_2_summary(self._query(qs), typ='Get JSON for Individual:Anatomy')
+            return self._termInfo_2_summary(self._query(qs), typ='Get JSON for Individual')
         else:
             return self._query(qs)
 
     def _termInfo_2_summary(self, TermInfo, typ):
         # type_2_summary = {
-        #     'Get JSON for Individual:Anatomy': '_populate_instance_summary_tab',
+        #     'Get JSON for Individual': '_populate_instance_summary_tab',
         #     'Get JSON for Class': '_populate_anatomical_entity_summary',
         # }
         dc = []
         for r in TermInfo:
-            if typ == 'Get JSON for Individual:Anatomy':
+            if typ == 'Get JSON for Individual':
                 dc.append(_populate_instance_summary_tab(r))
             elif typ == 'Get JSON for Class':
                 dc.append(_populate_anatomical_entity_summary(r))
             elif typ == 'Get JSON for DataSet':
                 dc.append(_populate_dataset_summary_tab(r))
         return dc
 
@@ -433,15 +433,15 @@
         """
         Generate JSON reports for anatomical individuals from a list of VFB IDs (short_forms)
 
         :param short_forms: An iterable (e.g. a list) of VFB IDs (short_forms) of anatomical individuals
         :param summary: Optional.  Returns summary reports if `True`. Default `False`
         :rtype: list of VFB_json or summary_report_json
         """
-        return self._get_TermInfo(short_forms, typ='Get JSON for Individual:Anatomy', summary=summary)
+        return self._get_TermInfo(short_forms, typ='Get JSON for Individual', summary=summary)
 
     def get_type_TermInfo(self, short_forms, summary=False):
         """
         Generate JSON reports for types from a list of VFB IDs (short_forms) of classes/types.
 
         :param short_forms: An iterable (e.g. a list) of VFB IDs (short_forms) of types
         :param summary: Optional.  Returns summary reports if `True`. Default `False`
@@ -463,8 +463,8 @@
         """
         Generate JSON reports for types from a list of VFB IDs (short_forms) of templates.
 
         :param short_forms: An iterable (e.g. a list) of VFB IDs (short_forms) of types
         :param summary: Optional.  Returns summary reports if `True`. Default `False`
         :rtype: list of VFB_json or summary_report_json
         """
-        return self._get_TermInfo(short_forms, typ='Get JSON for Template')
+        return self._get_TermInfo(short_forms, typ='Get JSON for Template')
```

### Comparing `vfb_connect-1.2.8/src/vfb_connect/neo/test/neo_tools_tests.py` & `vfb_connect-1.2.9/src/vfb_connect/neo/test/neo_tools_tests.py`

 * *Files identical despite different names*

### Comparing `vfb_connect-1.2.8/src/vfb_connect/owl/owlery_query_tools.py` & `vfb_connect-1.2.9/src/vfb_connect/owl/owlery_query_tools.py`

 * *Files identical despite different names*

### Comparing `vfb_connect-1.2.8/src/vfb_connect/resources/VFB_TermInfo_queries.json` & `vfb_connect-1.2.9/src/vfb_connect/resources/VFB_TermInfo_queries.json`

 * *Files 26% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.4%*

 * *Differences: {"'Get JSON for Class'": '"MATCH (primary:Class) WHERE primary.short_form in [\'$ID\'] WITH '*

 * *                         'primary OPTIONAL MATCH (o:Class)<-[r:SUBCLASSOF|INSTANCEOF]-(primary) '*

 * *                         'WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: '*

 * *                         "o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), "*

 * *                         'unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: '*

 * *                         "coalesc [â€¦]*

```diff
@@ -1,11 +1,11 @@
 {
-    "Get JSON for Class": "MATCH (primary:Class) WHERE primary.short_form in ['$ID']  \nWITH primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary)  \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')} ) END AS parents ,primary OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')}  }) END AS relationships ,primary,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(dbx.accession[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,parents,relationships CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] -&gt;(template:Individual)-[:depicts]-&gt; (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 5', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class)  \nWITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.`symbol`[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,primary,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]-&gt;(p:pub) where rp.typ = 'syn' \nWITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.`symbol`[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } , synonym: { label: coalesce(rp.value[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(rp.has_synonym_type[0],'') }  }) END AS pub_syn,primary,parents,relationships,xrefs,anatomy_channel_image OPTIONAL MATCH (primary)-[rp:has_reference]-&gt;(p:pub) WHERE rp.typ = 'def'  \nWITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.`symbol`[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } ) END AS def_pubs,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Class' AS query, '44725ae' AS version , parents, relationships, xrefs, anatomy_channel_image, pub_syn, def_pubs",
-    "Get JSON for DataSet": "MATCH (primary:DataSet) WHERE primary.short_form in ['$ID']  \nWITH primary CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] -&gt;(template:Individual)-[:depicts]-&gt; (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 5', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class)  \nWITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.`symbol`[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,primary OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, anatomy_channel_image OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(dbx.accession[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,anatomy_channel_image OPTIONAL MATCH (primary)-[:has_license]-&gt;(l:License) \nWITH collect ({ icon : coalesce(l.license_logo[0], ''), link : coalesce(l.license_url[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), symbol: coalesce(l.`symbol`[0], '')}  }) as license,primary,anatomy_channel_image,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]-&gt;(p:pub)  \nWITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.`symbol`[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } ) END AS pubs,primary,anatomy_channel_image,xrefs,license OPTIONAL MATCH (primary)&lt;-[:has_source]-(i:Individual) WITH  i, primary, anatomy_channel_image, xrefs, license, pubs OPTIONAL MATCH (i)-[:INSTANCEOF]-(c:Class) \nWITH DISTINCT { images: count(distinct i),types: count(distinct c) } as dataset_counts,primary,anatomy_channel_image,xrefs,license,pubs RETURN { link : coalesce(primary.dataset_link[0], ''), core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for DataSet' AS query, '44725ae' AS version , anatomy_channel_image, xrefs, license, pubs, dataset_counts",
-    "Get JSON for Individual:Anatomy": "MATCH (primary:Individual:Anatomy) WHERE primary.short_form in ['$ID']  \nWITH primary OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license]-&gt;(l:License) \nWITH COLLECT ({ dataset: { link : coalesce(ds.dataset_link[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), symbol: coalesce(ds.`symbol`[0], '')}  }, license: { icon : coalesce(l.license_logo[0], ''), link : coalesce(l.license_url[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), symbol: coalesce(l.`symbol`[0], '')}  }}) AS dataset_license,primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary)  \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')} ) END AS parents ,primary,dataset_license OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')}  }) END AS relationships ,primary,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(dbx.accession[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,dataset_license,parents,relationships OPTIONAL MATCH (primary)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]-&gt;(template:Individual)-[:depicts]-&gt;(template_anat:Individual) WITH template, channel, template_anat, irw, primary, dataset_license, parents, relationships, xrefs   OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class)  \nWITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary,dataset_license,parents,relationships,xrefs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Individual:Anatomy' AS query, '44725ae' AS version , dataset_license, parents, relationships, xrefs, channel_image",
-    "Get JSON for Individual:Anatomy_by_type": "MATCH (type:Anatomy:Class)<-[:INSTANCEOF|SUBCLASSOF*..]-(primary:Individual:Anatomy) WHERE type.short_form = '$ID' \nWITH primary OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license]-&gt;(l:License) \nWITH COLLECT ({ dataset: { link : coalesce(ds.dataset_link[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), symbol: coalesce(ds.`symbol`[0], '')}  }, license: { icon : coalesce(l.license_logo[0], ''), link : coalesce(l.license_url[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), symbol: coalesce(l.`symbol`[0], '')}  }}) AS dataset_license,primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary)  \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')} ) END AS parents ,primary,dataset_license OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')}  }) END AS relationships ,primary,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(dbx.accession[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,dataset_license,parents,relationships OPTIONAL MATCH (primary)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]-&gt;(template:Individual)-[:depicts]-&gt;(template_anat:Individual) WITH template, channel, template_anat, irw, primary, dataset_license, parents, relationships, xrefs   OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class)  \nWITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }}) END AS channel_image,primary,dataset_license,parents,relationships,xrefs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Individual:Anatomy' AS query, '44725ae' AS version , dataset_license, parents, relationships, xrefs, channel_image",
-    "Get JSON for License": "MATCH (primary:License) WHERE primary.short_form in ['$ID']  \nWITH primary RETURN { icon : coalesce(primary.license_logo[0], ''), link : coalesce(primary.license_url[0], ''), core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for License' AS query, '44725ae' AS version ",
-    "Get JSON for Neuron Class": "MATCH (primary:Class) WHERE primary.short_form in ['$ID']  \nWITH primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary)  \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')} ) END AS parents ,primary OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')}  }) END AS relationships ,primary,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(dbx.accession[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,parents,relationships CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] -&gt;(template:Individual)-[:depicts]-&gt; (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 5', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class)  \nWITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.`symbol`[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,primary,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]-&gt;(p:pub) where rp.typ = 'syn' \nWITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.`symbol`[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } , synonym: { label: coalesce(rp.value[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(rp.has_synonym_type[0],'') }  }) END AS pub_syn,primary,parents,relationships,xrefs,anatomy_channel_image OPTIONAL MATCH (primary)-[rp:has_reference]-&gt;(p:pub) WHERE rp.typ = 'def'  \nWITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.`symbol`[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } ) END AS def_pubs,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn OPTIONAL MATCH (:Class { label: 'intersectional expression pattern'})&lt;-[:SUBCLASSOF]-(ep:Class)&lt;-[ar:part_of]-(anoni:Individual)-[:INSTANCEOF]-&gt;(primary) \nWITH CASE WHEN ep IS NULL THEN [] ELSE COLLECT({ short_form: ep.short_form, label: coalesce(ep.label,''), iri: ep.iri, types: labels(ep), symbol: coalesce(ep.`symbol`[0], '')} ) END AS targeting_splits,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn,def_pubs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Neuron Class' AS query, '44725ae' AS version , parents, relationships, xrefs, anatomy_channel_image, pub_syn, def_pubs, targeting_splits",
-    "Get JSON for Split Class": "MATCH (primary:Class) WHERE primary.short_form in ['$ID']  \nWITH primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary)  \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')} ) END AS parents ,primary OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')}  }) END AS relationships ,primary,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(dbx.accession[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,parents,relationships CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)&lt;- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)&lt;-[:depicts]- (channel:Individual)-[irw:in_register_with] -&gt;(template:Individual)-[:depicts]-&gt; (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 5', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class)  \nWITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), symbol: coalesce(i.`symbol`[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), symbol: coalesce(channel.`symbol`[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), symbol: coalesce(technique.`symbol`[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), symbol: coalesce(template.`symbol`[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), symbol: coalesce(template_anat.`symbol`[0], '')} ,image_folder: COALESCE(irw.folder[0], ''), index: coalesce(apoc.convert.toInteger(irw.index[0]), []) + [] }} }) END AS anatomy_channel_image ,primary,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]-&gt;(p:pub) where rp.typ = 'syn' \nWITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.`symbol`[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } , synonym: { label: coalesce(rp.value[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(rp.has_synonym_type[0],'') }  }) END AS pub_syn,primary,parents,relationships,xrefs,anatomy_channel_image OPTIONAL MATCH (primary)-[rp:has_reference]-&gt;(p:pub) WHERE rp.typ = 'def'  \nWITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), symbol: coalesce(p.`symbol`[0], '')} , PubMed: coalesce(p.PMID[0], ''), FlyBase: coalesce(p.FlyBase[0], ''), DOI: coalesce(p.DOI[0], '') } ) END AS def_pubs,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn OPTIONAL MATCH (:Class { label: 'intersectional expression pattern'})&lt;-[:SUBCLASSOF]-(primary)&lt;-[ar:part_of]-(anoni:Individual)-[:INSTANCEOF]-&gt;(n:Neuron) \nWITH CASE WHEN n IS NULL THEN [] ELSE COLLECT({ short_form: n.short_form, label: coalesce(n.label,''), iri: n.iri, types: labels(n), symbol: coalesce(n.`symbol`[0], '')} ) END AS target_neurons,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn,def_pubs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Split Class' AS query, '44725ae' AS version , parents, relationships, xrefs, anatomy_channel_image, pub_syn, def_pubs, target_neurons",
-    "Get JSON for Template": "MATCH (primary:Template) WHERE primary.short_form in ['$ID']  \nWITH primary MATCH (channel:Individual)&lt;-[irw:in_register_with]-(channel:Individual)-[:depicts]-&gt;(primary) \nWITH { index: coalesce(apoc.convert.toInteger(irw.index), []) + [], extent: irw.extent[0], center: irw.center[0], voxel: irw.voxel[0], orientation: coalesce(irw.orientation[0], ''), image_folder: coalesce(irw.folder[0],''), channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), symbol: coalesce(channel.`symbol`[0], '')}  } as template_channel,primary OPTIONAL MATCH (technique:Class)&lt;-[:is_specified_output_of]-(channel:Individual)-[irw:in_register_with]-&gt;(template:Individual)-[:depicts]-&gt;(primary) WHERE technique.short_form = 'FBbi_00000224' AND exists(irw.index) WITH primary, template_channel, collect ({ channel: channel, irw: irw}) AS painted_domains UNWIND painted_domains AS pd MATCH (channel:Individual { short_form: pd.channel.short_form})-[:depicts]-(ai:Individual)-[:INSTANCEOF]-&gt;(c:Class)  \nWITH collect({ anatomical_type: { short_form: c.short_form, label: coalesce(c.label,''), iri: c.iri, types: labels(c), symbol: coalesce(c.`symbol`[0], '')}  , anatomical_individual: { short_form: ai.short_form, label: coalesce(ai.label,''), iri: ai.iri, types: labels(ai), symbol: coalesce(ai.`symbol`[0], '')} , folder: pd.irw.folder[0], center: coalesce (pd.irw.center, []), index: [] + coalesce (pd.irw.index, []) }) AS template_domains,primary,template_channel OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license]-&gt;(l:License) \nWITH COLLECT ({ dataset: { link : coalesce(ds.dataset_link[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), symbol: coalesce(ds.`symbol`[0], '')}  }, license: { icon : coalesce(l.license_logo[0], ''), link : coalesce(l.license_url[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), symbol: coalesce(l.`symbol`[0], '')}  }}) AS dataset_license,primary,template_channel,template_domains OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary)  \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')} ) END AS parents ,primary,template_channel,template_domains,dataset_license OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')}  }) END AS relationships ,primary,template_channel,template_domains,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] })  WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})  END AS self_xref, primary, template_channel, template_domains, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary)  \nWITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(s.link_base[0], ''), accession: coalesce(dbx.accession[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source, False), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), symbol: coalesce(s.`symbol`[0], '')} , icon: coalesce(s.link_icon_url[0], ''),  link_postfix: coalesce(s.link_postfix, '')})   + self_xref END AS xrefs,primary,template_channel,template_domains,dataset_license,parents,relationships OPTIONAL MATCH (o:Individual)&lt;-[r {type:'Related'}]-(primary) \nWITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), symbol: coalesce(o.`symbol`[0], '')}  }) END AS related_individuals ,primary,template_channel,template_domains,dataset_license,parents,relationships,xrefs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Template' AS query, '44725ae' AS version , template_channel, template_domains, dataset_license, parents, relationships, xrefs, related_individuals",
-    "Get JSON for pub": "MATCH (primary:Individual:pub) WHERE primary.short_form in ['$ID']  \nWITH primary \nOPTIONAL MATCH (primary)-[:has_reference]-(ds:DataSet)-[:has_license]-&gt;(l:License) \nWITH COLLECT ({ dataset: { link : coalesce(ds.dataset_link[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), symbol: coalesce(ds.`symbol`[0], '')}  }, license: { icon : coalesce(l.license_logo[0], ''), link : coalesce(l.license_url[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), symbol: coalesce(l.`symbol`[0], '')}  }}) AS dataset_license,primary \nRETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), symbol: coalesce(primary.`symbol`[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, '44725ae' AS version , dataset_license, {title: coalesce(primary.title[0], '') ,PubMed: coalesce(primary.PMID[0], ''), FlyBase: coalesce(primary.FlyBase[0], ''), DOI: coalesce(primary.DOI[0], '') }AS pub_specific_content"
+    "Get JSON for Class": "MATCH (primary:Class) WHERE primary.short_form in ['$ID'] WITH primary OPTIONAL MATCH (o:Class)<-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary OPTIONAL MATCH (o:Class)<-[r {type:'Related'}]-(primary) where (not exists(r.hide_in_terminfo)) OR (not (r.hide_in_terminfo[0] = true)) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) END AS self_xref, primary, parents, relationships OPTIONAL MATCH (s:Site)<-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) + self_xref END AS xrefs,primary,parents,relationships CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)<- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)<-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,primary,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) where rp.typ = 'syn' WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } , synonym: { label: coalesce(([]+rp.value)[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(([]+rp.has_synonym_type)[0],'') } }) END AS pub_syn,primary,parents,relationships,xrefs,anatomy_channel_image OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WHERE rp.typ = 'def' WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS def_pubs,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Class' AS query, '8851919' AS version , parents, relationships, xrefs, anatomy_channel_image, pub_syn, def_pubs",
+    "Get JSON for DataSet": "MATCH (primary:DataSet) WHERE primary.short_form in ['$ID'] WITH primary CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)<- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)<-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,primary OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) END AS self_xref, primary, anatomy_channel_image OPTIONAL MATCH (s:Site)<-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) + self_xref END AS xrefs,primary,anatomy_channel_image OPTIONAL MATCH (primary)-[:has_license|license]->(l:License) WITH collect ({ icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }) as license,primary,anatomy_channel_image,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS pubs,primary,anatomy_channel_image,xrefs,license OPTIONAL MATCH (primary)<-[:has_source]-(i:Individual) WITH i, primary, anatomy_channel_image, xrefs, license, pubs OPTIONAL MATCH (i)-[:INSTANCEOF]-(c:Class) WITH DISTINCT { images: count(distinct i),types: count(distinct c) } as dataset_counts,primary,anatomy_channel_image,xrefs,license,pubs RETURN { link : coalesce(([]+primary.dataset_link)[0], ''), core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for DataSet' AS query, '8851919' AS version , anatomy_channel_image, xrefs, license, pubs, dataset_counts",
+    "Get JSON for Individual": "MATCH (primary:Individual) WHERE primary.short_form in ['$ID'] WITH primary OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license|license]->(l:License) WITH COLLECT ({ dataset: { link : coalesce(([]+ds.dataset_link)[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(([]+ds.symbol)[0], '')} }, license: { icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }}) AS dataset_license,primary OPTIONAL MATCH (o:Class)<-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary,dataset_license OPTIONAL MATCH (o:Class)<-[r {type:'Related'}]-(primary) where (not exists(r.hide_in_terminfo)) OR (not (r.hide_in_terminfo[0] = true)) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) END AS self_xref, primary, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)<-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) + self_xref END AS xrefs,primary,dataset_license,parents,relationships OPTIONAL MATCH (primary)<-[:depicts]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(template_anat:Individual) WITH template, channel, template_anat, irw, primary, dataset_license, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }}) END AS channel_image,primary,dataset_license,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) where rp.typ = 'syn' WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } , synonym: { label: coalesce(([]+rp.value)[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(([]+rp.has_synonym_type)[0],'') } }) END AS pub_syn,primary,dataset_license,parents,relationships,xrefs,channel_image OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WHERE rp.typ = 'def' WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS def_pubs,primary,dataset_license,parents,relationships,xrefs,channel_image,pub_syn RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Individual' AS query, '8851919' AS version , dataset_license, parents, relationships, xrefs, channel_image, pub_syn, def_pubs",
+    "Get JSON for Individual:Anatomy_by_type": "MATCH (type:Anatomy:Class)<-[:INSTANCEOF|SUBCLASSOF*..]-(primary:Individual:Anatomy) WHERE type.short_form = '$ID' WITH primary OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license|license]-&gt;(l:License) WITH COLLECT ({ dataset: { link : coalesce(([]+ds.dataset_link)[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(([]+ds.symbol)[0], '')} }, license: { icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }}) AS dataset_license,primary OPTIONAL MATCH (o:Class)&lt;-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary,dataset_license OPTIONAL MATCH (o:Class)&lt;-[r {type:'Related'}]-(primary) where (not exists(r.hide_in_terminfo)) OR (not (r.hide_in_terminfo[0] = true)) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) END AS self_xref, primary, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)&lt;-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) + self_xref END AS xrefs,primary,dataset_license,parents,relationships OPTIONAL MATCH (primary)&lt;-[:depicts]-(channel:Individual)-[irw:in_register_with]-&gt;(template:Individual)-[:depicts]-&gt;(template_anat:Individual) WITH template, channel, template_anat, irw, primary, dataset_license, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]-&gt;(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE collect ({ channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }}) END AS channel_image,primary,dataset_license,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]-&gt;(p:pub) where rp.typ = 'syn' WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } , synonym: { label: coalesce(([]+rp.value)[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(([]+rp.has_synonym_type)[0],'') } }) END AS pub_syn,primary,dataset_license,parents,relationships,xrefs,channel_image OPTIONAL MATCH (primary)-[rp:has_reference]-&gt;(p:pub) WHERE rp.typ = 'def' WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS def_pubs,primary,dataset_license,parents,relationships,xrefs,channel_image,pub_syn RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Individual:Anatomy_by_type' AS query, '2f31356' AS version , dataset_license, parents, relationships, xrefs, channel_image, pub_syn, def_pubs",
+    "Get JSON for License": "MATCH (primary:License) WHERE primary.short_form in ['$ID'] WITH primary RETURN { icon : coalesce(([]+primary.license_logo)[0], ''), link : coalesce(([]+primary.license_url)[0], ''), core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for License' AS query, '8851919' AS version ",
+    "Get JSON for Neuron Class": "MATCH (primary:Class) WHERE primary.short_form in ['$ID'] WITH primary OPTIONAL MATCH (o:Class)<-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary OPTIONAL MATCH (o:Class)<-[r {type:'Related'}]-(primary) where (not exists(r.hide_in_terminfo)) OR (not (r.hide_in_terminfo[0] = true)) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) END AS self_xref, primary, parents, relationships OPTIONAL MATCH (s:Site)<-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) + self_xref END AS xrefs,primary,parents,relationships CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)<- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)<-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,primary,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) where rp.typ = 'syn' WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } , synonym: { label: coalesce(([]+rp.value)[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(([]+rp.has_synonym_type)[0],'') } }) END AS pub_syn,primary,parents,relationships,xrefs,anatomy_channel_image OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WHERE rp.typ = 'def' WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS def_pubs,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn OPTIONAL MATCH (:Class { label: 'intersectional expression pattern'})<-[:SUBCLASSOF]-(ep:Class)<-[ar:part_of]-(anoni:Individual)-[:INSTANCEOF]->(primary) WITH CASE WHEN ep IS NULL THEN [] ELSE COLLECT({ short_form: ep.short_form, label: coalesce(ep.label,''), iri: ep.iri, types: labels(ep), unique_facets: apoc.coll.sort(coalesce(ep.uniqueFacets, [])), symbol: coalesce(([]+ep.symbol)[0], '')} ) END AS targeting_splits,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn,def_pubs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Neuron Class' AS query, '8851919' AS version , parents, relationships, xrefs, anatomy_channel_image, pub_syn, def_pubs, targeting_splits",
+    "Get JSON for Split Class": "MATCH (primary:Class) WHERE primary.short_form in ['$ID'] WITH primary OPTIONAL MATCH (o:Class)<-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary OPTIONAL MATCH (o:Class)<-[r {type:'Related'}]-(primary) where (not exists(r.hide_in_terminfo)) OR (not (r.hide_in_terminfo[0] = true)) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) END AS self_xref, primary, parents, relationships OPTIONAL MATCH (s:Site)<-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) + self_xref END AS xrefs,primary,parents,relationships CALL apoc.cypher.run('WITH primary OPTIONAL MATCH (primary)<- [:has_source|SUBCLASSOF|INSTANCEOF*]-(i:Individual)<-[:depicts]- (channel:Individual)-[irw:in_register_with] ->(template:Individual)-[:depicts]-> (template_anat:Individual) RETURN template, channel, template_anat, i, irw limit 10', {primary:primary}) yield value with value.template as template, value.channel as channel,value.template_anat as template_anat, value.i as i, value.irw as irw, primary, parents, relationships, xrefs OPTIONAL MATCH (channel)-[:is_specified_output_of]->(technique:Class) WITH CASE WHEN channel IS NULL THEN [] ELSE COLLECT({ anatomy: { short_form: i.short_form, label: coalesce(i.label,''), iri: i.iri, types: labels(i), unique_facets: apoc.coll.sort(coalesce(i.uniqueFacets, [])), symbol: coalesce(([]+i.symbol)[0], '')} , channel_image: { channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} , imaging_technique: { short_form: technique.short_form, label: coalesce(technique.label,''), iri: technique.iri, types: labels(technique), unique_facets: apoc.coll.sort(coalesce(technique.uniqueFacets, [])), symbol: coalesce(([]+technique.symbol)[0], '')} ,image: { template_channel : { short_form: template.short_form, label: coalesce(template.label,''), iri: template.iri, types: labels(template), unique_facets: apoc.coll.sort(coalesce(template.uniqueFacets, [])), symbol: coalesce(([]+template.symbol)[0], '')} , template_anatomy: { short_form: template_anat.short_form, label: coalesce(template_anat.label,''), iri: template_anat.iri, types: labels(template_anat), unique_facets: apoc.coll.sort(coalesce(template_anat.uniqueFacets, [])), symbol: coalesce(([]+template_anat.symbol)[0], '')} ,image_folder: COALESCE(([]+irw.folder)[0], ''), index: coalesce(apoc.convert.toInteger(([]+irw.index)[0]), []) + [] }} }) END AS anatomy_channel_image ,primary,parents,relationships,xrefs OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) where rp.typ = 'syn' WITH CASE WHEN p is null THEN [] ELSE collect({ pub: { core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } , synonym: { label: coalesce(([]+rp.value)[0], ''), scope: coalesce(rp.scope, ''), type: coalesce(([]+rp.has_synonym_type)[0],'') } }) END AS pub_syn,primary,parents,relationships,xrefs,anatomy_channel_image OPTIONAL MATCH (primary)-[rp:has_reference]->(p:pub) WHERE rp.typ = 'def' WITH CASE WHEN p is null THEN [] ELSE collect({ core: { short_form: p.short_form, label: coalesce(p.label,''), iri: p.iri, types: labels(p), unique_facets: apoc.coll.sort(coalesce(p.uniqueFacets, [])), symbol: coalesce(([]+p.symbol)[0], '')} , PubMed: coalesce(([]+p.PMID)[0], ''), FlyBase: coalesce(([]+p.FlyBase)[0], ''), DOI: coalesce(([]+p.DOI)[0], '') } ) END AS def_pubs,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn OPTIONAL MATCH (:Class { label: 'intersectional expression pattern'})<-[:SUBCLASSOF]-(primary)<-[ar:part_of]-(anoni:Individual)-[:INSTANCEOF]->(n:Neuron) WITH CASE WHEN n IS NULL THEN [] ELSE COLLECT({ short_form: n.short_form, label: coalesce(n.label,''), iri: n.iri, types: labels(n), unique_facets: apoc.coll.sort(coalesce(n.uniqueFacets, [])), symbol: coalesce(([]+n.symbol)[0], '')} ) END AS target_neurons,primary,parents,relationships,xrefs,anatomy_channel_image,pub_syn,def_pubs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Split Class' AS query, '8851919' AS version , parents, relationships, xrefs, anatomy_channel_image, pub_syn, def_pubs, target_neurons",
+    "Get JSON for Template": "MATCH (primary:Template) WHERE primary.short_form in ['$ID'] WITH primary MATCH (channel:Individual)<-[irw:in_register_with]-(channel:Individual)-[:depicts]->(primary) WITH { index: coalesce(apoc.convert.toInteger(irw.index), []) + [], extent: ([]+irw.extent)[0], center: ([]+irw.center)[0], voxel: ([]+irw.voxel)[0], orientation: coalesce(([]+irw.orientation)[0], ''), image_folder: coalesce(([]+irw.folder)[0],''), channel: { short_form: channel.short_form, label: coalesce(channel.label,''), iri: channel.iri, types: labels(channel), unique_facets: apoc.coll.sort(coalesce(channel.uniqueFacets, [])), symbol: coalesce(([]+channel.symbol)[0], '')} } as template_channel,primary OPTIONAL MATCH (technique:Class)<-[:is_specified_output_of]-(channel:Individual)-[irw:in_register_with]->(template:Individual)-[:depicts]->(primary) WHERE technique.short_form IN ['FBbi_00000224','FBbi_00000251'] AND exists(irw.index) WITH primary, template_channel, collect ({ channel: channel, irw: irw}) AS painted_domains UNWIND painted_domains AS pd OPTIONAL MATCH (channel:Individual { short_form: pd.channel.short_form})-[:depicts]-(ai:Individual)-[:INSTANCEOF]->(c:Class) WITH collect({ anatomical_type: { short_form: c.short_form, label: coalesce(c.label,''), iri: c.iri, types: labels(c), unique_facets: apoc.coll.sort(coalesce(c.uniqueFacets, [])), symbol: coalesce(([]+c.symbol)[0], '')} , anatomical_individual: { short_form: ai.short_form, label: coalesce(ai.label,''), iri: ai.iri, types: labels(ai), unique_facets: apoc.coll.sort(coalesce(ai.uniqueFacets, [])), symbol: coalesce(([]+ai.symbol)[0], '')} , folder: ([]+pd.irw.folder)[0], center: coalesce (pd.irw.center, []), index: [] + coalesce (pd.irw.index, []) }) AS template_domains,primary,template_channel OPTIONAL MATCH (primary)-[:has_source]-(ds:DataSet)-[:has_license|license]->(l:License) WITH COLLECT ({ dataset: { link : coalesce(([]+ds.dataset_link)[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(([]+ds.symbol)[0], '')} }, license: { icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }}) AS dataset_license,primary,template_channel,template_domains OPTIONAL MATCH (o:Class)<-[r:SUBCLASSOF|INSTANCEOF]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} ) END AS parents ,primary,template_channel,template_domains,dataset_license OPTIONAL MATCH (o:Class)<-[r {type:'Related'}]-(primary) where (not exists(r.hide_in_terminfo)) OR (not (r.hide_in_terminfo[0] = true)) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS relationships ,primary,template_channel,template_domains,dataset_license,parents OPTIONAL MATCH (s:Site { short_form: apoc.convert.toList(primary.self_xref)[0] }) WITH CASE WHEN s IS NULL THEN [] ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(primary.short_form, ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) END AS self_xref, primary, template_channel, template_domains, dataset_license, parents, relationships OPTIONAL MATCH (s:Site)<-[dbx:database_cross_reference]-(primary) WITH CASE WHEN s IS NULL THEN self_xref ELSE COLLECT({ link_base: coalesce(([]+s.link_base)[0], ''), accession: coalesce(([]+dbx.accession)[0], ''), link_text: primary.label + ' on ' + s.label, homepage: coalesce(s.homepage[0], ''), is_data_source: coalesce(s.is_data_source[0], false), site: { short_form: s.short_form, label: coalesce(s.label,''), iri: s.iri, types: labels(s), unique_facets: apoc.coll.sort(coalesce(s.uniqueFacets, [])), symbol: coalesce(([]+s.symbol)[0], '')} , icon: coalesce(s.link_icon_url[0], ''), link_postfix: coalesce(s.link_postfix, '')}) + self_xref END AS xrefs,primary,template_channel,template_domains,dataset_license,parents,relationships OPTIONAL MATCH (o:Individual)<-[r {type:'Related'}]-(primary) WITH CASE WHEN o IS NULL THEN [] ELSE COLLECT ({ relation: { label: r.label, iri: r.iri, type: type(r) } , object: { short_form: o.short_form, label: coalesce(o.label,''), iri: o.iri, types: labels(o), unique_facets: apoc.coll.sort(coalesce(o.uniqueFacets, [])), symbol: coalesce(([]+o.symbol)[0], '')} }) END AS related_individuals ,primary,template_channel,template_domains,dataset_license,parents,relationships,xrefs RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for Template' AS query, '8851919' AS version , template_channel, template_domains, dataset_license, parents, relationships, xrefs, related_individuals",
+    "Get JSON for pub": "MATCH (primary:Individual:pub) WHERE primary.short_form in ['$ID'] WITH primary OPTIONAL MATCH (primary)-[:has_reference]-(ds:DataSet)-[:has_license|license]->(l:License) WITH COLLECT ({ dataset: { link : coalesce(([]+ds.dataset_link)[0], ''), core : { short_form: ds.short_form, label: coalesce(ds.label,''), iri: ds.iri, types: labels(ds), unique_facets: apoc.coll.sort(coalesce(ds.uniqueFacets, [])), symbol: coalesce(([]+ds.symbol)[0], '')} }, license: { icon : coalesce(([]+l.license_logo)[0], ''), link : coalesce(([]+l.license_url)[0], ''), core : { short_form: l.short_form, label: coalesce(l.label,''), iri: l.iri, types: labels(l), unique_facets: apoc.coll.sort(coalesce(l.uniqueFacets, [])), symbol: coalesce(([]+l.symbol)[0], '')} }}) AS dataset_license,primary RETURN { core : { short_form: primary.short_form, label: coalesce(primary.label,''), iri: primary.iri, types: labels(primary), unique_facets: apoc.coll.sort(coalesce(primary.uniqueFacets, [])), symbol: coalesce(([]+primary.symbol)[0], '')} , description : coalesce(primary.description, []), comment : coalesce(primary.comment, []) } AS term, 'Get JSON for pub' AS query, '8851919' AS version , dataset_license, {title: coalesce(([]+primary.title)[0], '') ,PubMed: coalesce(([]+primary.PMID)[0], ''), FlyBase: coalesce(([]+primary.FlyBase)[0], ''), DOI: coalesce(([]+primary.DOI)[0], '') }AS pub_specific_content"
 }
```

### Comparing `vfb_connect-1.2.8/src/vfb_connect.egg-info/PKG-INFO` & `vfb_connect-1.2.9/src/vfb_connect.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: vfb-connect
-Version: 1.2.8
+Version: 1.2.9
 Summary: Wrapper for querying VirtualFlyBrain servers.
 Home-page: https://github.com/VirtualFlyBrain/VFB_connect
 Author: David Osumi-Sutherland
 Author-email: dosumis@gmail.com
 Project-URL: Bug Reports, https://github.com/VirtualFlyBrain/VFB_connect/issues
 Project-URL: Source, https://github.com/VirtualFlyBrain/VFB_connect
 Project-URL: Documentation, https://vfb-connect.readthedocs.io/en/stable/
```

### Comparing `vfb_connect-1.2.8/src/vfb_connect.egg-info/SOURCES.txt` & `vfb_connect-1.2.9/src/vfb_connect.egg-info/SOURCES.txt`

 * *Files identical despite different names*

