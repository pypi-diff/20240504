# Comparing `tmp/pyntcore-2024.3.2.0-cp39-cp39-win_amd64.whl.zip` & `tmp/pyntcore-2024.3.2.1-cp312-cp312-macosx_12_0_universal2.whl.zip`

## zipinfo {}

```diff
@@ -1,142 +1,141 @@
-Zip file size: 1734259 bytes, number of entries: 140
--rw-rw-rw-  2.0 fat     4483 b- defN 24-Mar-14 06:00 ntcore/__init__.py
--rw-rw-rw-  2.0 fat      650 b- defN 24-Mar-14 06:44 ntcore/_init_ntcore.py
--rw-rw-rw-  2.0 fat     3642 b- defN 24-Mar-14 06:00 ntcore/_logutil.py
--rw-rw-rw-  2.0 fat  2503168 b- defN 24-Mar-14 06:49 ntcore/_ntcore.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat      561 b- defN 24-Mar-14 06:44 ntcore/pkgcfg.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Mar-14 06:49 ntcore/py.typed
--rw-rw-rw-  2.0 fat      196 b- defN 24-Mar-14 06:00 ntcore/types.py
--rw-rw-rw-  2.0 fat     7225 b- defN 24-Mar-14 06:00 ntcore/util.py
--rw-rw-rw-  2.0 fat      175 b- defN 24-Mar-14 06:44 ntcore/version.py
--rw-rw-rw-  2.0 fat     2784 b- defN 24-Mar-14 06:49 ntcore/__pycache__/__init__.cpython-39.pyc
--rw-rw-rw-  2.0 fat      749 b- defN 24-Mar-14 06:49 ntcore/__pycache__/_init_ntcore.cpython-39.pyc
--rw-rw-rw-  2.0 fat      287 b- defN 24-Mar-14 06:49 ntcore/__pycache__/version.cpython-39.pyc
--rw-rw-rw-  2.0 fat   274119 b- defN 24-Mar-14 06:49 ntcore/_ntcore/__init__.pyi
--rw-rw-rw-  2.0 fat     2987 b- defN 24-Mar-14 06:49 ntcore/_ntcore/meta.pyi
--rw-rw-rw-  2.0 fat      331 b- defN 24-Mar-14 06:44 ntcore/include/ntcore.h
--rw-rw-rw-  2.0 fat    62006 b- defN 24-Mar-14 06:44 ntcore/include/ntcore_c.h
--rw-rw-rw-  2.0 fat    33883 b- defN 24-Mar-14 06:44 ntcore/include/ntcore_c_types.h
--rw-rw-rw-  2.0 fat    44061 b- defN 24-Mar-14 06:44 ntcore/include/ntcore_cpp.h
--rw-rw-rw-  2.0 fat    30054 b- defN 24-Mar-14 06:44 ntcore/include/ntcore_cpp_types.h
--rw-rw-rw-  2.0 fat     2715 b- defN 24-Mar-14 06:44 ntcore/include/ntcore_test.h
--rw-rw-rw-  2.0 fat    13119 b- defN 24-Mar-14 06:44 ntcore/include/networktables/BooleanArrayTopic.h
--rw-rw-rw-  2.0 fat     4706 b- defN 24-Mar-14 06:44 ntcore/include/networktables/BooleanArrayTopic.inc
--rw-rw-rw-  2.0 fat    11127 b- defN 24-Mar-14 06:44 ntcore/include/networktables/BooleanTopic.h
--rw-rw-rw-  2.0 fat     3506 b- defN 24-Mar-14 06:44 ntcore/include/networktables/BooleanTopic.inc
--rw-rw-rw-  2.0 fat    13122 b- defN 24-Mar-14 06:44 ntcore/include/networktables/DoubleArrayTopic.h
--rw-rw-rw-  2.0 fat     4697 b- defN 24-Mar-14 06:44 ntcore/include/networktables/DoubleArrayTopic.inc
--rw-rw-rw-  2.0 fat    11105 b- defN 24-Mar-14 06:44 ntcore/include/networktables/DoubleTopic.h
--rw-rw-rw-  2.0 fat     3469 b- defN 24-Mar-14 06:44 ntcore/include/networktables/DoubleTopic.inc
--rw-rw-rw-  2.0 fat    13069 b- defN 24-Mar-14 06:44 ntcore/include/networktables/FloatArrayTopic.h
--rw-rw-rw-  2.0 fat     4608 b- defN 24-Mar-14 06:44 ntcore/include/networktables/FloatArrayTopic.inc
--rw-rw-rw-  2.0 fat    11059 b- defN 24-Mar-14 06:44 ntcore/include/networktables/FloatTopic.h
--rw-rw-rw-  2.0 fat     3396 b- defN 24-Mar-14 06:44 ntcore/include/networktables/FloatTopic.inc
--rw-rw-rw-  2.0 fat    14044 b- defN 24-Mar-14 06:44 ntcore/include/networktables/GenericEntry.h
--rw-rw-rw-  2.0 fat     6856 b- defN 24-Mar-14 06:44 ntcore/include/networktables/GenericEntry.inc
--rw-rw-rw-  2.0 fat    13171 b- defN 24-Mar-14 06:44 ntcore/include/networktables/IntegerArrayTopic.h
--rw-rw-rw-  2.0 fat     4774 b- defN 24-Mar-14 06:44 ntcore/include/networktables/IntegerArrayTopic.inc
--rw-rw-rw-  2.0 fat    11147 b- defN 24-Mar-14 06:44 ntcore/include/networktables/IntegerTopic.h
--rw-rw-rw-  2.0 fat     3530 b- defN 24-Mar-14 06:44 ntcore/include/networktables/IntegerTopic.inc
--rw-rw-rw-  2.0 fat     1598 b- defN 24-Mar-14 06:44 ntcore/include/networktables/MultiSubscriber.h
--rw-rw-rw-  2.0 fat      967 b- defN 24-Mar-14 06:44 ntcore/include/networktables/MultiSubscriber.inc
--rw-rw-rw-  2.0 fat      638 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NTSendable.h
--rw-rw-rw-  2.0 fat     1497 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NTSendableBuilder.h
--rw-rw-rw-  2.0 fat    20549 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NetworkTable.h
--rw-rw-rw-  2.0 fat    15142 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NetworkTableEntry.h
--rw-rw-rw-  2.0 fat     7534 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NetworkTableEntry.inc
--rw-rw-rw-  2.0 fat    26081 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NetworkTableInstance.h
--rw-rw-rw-  2.0 fat     9235 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NetworkTableInstance.inc
--rw-rw-rw-  2.0 fat    10444 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NetworkTableListener.h
--rw-rw-rw-  2.0 fat     6138 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NetworkTableListener.inc
--rw-rw-rw-  2.0 fat     1128 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NetworkTableType.h
--rw-rw-rw-  2.0 fat    17866 b- defN 24-Mar-14 06:44 ntcore/include/networktables/NetworkTableValue.h
--rw-rw-rw-  2.0 fat    14393 b- defN 24-Mar-14 06:44 ntcore/include/networktables/ProtobufTopic.h
--rw-rw-rw-  2.0 fat    10931 b- defN 24-Mar-14 06:44 ntcore/include/networktables/RawTopic.h
--rw-rw-rw-  2.0 fat     3758 b- defN 24-Mar-14 06:44 ntcore/include/networktables/RawTopic.inc
--rw-rw-rw-  2.0 fat    11470 b- defN 24-Mar-14 06:44 ntcore/include/networktables/StringArrayTopic.h
--rw-rw-rw-  2.0 fat     4055 b- defN 24-Mar-14 06:44 ntcore/include/networktables/StringArrayTopic.inc
--rw-rw-rw-  2.0 fat    12902 b- defN 24-Mar-14 06:44 ntcore/include/networktables/StringTopic.h
--rw-rw-rw-  2.0 fat     4217 b- defN 24-Mar-14 06:44 ntcore/include/networktables/StringTopic.inc
--rw-rw-rw-  2.0 fat    22701 b- defN 24-Mar-14 06:44 ntcore/include/networktables/StructArrayTopic.h
--rw-rw-rw-  2.0 fat    16217 b- defN 24-Mar-14 06:44 ntcore/include/networktables/StructTopic.h
--rw-rw-rw-  2.0 fat    11263 b- defN 24-Mar-14 06:44 ntcore/include/networktables/Topic.h
--rw-rw-rw-  2.0 fat     2769 b- defN 24-Mar-14 06:44 ntcore/include/networktables/Topic.inc
--rw-rw-rw-  2.0 fat    12126 b- defN 24-Mar-14 06:44 ntcore/include/networktables/UnitTopic.h
--rw-rw-rw-  2.0 fat     4541 b- defN 24-Mar-14 06:44 ntcore/include/networktables/UnitTopic.inc
--rw-rw-rw-  2.0 fat  1582592 b- defN 24-Mar-14 06:44 ntcore/lib/ntcore.dll
--rw-rw-rw-  2.0 fat  3246352 b- defN 24-Mar-14 06:44 ntcore/lib/ntcore.lib
--rw-rw-rw-  2.0 fat      678 b- defN 24-Mar-14 06:00 ntcore/meta/__init__.py
--rw-rw-rw-  2.0 fat     1095 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/StructArrayTopic_tmpl1.cpp
--rw-rw-rw-  2.0 fat     1090 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/StructArrayTopic_tmpl2.cpp
--rw-rw-rw-  2.0 fat     1070 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/StructArrayTopic_tmpl3.cpp
--rw-rw-rw-  2.0 fat     1070 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/StructArrayTopic_tmpl4.cpp
--rw-rw-rw-  2.0 fat     1003 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/StructTopic_tmpl1.cpp
--rw-rw-rw-  2.0 fat      998 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/StructTopic_tmpl2.cpp
--rw-rw-rw-  2.0 fat      978 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/StructTopic_tmpl3.cpp
--rw-rw-rw-  2.0 fat      978 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/StructTopic_tmpl4.cpp
--rw-rw-rw-  2.0 fat     1721 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__BooleanArrayPublisher.hpp
--rw-rw-rw-  2.0 fat     1857 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__BooleanArraySubscriber.hpp
--rw-rw-rw-  2.0 fat     1469 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__BooleanPublisher.hpp
--rw-rw-rw-  2.0 fat     1483 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__BooleanSubscriber.hpp
--rw-rw-rw-  2.0 fat     1707 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__DoubleArrayPublisher.hpp
--rw-rw-rw-  2.0 fat     1842 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__DoubleArraySubscriber.hpp
--rw-rw-rw-  2.0 fat     1457 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__DoublePublisher.hpp
--rw-rw-rw-  2.0 fat     1471 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__DoubleSubscriber.hpp
--rw-rw-rw-  2.0 fat     1693 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__FloatArrayPublisher.hpp
--rw-rw-rw-  2.0 fat     1827 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__FloatArraySubscriber.hpp
--rw-rw-rw-  2.0 fat     1445 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__FloatPublisher.hpp
--rw-rw-rw-  2.0 fat     1459 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__FloatSubscriber.hpp
--rw-rw-rw-  2.0 fat     1504 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__GenericPublisher.hpp
--rw-rw-rw-  2.0 fat     1518 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__GenericSubscriber.hpp
--rw-rw-rw-  2.0 fat     1721 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__IntegerArrayPublisher.hpp
--rw-rw-rw-  2.0 fat     1857 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__IntegerArraySubscriber.hpp
--rw-rw-rw-  2.0 fat     1469 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__IntegerPublisher.hpp
--rw-rw-rw-  2.0 fat     1483 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__IntegerSubscriber.hpp
--rw-rw-rw-  2.0 fat     2567 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__NTSendable.hpp
--rw-rw-rw-  2.0 fat     3140 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__NTSendableBuilder.hpp
--rw-rw-rw-  2.0 fat      820 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__Publisher.hpp
--rw-rw-rw-  2.0 fat     1630 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__RawPublisher.hpp
--rw-rw-rw-  2.0 fat     1757 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__RawSubscriber.hpp
--rw-rw-rw-  2.0 fat     1517 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StringArrayPublisher.hpp
--rw-rw-rw-  2.0 fat     1531 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StringArraySubscriber.hpp
--rw-rw-rw-  2.0 fat     1637 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StringPublisher.hpp
--rw-rw-rw-  2.0 fat     1767 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StringSubscriber.hpp
--rw-rw-rw-  2.0 fat     2771 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StructArrayEntry.hpp
--rw-rw-rw-  2.0 fat     4974 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StructArrayPublisher.hpp
--rw-rw-rw-  2.0 fat     6647 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StructArraySubscriber.hpp
--rw-rw-rw-  2.0 fat     6081 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StructArrayTopic.hpp
--rw-rw-rw-  2.0 fat     2593 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StructEntry.hpp
--rw-rw-rw-  2.0 fat     4544 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StructPublisher.hpp
--rw-rw-rw-  2.0 fat     6339 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StructSubscriber.hpp
--rw-rw-rw-  2.0 fat     5684 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__StructTopic.hpp
--rw-rw-rw-  2.0 fat      824 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__Subscriber.hpp
--rw-rw-rw-  2.0 fat     2008 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/nt__Timestamped.hpp
--rw-rw-rw-  2.0 fat      730 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl1.cpp
--rw-rw-rw-  2.0 fat      745 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl10.cpp
--rw-rw-rw-  2.0 fat      753 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl11.cpp
--rw-rw-rw-  2.0 fat      738 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl12.cpp
--rw-rw-rw-  2.0 fat      751 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl13.cpp
--rw-rw-rw-  2.0 fat      733 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl2.cpp
--rw-rw-rw-  2.0 fat      731 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl3.cpp
--rw-rw-rw-  2.0 fat      732 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl4.cpp
--rw-rw-rw-  2.0 fat      737 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl5.cpp
--rw-rw-rw-  2.0 fat      746 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl6.cpp
--rw-rw-rw-  2.0 fat      742 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl7.cpp
--rw-rw-rw-  2.0 fat      746 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl8.cpp
--rw-rw-rw-  2.0 fat      744 b- defN 24-Mar-14 06:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl9.cpp
--rw-rw-rw-  2.0 fat     3132 b- defN 24-Mar-14 06:00 ntcore/src/NetworkTable.cpp.inl
--rw-rw-rw-  2.0 fat     2341 b- defN 24-Mar-14 06:00 ntcore/src/NetworkTableEntry.cpp.inl
--rw-rw-rw-  2.0 fat     1627 b- defN 24-Mar-14 06:00 ntcore/src/nt_instance.cpp
--rw-rw-rw-  2.0 fat      416 b- defN 24-Mar-14 06:00 ntcore/src/nt_instance.h
--rw-rw-rw-  2.0 fat     1043 b- defN 24-Mar-14 06:00 ntcore/src/nt_type_caster.h
--rw-rw-rw-  2.0 fat      267 b- defN 24-Mar-14 06:00 ntcore/src/ntcore.cpp
--rw-rw-rw-  2.0 fat     5160 b- defN 24-Mar-14 06:00 ntcore/src/py2value.cpp
--rw-rw-rw-  2.0 fat      621 b- defN 24-Mar-14 06:00 ntcore/src/py2value.h
--rw-rw-rw-  2.0 fat     4596 b- defN 24-Mar-14 06:00 ntcore/src/pyentry.cpp
--rw-rw-rw-  2.0 fat     1245 b- defN 24-Mar-14 06:00 ntcore/src/pyentry.h
--rw-rw-rw-  2.0 fat      514 b- defN 24-Mar-14 06:49 pyntcore-2024.3.2.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 24-Mar-14 06:49 pyntcore-2024.3.2.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       39 b- defN 24-Mar-14 06:44 pyntcore-2024.3.2.0.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        7 b- defN 24-Mar-14 06:44 pyntcore-2024.3.2.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat    13887 b- defN 24-Mar-14 06:49 pyntcore-2024.3.2.0.dist-info/RECORD
-140 files, 8345082 bytes uncompressed, 1711667 bytes compressed:  79.5%
+Zip file size: 3710250 bytes, number of entries: 139
+-rw-r--r--  2.0 unx     4288 b- defN 24-May-04 16:34 ntcore/__init__.py
+-rw-r--r--  2.0 unx      648 b- defN 24-May-04 16:44 ntcore/_init_ntcore.py
+-rw-r--r--  2.0 unx     3519 b- defN 24-May-04 16:34 ntcore/_logutil.py
+-rwxr-xr-x  2.0 unx 12191088 b- defN 24-May-04 16:48 ntcore/_ntcore.cpython-312-darwin.so
+-rw-r--r--  2.0 unx      543 b- defN 24-May-04 16:44 ntcore/pkgcfg.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-04 16:48 ntcore/py.typed
+-rw-r--r--  2.0 unx      183 b- defN 24-May-04 16:34 ntcore/types.py
+-rw-r--r--  2.0 unx     7001 b- defN 24-May-04 16:34 ntcore/util.py
+-rw-r--r--  2.0 unx      171 b- defN 24-May-04 16:44 ntcore/version.py
+-rw-r--r--  2.0 unx     3024 b- defN 24-May-04 16:48 ntcore/__pycache__/__init__.cpython-312.pyc
+-rw-r--r--  2.0 unx      952 b- defN 24-May-04 16:48 ntcore/__pycache__/_init_ntcore.cpython-312.pyc
+-rw-r--r--  2.0 unx      349 b- defN 24-May-04 16:48 ntcore/__pycache__/version.cpython-312.pyc
+-rw-r--r--  2.0 unx   267107 b- defN 24-May-04 16:48 ntcore/_ntcore/__init__.pyi
+-rw-r--r--  2.0 unx     2889 b- defN 24-May-04 16:48 ntcore/_ntcore/meta.pyi
+-rw-r--r--  2.0 unx      331 b- defN 24-May-04 16:44 ntcore/include/ntcore.h
+-rw-r--r--  2.0 unx    62006 b- defN 24-May-04 16:44 ntcore/include/ntcore_c.h
+-rw-r--r--  2.0 unx    33883 b- defN 24-May-04 16:44 ntcore/include/ntcore_c_types.h
+-rw-r--r--  2.0 unx    44061 b- defN 24-May-04 16:44 ntcore/include/ntcore_cpp.h
+-rw-r--r--  2.0 unx    30054 b- defN 24-May-04 16:44 ntcore/include/ntcore_cpp_types.h
+-rw-r--r--  2.0 unx     2715 b- defN 24-May-04 16:44 ntcore/include/ntcore_test.h
+-rw-r--r--  2.0 unx    13119 b- defN 24-May-04 16:44 ntcore/include/networktables/BooleanArrayTopic.h
+-rw-r--r--  2.0 unx     4706 b- defN 24-May-04 16:44 ntcore/include/networktables/BooleanArrayTopic.inc
+-rw-r--r--  2.0 unx    11127 b- defN 24-May-04 16:44 ntcore/include/networktables/BooleanTopic.h
+-rw-r--r--  2.0 unx     3506 b- defN 24-May-04 16:44 ntcore/include/networktables/BooleanTopic.inc
+-rw-r--r--  2.0 unx    13122 b- defN 24-May-04 16:44 ntcore/include/networktables/DoubleArrayTopic.h
+-rw-r--r--  2.0 unx     4697 b- defN 24-May-04 16:44 ntcore/include/networktables/DoubleArrayTopic.inc
+-rw-r--r--  2.0 unx    11105 b- defN 24-May-04 16:44 ntcore/include/networktables/DoubleTopic.h
+-rw-r--r--  2.0 unx     3469 b- defN 24-May-04 16:44 ntcore/include/networktables/DoubleTopic.inc
+-rw-r--r--  2.0 unx    13069 b- defN 24-May-04 16:44 ntcore/include/networktables/FloatArrayTopic.h
+-rw-r--r--  2.0 unx     4608 b- defN 24-May-04 16:44 ntcore/include/networktables/FloatArrayTopic.inc
+-rw-r--r--  2.0 unx    11059 b- defN 24-May-04 16:44 ntcore/include/networktables/FloatTopic.h
+-rw-r--r--  2.0 unx     3396 b- defN 24-May-04 16:44 ntcore/include/networktables/FloatTopic.inc
+-rw-r--r--  2.0 unx    14044 b- defN 24-May-04 16:44 ntcore/include/networktables/GenericEntry.h
+-rw-r--r--  2.0 unx     6856 b- defN 24-May-04 16:44 ntcore/include/networktables/GenericEntry.inc
+-rw-r--r--  2.0 unx    13171 b- defN 24-May-04 16:44 ntcore/include/networktables/IntegerArrayTopic.h
+-rw-r--r--  2.0 unx     4774 b- defN 24-May-04 16:44 ntcore/include/networktables/IntegerArrayTopic.inc
+-rw-r--r--  2.0 unx    11147 b- defN 24-May-04 16:44 ntcore/include/networktables/IntegerTopic.h
+-rw-r--r--  2.0 unx     3530 b- defN 24-May-04 16:44 ntcore/include/networktables/IntegerTopic.inc
+-rw-r--r--  2.0 unx     1598 b- defN 24-May-04 16:44 ntcore/include/networktables/MultiSubscriber.h
+-rw-r--r--  2.0 unx      967 b- defN 24-May-04 16:44 ntcore/include/networktables/MultiSubscriber.inc
+-rw-r--r--  2.0 unx      638 b- defN 24-May-04 16:44 ntcore/include/networktables/NTSendable.h
+-rw-r--r--  2.0 unx     1497 b- defN 24-May-04 16:44 ntcore/include/networktables/NTSendableBuilder.h
+-rw-r--r--  2.0 unx    20549 b- defN 24-May-04 16:44 ntcore/include/networktables/NetworkTable.h
+-rw-r--r--  2.0 unx    15142 b- defN 24-May-04 16:44 ntcore/include/networktables/NetworkTableEntry.h
+-rw-r--r--  2.0 unx     7534 b- defN 24-May-04 16:44 ntcore/include/networktables/NetworkTableEntry.inc
+-rw-r--r--  2.0 unx    26081 b- defN 24-May-04 16:44 ntcore/include/networktables/NetworkTableInstance.h
+-rw-r--r--  2.0 unx     9235 b- defN 24-May-04 16:44 ntcore/include/networktables/NetworkTableInstance.inc
+-rw-r--r--  2.0 unx    10444 b- defN 24-May-04 16:44 ntcore/include/networktables/NetworkTableListener.h
+-rw-r--r--  2.0 unx     6138 b- defN 24-May-04 16:44 ntcore/include/networktables/NetworkTableListener.inc
+-rw-r--r--  2.0 unx     1128 b- defN 24-May-04 16:44 ntcore/include/networktables/NetworkTableType.h
+-rw-r--r--  2.0 unx    17866 b- defN 24-May-04 16:44 ntcore/include/networktables/NetworkTableValue.h
+-rw-r--r--  2.0 unx    14393 b- defN 24-May-04 16:44 ntcore/include/networktables/ProtobufTopic.h
+-rw-r--r--  2.0 unx    10931 b- defN 24-May-04 16:44 ntcore/include/networktables/RawTopic.h
+-rw-r--r--  2.0 unx     3758 b- defN 24-May-04 16:44 ntcore/include/networktables/RawTopic.inc
+-rw-r--r--  2.0 unx    11470 b- defN 24-May-04 16:44 ntcore/include/networktables/StringArrayTopic.h
+-rw-r--r--  2.0 unx     4055 b- defN 24-May-04 16:44 ntcore/include/networktables/StringArrayTopic.inc
+-rw-r--r--  2.0 unx    12902 b- defN 24-May-04 16:44 ntcore/include/networktables/StringTopic.h
+-rw-r--r--  2.0 unx     4217 b- defN 24-May-04 16:44 ntcore/include/networktables/StringTopic.inc
+-rw-r--r--  2.0 unx    22701 b- defN 24-May-04 16:44 ntcore/include/networktables/StructArrayTopic.h
+-rw-r--r--  2.0 unx    16217 b- defN 24-May-04 16:44 ntcore/include/networktables/StructTopic.h
+-rw-r--r--  2.0 unx    11263 b- defN 24-May-04 16:44 ntcore/include/networktables/Topic.h
+-rw-r--r--  2.0 unx     2769 b- defN 24-May-04 16:44 ntcore/include/networktables/Topic.inc
+-rw-r--r--  2.0 unx    12126 b- defN 24-May-04 16:44 ntcore/include/networktables/UnitTopic.h
+-rw-r--r--  2.0 unx     4541 b- defN 24-May-04 16:44 ntcore/include/networktables/UnitTopic.inc
+-rw-r--r--  2.0 unx  5649024 b- defN 24-May-04 16:44 ntcore/lib/libntcore.dylib
+-rw-r--r--  2.0 unx      650 b- defN 24-May-04 16:34 ntcore/meta/__init__.py
+-rw-r--r--  2.0 unx     1045 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/StructArrayTopic_tmpl1.cpp
+-rw-r--r--  2.0 unx     1040 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/StructArrayTopic_tmpl2.cpp
+-rw-r--r--  2.0 unx     1020 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/StructArrayTopic_tmpl3.cpp
+-rw-r--r--  2.0 unx     1020 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/StructArrayTopic_tmpl4.cpp
+-rw-r--r--  2.0 unx      955 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/StructTopic_tmpl1.cpp
+-rw-r--r--  2.0 unx      950 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/StructTopic_tmpl2.cpp
+-rw-r--r--  2.0 unx      930 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/StructTopic_tmpl3.cpp
+-rw-r--r--  2.0 unx      930 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/StructTopic_tmpl4.cpp
+-rw-r--r--  2.0 unx     1616 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__BooleanArrayPublisher.hpp
+-rw-r--r--  2.0 unx     1750 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__BooleanArraySubscriber.hpp
+-rw-r--r--  2.0 unx     1368 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__BooleanPublisher.hpp
+-rw-r--r--  2.0 unx     1382 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__BooleanSubscriber.hpp
+-rw-r--r--  2.0 unx     1602 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__DoubleArrayPublisher.hpp
+-rw-r--r--  2.0 unx     1735 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__DoubleArraySubscriber.hpp
+-rw-r--r--  2.0 unx     1356 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__DoublePublisher.hpp
+-rw-r--r--  2.0 unx     1370 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__DoubleSubscriber.hpp
+-rw-r--r--  2.0 unx     1588 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__FloatArrayPublisher.hpp
+-rw-r--r--  2.0 unx     1720 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__FloatArraySubscriber.hpp
+-rw-r--r--  2.0 unx     1344 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__FloatPublisher.hpp
+-rw-r--r--  2.0 unx     1358 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__FloatSubscriber.hpp
+-rw-r--r--  2.0 unx     1401 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__GenericPublisher.hpp
+-rw-r--r--  2.0 unx     1415 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__GenericSubscriber.hpp
+-rw-r--r--  2.0 unx     1616 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__IntegerArrayPublisher.hpp
+-rw-r--r--  2.0 unx     1750 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__IntegerArraySubscriber.hpp
+-rw-r--r--  2.0 unx     1368 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__IntegerPublisher.hpp
+-rw-r--r--  2.0 unx     1382 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__IntegerSubscriber.hpp
+-rw-r--r--  2.0 unx     2418 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__NTSendable.hpp
+-rw-r--r--  2.0 unx     2963 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__NTSendableBuilder.hpp
+-rw-r--r--  2.0 unx      743 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__Publisher.hpp
+-rw-r--r--  2.0 unx     1523 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__RawPublisher.hpp
+-rw-r--r--  2.0 unx     1648 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__RawSubscriber.hpp
+-rw-r--r--  2.0 unx     1416 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StringArrayPublisher.hpp
+-rw-r--r--  2.0 unx     1430 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StringArraySubscriber.hpp
+-rw-r--r--  2.0 unx     1532 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StringPublisher.hpp
+-rw-r--r--  2.0 unx     1660 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StringSubscriber.hpp
+-rw-r--r--  2.0 unx     2625 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StructArrayEntry.hpp
+-rw-r--r--  2.0 unx     4725 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StructArrayPublisher.hpp
+-rw-r--r--  2.0 unx     6348 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StructArraySubscriber.hpp
+-rw-r--r--  2.0 unx     6169 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StructArrayTopic.hpp
+-rw-r--r--  2.0 unx     2449 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StructEntry.hpp
+-rw-r--r--  2.0 unx     4299 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StructPublisher.hpp
+-rw-r--r--  2.0 unx     6042 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StructSubscriber.hpp
+-rw-r--r--  2.0 unx     5771 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__StructTopic.hpp
+-rw-r--r--  2.0 unx      747 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__Subscriber.hpp
+-rw-r--r--  2.0 unx     1877 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/nt__Timestamped.hpp
+-rw-r--r--  2.0 unx      688 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl1.cpp
+-rw-r--r--  2.0 unx      703 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl10.cpp
+-rw-r--r--  2.0 unx      711 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl11.cpp
+-rw-r--r--  2.0 unx      696 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl12.cpp
+-rw-r--r--  2.0 unx      709 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl13.cpp
+-rw-r--r--  2.0 unx      691 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl2.cpp
+-rw-r--r--  2.0 unx      689 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl3.cpp
+-rw-r--r--  2.0 unx      690 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl4.cpp
+-rw-r--r--  2.0 unx      695 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl5.cpp
+-rw-r--r--  2.0 unx      704 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl6.cpp
+-rw-r--r--  2.0 unx      700 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl7.cpp
+-rw-r--r--  2.0 unx      704 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl8.cpp
+-rw-r--r--  2.0 unx      702 b- defN 24-May-04 16:44 ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl9.cpp
+-rw-r--r--  2.0 unx     3076 b- defN 24-May-04 16:34 ntcore/src/NetworkTable.cpp.inl
+-rw-r--r--  2.0 unx     2293 b- defN 24-May-04 16:34 ntcore/src/NetworkTableEntry.cpp.inl
+-rw-r--r--  2.0 unx     1572 b- defN 24-May-04 16:34 ntcore/src/nt_instance.cpp
+-rw-r--r--  2.0 unx      400 b- defN 24-May-04 16:34 ntcore/src/nt_instance.h
+-rw-r--r--  2.0 unx     1005 b- defN 24-May-04 16:34 ntcore/src/nt_type_caster.h
+-rw-r--r--  2.0 unx      254 b- defN 24-May-04 16:34 ntcore/src/ntcore.cpp
+-rw-r--r--  2.0 unx     4980 b- defN 24-May-04 16:34 ntcore/src/py2value.cpp
+-rw-r--r--  2.0 unx      597 b- defN 24-May-04 16:34 ntcore/src/py2value.h
+-rw-r--r--  2.0 unx     4455 b- defN 24-May-04 16:34 ntcore/src/pyentry.cpp
+-rw-r--r--  2.0 unx     1224 b- defN 24-May-04 16:34 ntcore/src/pyentry.h
+-rw-r--r--  2.0 unx      476 b- defN 24-May-04 16:48 pyntcore-2024.3.2.1.dist-info/METADATA
+-rw-r--r--  2.0 unx      115 b- defN 24-May-04 16:48 pyntcore-2024.3.2.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       38 b- defN 24-May-04 16:44 pyntcore-2024.3.2.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 24-May-04 16:44 pyntcore-2024.3.2.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    13817 b- defN 24-May-04 16:48 pyntcore-2024.3.2.1.dist-info/RECORD
+139 files, 18839938 bytes uncompressed, 3687754 bytes compressed:  80.4%
```

## zipnote {}

```diff
@@ -3,15 +3,15 @@
 
 Filename: ntcore/_init_ntcore.py
 Comment: 
 
 Filename: ntcore/_logutil.py
 Comment: 
 
-Filename: ntcore/_ntcore.cp39-win_amd64.pyd
+Filename: ntcore/_ntcore.cpython-312-darwin.so
 Comment: 
 
 Filename: ntcore/pkgcfg.py
 Comment: 
 
 Filename: ntcore/py.typed
 Comment: 
@@ -21,21 +21,21 @@
 
 Filename: ntcore/util.py
 Comment: 
 
 Filename: ntcore/version.py
 Comment: 
 
-Filename: ntcore/__pycache__/__init__.cpython-39.pyc
+Filename: ntcore/__pycache__/__init__.cpython-312.pyc
 Comment: 
 
-Filename: ntcore/__pycache__/_init_ntcore.cpython-39.pyc
+Filename: ntcore/__pycache__/_init_ntcore.cpython-312.pyc
 Comment: 
 
-Filename: ntcore/__pycache__/version.cpython-39.pyc
+Filename: ntcore/__pycache__/version.cpython-312.pyc
 Comment: 
 
 Filename: ntcore/_ntcore/__init__.pyi
 Comment: 
 
 Filename: ntcore/_ntcore/meta.pyi
 Comment: 
@@ -186,18 +186,15 @@
 
 Filename: ntcore/include/networktables/UnitTopic.h
 Comment: 
 
 Filename: ntcore/include/networktables/UnitTopic.inc
 Comment: 
 
-Filename: ntcore/lib/ntcore.dll
-Comment: 
-
-Filename: ntcore/lib/ntcore.lib
+Filename: ntcore/lib/libntcore.dylib
 Comment: 
 
 Filename: ntcore/meta/__init__.py
 Comment: 
 
 Filename: ntcore/rpy-include/rpygen/StructArrayTopic_tmpl1.cpp
 Comment: 
@@ -399,23 +396,23 @@
 
 Filename: ntcore/src/pyentry.cpp
 Comment: 
 
 Filename: ntcore/src/pyentry.h
 Comment: 
 
-Filename: pyntcore-2024.3.2.0.dist-info/METADATA
+Filename: pyntcore-2024.3.2.1.dist-info/METADATA
 Comment: 
 
-Filename: pyntcore-2024.3.2.0.dist-info/WHEEL
+Filename: pyntcore-2024.3.2.1.dist-info/WHEEL
 Comment: 
 
-Filename: pyntcore-2024.3.2.0.dist-info/entry_points.txt
+Filename: pyntcore-2024.3.2.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: pyntcore-2024.3.2.0.dist-info/top_level.txt
+Filename: pyntcore-2024.3.2.1.dist-info/top_level.txt
 Comment: 
 
-Filename: pyntcore-2024.3.2.0.dist-info/RECORD
+Filename: pyntcore-2024.3.2.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## ntcore/__init__.py

 * *Ordering differences only*

```diff
@@ -1,195 +1,195 @@
-from . import _init_ntcore
-
-# autogenerated by 'robotpy-build create-imports ntcore'
-from ._ntcore import (
-    BooleanArrayEntry,
-    BooleanArrayPublisher,
-    BooleanArraySubscriber,
-    BooleanArrayTopic,
-    BooleanEntry,
-    BooleanPublisher,
-    BooleanSubscriber,
-    BooleanTopic,
-    ConnectionInfo,
-    DoubleArrayEntry,
-    DoubleArrayPublisher,
-    DoubleArraySubscriber,
-    DoubleArrayTopic,
-    DoubleEntry,
-    DoublePublisher,
-    DoubleSubscriber,
-    DoubleTopic,
-    Event,
-    EventFlags,
-    FloatArrayEntry,
-    FloatArrayPublisher,
-    FloatArraySubscriber,
-    FloatArrayTopic,
-    FloatEntry,
-    FloatPublisher,
-    FloatSubscriber,
-    FloatTopic,
-    GenericEntry,
-    GenericPublisher,
-    GenericSubscriber,
-    IntegerArrayEntry,
-    IntegerArrayPublisher,
-    IntegerArraySubscriber,
-    IntegerArrayTopic,
-    IntegerEntry,
-    IntegerPublisher,
-    IntegerSubscriber,
-    IntegerTopic,
-    LogMessage,
-    MultiSubscriber,
-    NTSendable,
-    NTSendableBuilder,
-    NetworkTable,
-    NetworkTableEntry,
-    NetworkTableInstance,
-    NetworkTableListener,
-    NetworkTableListenerPoller,
-    NetworkTableType,
-    PubSubOptions,
-    Publisher,
-    RawEntry,
-    RawPublisher,
-    RawSubscriber,
-    RawTopic,
-    StringArrayEntry,
-    StringArrayPublisher,
-    StringArraySubscriber,
-    StringArrayTopic,
-    StringEntry,
-    StringPublisher,
-    StringSubscriber,
-    StringTopic,
-    StructArrayEntry,
-    StructArrayPublisher,
-    StructArraySubscriber,
-    StructArrayTopic,
-    StructEntry,
-    StructPublisher,
-    StructSubscriber,
-    StructTopic,
-    Subscriber,
-    TimeSyncEventData,
-    TimestampedBoolean,
-    TimestampedBooleanArray,
-    TimestampedDouble,
-    TimestampedDoubleArray,
-    TimestampedFloat,
-    TimestampedFloatArray,
-    TimestampedInteger,
-    TimestampedIntegerArray,
-    TimestampedRaw,
-    TimestampedString,
-    TimestampedStringArray,
-    TimestampedStruct,
-    TimestampedStructArray,
-    Topic,
-    TopicInfo,
-    Value,
-    ValueEventData,
-)
-
-__all__ = [
-    "BooleanArrayEntry",
-    "BooleanArrayPublisher",
-    "BooleanArraySubscriber",
-    "BooleanArrayTopic",
-    "BooleanEntry",
-    "BooleanPublisher",
-    "BooleanSubscriber",
-    "BooleanTopic",
-    "ConnectionInfo",
-    "DoubleArrayEntry",
-    "DoubleArrayPublisher",
-    "DoubleArraySubscriber",
-    "DoubleArrayTopic",
-    "DoubleEntry",
-    "DoublePublisher",
-    "DoubleSubscriber",
-    "DoubleTopic",
-    "Event",
-    "EventFlags",
-    "FloatArrayEntry",
-    "FloatArrayPublisher",
-    "FloatArraySubscriber",
-    "FloatArrayTopic",
-    "FloatEntry",
-    "FloatPublisher",
-    "FloatSubscriber",
-    "FloatTopic",
-    "GenericEntry",
-    "GenericPublisher",
-    "GenericSubscriber",
-    "IntegerArrayEntry",
-    "IntegerArrayPublisher",
-    "IntegerArraySubscriber",
-    "IntegerArrayTopic",
-    "IntegerEntry",
-    "IntegerPublisher",
-    "IntegerSubscriber",
-    "IntegerTopic",
-    "LogMessage",
-    "MultiSubscriber",
-    "NTSendable",
-    "NTSendableBuilder",
-    "NetworkTable",
-    "NetworkTableEntry",
-    "NetworkTableInstance",
-    "NetworkTableListener",
-    "NetworkTableListenerPoller",
-    "NetworkTableType",
-    "PubSubOptions",
-    "Publisher",
-    "RawEntry",
-    "RawPublisher",
-    "RawSubscriber",
-    "RawTopic",
-    "StringArrayEntry",
-    "StringArrayPublisher",
-    "StringArraySubscriber",
-    "StringArrayTopic",
-    "StringEntry",
-    "StringPublisher",
-    "StringSubscriber",
-    "StringTopic",
-    "StructArrayEntry",
-    "StructArrayPublisher",
-    "StructArraySubscriber",
-    "StructArrayTopic",
-    "StructEntry",
-    "StructPublisher",
-    "StructSubscriber",
-    "StructTopic",
-    "Subscriber",
-    "TimeSyncEventData",
-    "TimestampedBoolean",
-    "TimestampedBooleanArray",
-    "TimestampedDouble",
-    "TimestampedDoubleArray",
-    "TimestampedFloat",
-    "TimestampedFloatArray",
-    "TimestampedInteger",
-    "TimestampedIntegerArray",
-    "TimestampedRaw",
-    "TimestampedString",
-    "TimestampedStringArray",
-    "TimestampedStruct",
-    "TimestampedStructArray",
-    "Topic",
-    "TopicInfo",
-    "Value",
-    "ValueEventData",
-]
-
-from ._ntcore import _now, _setNow
-
-__all__ += ["_now", "_setNow"]
-
-try:
-    from .version import version as __version__
-except ImportError:
-    __version__ = "master"
+from . import _init_ntcore
+
+# autogenerated by 'robotpy-build create-imports ntcore'
+from ._ntcore import (
+    BooleanArrayEntry,
+    BooleanArrayPublisher,
+    BooleanArraySubscriber,
+    BooleanArrayTopic,
+    BooleanEntry,
+    BooleanPublisher,
+    BooleanSubscriber,
+    BooleanTopic,
+    ConnectionInfo,
+    DoubleArrayEntry,
+    DoubleArrayPublisher,
+    DoubleArraySubscriber,
+    DoubleArrayTopic,
+    DoubleEntry,
+    DoublePublisher,
+    DoubleSubscriber,
+    DoubleTopic,
+    Event,
+    EventFlags,
+    FloatArrayEntry,
+    FloatArrayPublisher,
+    FloatArraySubscriber,
+    FloatArrayTopic,
+    FloatEntry,
+    FloatPublisher,
+    FloatSubscriber,
+    FloatTopic,
+    GenericEntry,
+    GenericPublisher,
+    GenericSubscriber,
+    IntegerArrayEntry,
+    IntegerArrayPublisher,
+    IntegerArraySubscriber,
+    IntegerArrayTopic,
+    IntegerEntry,
+    IntegerPublisher,
+    IntegerSubscriber,
+    IntegerTopic,
+    LogMessage,
+    MultiSubscriber,
+    NTSendable,
+    NTSendableBuilder,
+    NetworkTable,
+    NetworkTableEntry,
+    NetworkTableInstance,
+    NetworkTableListener,
+    NetworkTableListenerPoller,
+    NetworkTableType,
+    PubSubOptions,
+    Publisher,
+    RawEntry,
+    RawPublisher,
+    RawSubscriber,
+    RawTopic,
+    StringArrayEntry,
+    StringArrayPublisher,
+    StringArraySubscriber,
+    StringArrayTopic,
+    StringEntry,
+    StringPublisher,
+    StringSubscriber,
+    StringTopic,
+    StructArrayEntry,
+    StructArrayPublisher,
+    StructArraySubscriber,
+    StructArrayTopic,
+    StructEntry,
+    StructPublisher,
+    StructSubscriber,
+    StructTopic,
+    Subscriber,
+    TimeSyncEventData,
+    TimestampedBoolean,
+    TimestampedBooleanArray,
+    TimestampedDouble,
+    TimestampedDoubleArray,
+    TimestampedFloat,
+    TimestampedFloatArray,
+    TimestampedInteger,
+    TimestampedIntegerArray,
+    TimestampedRaw,
+    TimestampedString,
+    TimestampedStringArray,
+    TimestampedStruct,
+    TimestampedStructArray,
+    Topic,
+    TopicInfo,
+    Value,
+    ValueEventData,
+)
+
+__all__ = [
+    "BooleanArrayEntry",
+    "BooleanArrayPublisher",
+    "BooleanArraySubscriber",
+    "BooleanArrayTopic",
+    "BooleanEntry",
+    "BooleanPublisher",
+    "BooleanSubscriber",
+    "BooleanTopic",
+    "ConnectionInfo",
+    "DoubleArrayEntry",
+    "DoubleArrayPublisher",
+    "DoubleArraySubscriber",
+    "DoubleArrayTopic",
+    "DoubleEntry",
+    "DoublePublisher",
+    "DoubleSubscriber",
+    "DoubleTopic",
+    "Event",
+    "EventFlags",
+    "FloatArrayEntry",
+    "FloatArrayPublisher",
+    "FloatArraySubscriber",
+    "FloatArrayTopic",
+    "FloatEntry",
+    "FloatPublisher",
+    "FloatSubscriber",
+    "FloatTopic",
+    "GenericEntry",
+    "GenericPublisher",
+    "GenericSubscriber",
+    "IntegerArrayEntry",
+    "IntegerArrayPublisher",
+    "IntegerArraySubscriber",
+    "IntegerArrayTopic",
+    "IntegerEntry",
+    "IntegerPublisher",
+    "IntegerSubscriber",
+    "IntegerTopic",
+    "LogMessage",
+    "MultiSubscriber",
+    "NTSendable",
+    "NTSendableBuilder",
+    "NetworkTable",
+    "NetworkTableEntry",
+    "NetworkTableInstance",
+    "NetworkTableListener",
+    "NetworkTableListenerPoller",
+    "NetworkTableType",
+    "PubSubOptions",
+    "Publisher",
+    "RawEntry",
+    "RawPublisher",
+    "RawSubscriber",
+    "RawTopic",
+    "StringArrayEntry",
+    "StringArrayPublisher",
+    "StringArraySubscriber",
+    "StringArrayTopic",
+    "StringEntry",
+    "StringPublisher",
+    "StringSubscriber",
+    "StringTopic",
+    "StructArrayEntry",
+    "StructArrayPublisher",
+    "StructArraySubscriber",
+    "StructArrayTopic",
+    "StructEntry",
+    "StructPublisher",
+    "StructSubscriber",
+    "StructTopic",
+    "Subscriber",
+    "TimeSyncEventData",
+    "TimestampedBoolean",
+    "TimestampedBooleanArray",
+    "TimestampedDouble",
+    "TimestampedDoubleArray",
+    "TimestampedFloat",
+    "TimestampedFloatArray",
+    "TimestampedInteger",
+    "TimestampedIntegerArray",
+    "TimestampedRaw",
+    "TimestampedString",
+    "TimestampedStringArray",
+    "TimestampedStruct",
+    "TimestampedStructArray",
+    "Topic",
+    "TopicInfo",
+    "Value",
+    "ValueEventData",
+]
+
+from ._ntcore import _now, _setNow
+
+__all__ += ["_now", "_setNow"]
+
+try:
+    from .version import version as __version__
+except ImportError:
+    __version__ = "master"
```

## ntcore/_init_ntcore.py

```diff
@@ -1,18 +1,18 @@
-# This file is automatically generated, DO NOT EDIT
-# fmt: off
-
-from os.path import abspath, join, dirname, exists
-_root = abspath(dirname(__file__))
-
-# runtime dependencies
-import wpiutil._init_wpiutil
-import wpinet._init_wpinet
-from ctypes import cdll
-
-try:
-    _lib = cdll.LoadLibrary(join(_root, "lib", "ntcore.dll"))
-except FileNotFoundError:
-    if not exists(join(_root, "lib", "ntcore.dll")):
-        raise FileNotFoundError("ntcore.dll was not found on your system. Is this package correctly installed?")
-    raise Exception("ntcore.dll could not be loaded. Do you have Visual Studio C++ Redistributible 2019 installed?")
-
+# This file is automatically generated, DO NOT EDIT
+# fmt: off
+
+from os.path import abspath, join, dirname, exists
+_root = abspath(dirname(__file__))
+
+# runtime dependencies
+import wpiutil._init_wpiutil
+import wpinet._init_wpinet
+from ctypes import CDLL, RTLD_GLOBAL
+
+try:
+    _lib = CDLL(join(_root, "lib", "libntcore.dylib"), mode=RTLD_GLOBAL)
+except FileNotFoundError:
+    if not exists(join(_root, "lib", "libntcore.dylib")):
+        raise FileNotFoundError("libntcore.dylib was not found on your system. Is this package correctly installed?")
+    raise FileNotFoundError("libntcore.dylib could not be loaded. There is a missing dependency.")
+
```

## ntcore/_logutil.py

 * *Ordering differences only*

```diff
@@ -1,123 +1,123 @@
-import atexit
-import logging
-import threading
-
-from . import _ntcore
-
-import wpiutil.sync
-
-
-class InstanceAlreadyStartedError(Exception):
-    pass
-
-
-class NtLogForwarder:
-    """
-    Forwards ntcore's logger to python's logging system
-    """
-
-    _instlock = threading.Lock()
-    _instances = {}
-    _instcfg = {}
-
-    @classmethod
-    def config_logging(
-        cls,
-        instance: _ntcore.NetworkTableInstance,
-        minLevel: _ntcore.NetworkTableInstance.LogLevel,
-        maxLevel: _ntcore.NetworkTableInstance.LogLevel,
-        logName: str,
-    ):
-        handle = instance._getHandle()
-        with cls._instlock:
-            if handle in cls._instances:
-                raise InstanceAlreadyStartedError(
-                    "cannot configure logging after instance has been started"
-                )
-
-            cls._instcfg[handle] = (minLevel, maxLevel, logName)
-
-    @classmethod
-    def onInstanceStart(cls, instance: _ntcore.NetworkTableInstance):
-        handle = instance._getHandle()
-        with cls._instlock:
-            if handle in cls._instances:
-                return
-
-            default_cfg = (
-                _ntcore.NetworkTableInstance.LogLevel.kLogInfo,
-                _ntcore.NetworkTableInstance.LogLevel.kLogCritical,
-                "nt",
-            )
-            minLevel, maxLevel, logName = cls._instcfg.get(handle, default_cfg)
-
-            cls._instances[handle] = cls(instance, logName, minLevel, maxLevel)
-
-    @classmethod
-    def onInstanceDestroy(cls, instance: _ntcore.NetworkTableInstance):
-        handle = instance._getHandle()
-        with cls._instlock:
-            lfwd = cls._instances.pop(handle, None)
-            if lfwd:
-                lfwd.destroy()
-
-    def __init__(
-        self,
-        instance: _ntcore.NetworkTableInstance,
-        logName: str,
-        minLevel: _ntcore.NetworkTableInstance.LogLevel,
-        maxLevel: _ntcore.NetworkTableInstance.LogLevel,
-    ):
-        self.lock = threading.Lock()
-        self.poller = _ntcore.NetworkTableListenerPoller(instance)
-        ntLogger = self.poller.addLogger(minLevel, maxLevel)
-
-        self.thread = threading.Thread(
-            target=self._logging_thread,
-            name=logName + "-log-thread",
-            daemon=True,
-            args=(self.poller, logName, ntLogger),
-        )
-        self.thread.start()
-
-        atexit.register(self.destroy)
-
-    def _logging_thread(
-        self, poller: _ntcore.NetworkTableListenerPoller, logName: str, ntLogger: int
-    ):
-        logger = logging.getLogger(logName)
-
-        _waitForObject = wpiutil.sync.waitForObject
-        handle = poller.getHandle()
-
-        while True:
-            if not _waitForObject(handle):
-                break
-
-            messages = poller.readQueue()
-            if not messages:
-                continue
-
-            for msg in messages:
-                msg = msg.data
-                if logger.isEnabledFor(msg.level):
-                    lr = logger.makeRecord(
-                        logName,
-                        msg.level,
-                        msg.filename,
-                        msg.line,
-                        "%s",
-                        (msg.message,),
-                        None,
-                    )
-                    logger.handle(lr)
-
-    def destroy(self):
-        with self.lock:
-            if self.poller:
-                self.poller.close()
-                self.thread.join(timeout=1)
-            self.poller = None
-
-
-_config_logging = NtLogForwarder.config_logging
+import atexit
+import logging
+import threading
+
+from . import _ntcore
+
+import wpiutil.sync
+
+
+class InstanceAlreadyStartedError(Exception):
+    pass
+
+
+class NtLogForwarder:
+    """
+    Forwards ntcore's logger to python's logging system
+    """
+
+    _instlock = threading.Lock()
+    _instances = {}
+    _instcfg = {}
+
+    @classmethod
+    def config_logging(
+        cls,
+        instance: _ntcore.NetworkTableInstance,
+        minLevel: _ntcore.NetworkTableInstance.LogLevel,
+        maxLevel: _ntcore.NetworkTableInstance.LogLevel,
+        logName: str,
+    ):
+        handle = instance._getHandle()
+        with cls._instlock:
+            if handle in cls._instances:
+                raise InstanceAlreadyStartedError(
+                    "cannot configure logging after instance has been started"
+                )
+
+            cls._instcfg[handle] = (minLevel, maxLevel, logName)
+
+    @classmethod
+    def onInstanceStart(cls, instance: _ntcore.NetworkTableInstance):
+        handle = instance._getHandle()
+        with cls._instlock:
+            if handle in cls._instances:
+                return
+
+            default_cfg = (
+                _ntcore.NetworkTableInstance.LogLevel.kLogInfo,
+                _ntcore.NetworkTableInstance.LogLevel.kLogCritical,
+                "nt",
+            )
+            minLevel, maxLevel, logName = cls._instcfg.get(handle, default_cfg)
+
+            cls._instances[handle] = cls(instance, logName, minLevel, maxLevel)
+
+    @classmethod
+    def onInstanceDestroy(cls, instance: _ntcore.NetworkTableInstance):
+        handle = instance._getHandle()
+        with cls._instlock:
+            lfwd = cls._instances.pop(handle, None)
+            if lfwd:
+                lfwd.destroy()
+
+    def __init__(
+        self,
+        instance: _ntcore.NetworkTableInstance,
+        logName: str,
+        minLevel: _ntcore.NetworkTableInstance.LogLevel,
+        maxLevel: _ntcore.NetworkTableInstance.LogLevel,
+    ):
+        self.lock = threading.Lock()
+        self.poller = _ntcore.NetworkTableListenerPoller(instance)
+        ntLogger = self.poller.addLogger(minLevel, maxLevel)
+
+        self.thread = threading.Thread(
+            target=self._logging_thread,
+            name=logName + "-log-thread",
+            daemon=True,
+            args=(self.poller, logName, ntLogger),
+        )
+        self.thread.start()
+
+        atexit.register(self.destroy)
+
+    def _logging_thread(
+        self, poller: _ntcore.NetworkTableListenerPoller, logName: str, ntLogger: int
+    ):
+        logger = logging.getLogger(logName)
+
+        _waitForObject = wpiutil.sync.waitForObject
+        handle = poller.getHandle()
+
+        while True:
+            if not _waitForObject(handle):
+                break
+
+            messages = poller.readQueue()
+            if not messages:
+                continue
+
+            for msg in messages:
+                msg = msg.data
+                if logger.isEnabledFor(msg.level):
+                    lr = logger.makeRecord(
+                        logName,
+                        msg.level,
+                        msg.filename,
+                        msg.line,
+                        "%s",
+                        (msg.message,),
+                        None,
+                    )
+                    logger.handle(lr)
+
+    def destroy(self):
+        with self.lock:
+            if self.poller:
+                self.poller.close()
+                self.thread.join(timeout=1)
+            self.poller = None
+
+
+_config_logging = NtLogForwarder.config_logging
```

## ntcore/pkgcfg.py

```diff
@@ -1,24 +1,24 @@
-# fmt: off
-# This file is automatically generated, DO NOT EDIT
-
-from os.path import abspath, join, dirname
-_root = abspath(dirname(__file__))
-
-libinit_import = "ntcore._init_ntcore"
-depends = ['wpiutil', 'wpinet']
-pypi_package = 'pyntcore'
-
-def get_include_dirs():
-    return [join(_root, "include"), join(_root, "rpy-include")]
-
-def get_library_dirs():
-    return [join(_root, "lib")]
-
-def get_library_dirs_rel():
-    return ['lib']
-
-def get_library_names():
-    return ['ntcore']
-
-def get_library_full_names():
-    return ['ntcore.dll']
+# fmt: off
+# This file is automatically generated, DO NOT EDIT
+
+from os.path import abspath, join, dirname
+_root = abspath(dirname(__file__))
+
+libinit_import = "ntcore._init_ntcore"
+depends = ['wpiutil', 'wpinet']
+pypi_package = 'pyntcore'
+
+def get_include_dirs():
+    return [join(_root, "include"), join(_root, "rpy-include")]
+
+def get_library_dirs():
+    return [join(_root, "lib")]
+
+def get_library_dirs_rel():
+    return ['lib']
+
+def get_library_names():
+    return ['ntcore']
+
+def get_library_full_names():
+    return ['libntcore.dylib']
```

## ntcore/types.py

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-from typing import Sequence, Union
-
-ValueT = Union[
-    bool,
-    int,
-    float,
-    str,
-    bytes,
-    Sequence[bool],
-    Sequence[int],
-    Sequence[float],
-    Sequence[str],
-]
+from typing import Sequence, Union
+
+ValueT = Union[
+    bool,
+    int,
+    float,
+    str,
+    bytes,
+    Sequence[bool],
+    Sequence[int],
+    Sequence[float],
+    Sequence[str],
+]
```

## ntcore/util.py

 * *Ordering differences only*

```diff
@@ -1,224 +1,224 @@
-import threading
-import weakref
-
-from typing import Callable, Dict, Optional, Sequence
-
-from ._ntcore import NetworkTableInstance, NetworkTableEntry, NetworkTableType, Value
-
-__all__ = ["ntproperty", "ChooserControl"]
-
-
-class _NtProperty:
-    """
-    Don't use this directly, use @ntproperty instead
-    """
-
-    entry: NetworkTableEntry
-    defaultValue: Value
-
-    _instlock = threading.Lock()
-    _instances: Dict[int, weakref.WeakSet] = {}
-
-    @classmethod
-    def attach(cls, self: "_NtProperty", inst: NetworkTableInstance):
-        with cls._instlock:
-            handle = inst._getHandle()
-            props = cls._instances.get(handle)
-            if not props:
-                props = weakref.WeakSet()
-                cls._instances[handle] = props
-            props.add(self)
-
-    @classmethod
-    def onInstancePostReset(cls, inst: NetworkTableInstance):
-        with cls._instlock:
-            props = cls._instances.get(inst._getHandle(), [])
-            for prop in props:
-                prop.reset()
-
-    @classmethod
-    def onInstanceDestroy(cls, inst: NetworkTableInstance):
-        with cls._instlock:
-            cls._instances.pop(inst._getHandle(), None)
-
-    def __init__(
-        self,
-        key: str,
-        defaultValue,
-        writeDefault: bool,
-        persistent: bool,
-        type: Optional[NetworkTableType],
-        inst: NetworkTableInstance,
-    ) -> None:
-        # Autodetect the type if not provided, and store the default
-        # value as that specific type
-        if type is None:
-            self.defaultValue = Value.makeValue(defaultValue)
-            self.mkv = Value.getFactoryByType(self.defaultValue.type())
-        else:
-            self.mkv = Value.getFactoryByType(type)
-            self.defaultValue = self.mkv(defaultValue)
-
-        self.key = key
-        self.writeDefault = writeDefault
-        self.persistent = persistent
-        # never overwrite persistent values with defaults
-        if persistent:
-            self.writeDefault = False
-        self.inst = inst
-        _NtProperty.attach(self, inst)
-
-        # Set it up
-        self.reset()
-
-    def reset(self):
-        self.entry = self.inst.getEntry(self.key)
-        if self.writeDefault:
-            print("set v", self.defaultValue)
-            self.entry.setValue(self.defaultValue)
-        else:
-            print("set default", self.defaultValue)
-            self.entry.setDefaultValue(self.defaultValue)
-
-        if self.persistent:
-            self.entry.setPersistent()
-
-    def get(self, _):
-        return self.entry.value
-
-    def set(self, _, value):
-        self.entry.setValue(self.mkv(value))
-
-
-def ntproperty(
-    key: str,
-    defaultValue,
-    *,
-    writeDefault: bool = True,
-    doc: str = None,
-    persistent: bool = False,
-    type: Optional[NetworkTableType] = None,
-    inst: Optional[NetworkTableInstance] = None
-) -> property:
-    """
-    A property that you can add to your classes to access NetworkTables
-    variables like a normal variable.
-
-    :param key: A full NetworkTables key (eg ``/SmartDashboard/foo``)
-    :param defaultValue: Default value to use if not in the table
-    :type  defaultValue: any
-    :param writeDefault: If True, put the default value to the table,
-                         overwriting existing values
-    :param doc: If given, will be the docstring of the property.
-    :param persistent: If True, persist set values across restarts.
-                       *writeDefault* is ignored if this is True.
-    :param type: Specify the type of this entry. If not specified,
-                 will autodetect the type from the default value
-    :param inst: The NetworkTables instance to use.
-
-    Example usage::
-
-        class Foo(object):
-
-            something = ntproperty('/SmartDashboard/something', True)
-
-            ...
-
-            def do_thing(self):
-                if self.something:    # reads from value
-                    ...
-
-                    self.something = False # writes value
-
-    .. note:: When using empty lists/tuples, you must explicitly specify
-              the type.
-
-    .. warning::
-
-       This function assumes that the value's type
-       never changes. If it does, you'll get really strange
-       errors... so don't do that.
-    """
-    if inst is None:
-        inst = NetworkTableInstance.getDefault()
-
-    ntprop = _NtProperty(key, defaultValue, writeDefault, persistent, type, inst)
-    return property(fget=ntprop.get, fset=ntprop.set, doc=doc)
-
-
-class ChooserControl:
-    """
-    Interacts with a :class:`wpilib.SendableChooser`
-    object over NetworkTables.
-    """
-
-    def __init__(
-        self,
-        key: str,
-        on_choices: Optional[Callable[[Sequence[str]], None]] = None,
-        on_selected: Optional[Callable[[str], None]] = None,
-        *,
-        inst: Optional[NetworkTableInstance] = None
-    ) -> None:
-        """
-        :param key: NetworkTables key
-        :param on_choices: A function that will be called when the
-                           choices change.
-        :param on_selection: A function that will be called when the
-                             selection changes.
-        :param inst: The NetworkTables instance to use.
-        """
-
-        if inst is None:
-            inst = NetworkTableInstance.getDefault()
-
-        self.subtable = inst.getTable("SmartDashboard").getSubTable(key)
-
-        self.on_choices = on_choices
-        self.on_selected = on_selected
-
-        if on_choices or on_selected:
-            self.subtable.addTableListener(self._on_change, True)
-
-    def close(self) -> None:
-        """Stops listening for changes to the ``SendableChooser``"""
-        if self.on_choices or self.on_selected:
-            self.subtable.removeTableListener(self._on_change)
-
-    def getChoices(self) -> Sequence[str]:
-        """
-        Returns the current choices. If the chooser doesn't exist, this
-        will return an empty tuple.
-        """
-        return self.subtable.getStringArray("options", [])
-
-    def getSelected(self) -> Optional[str]:
-        """
-        Returns the current selection or None
-        """
-        selected = self.subtable.getString("selected", None)
-        if selected is None:
-            selected = self.subtable.getString("default", None)
-        return selected
-
-    def setSelected(self, selection: str) -> None:
-        """
-        Sets the active selection on the chooser
-
-        :param selection: Active selection name
-        """
-        self.subtable.putString("selected", selection)
-
-    def _on_change(self, table, key, value, isNew):
-        if key == "options":
-            if self.on_choices is not None:
-                self.on_choices(value)
-        elif key == "selected":
-            if self.on_selected is not None:
-                self.on_selected(value)
-        elif key == "default":
-            if (
-                self.on_selected is not None
-                and self.subtable.getString("selected", None) is None
-            ):
-                self.on_selected(value)
+import threading
+import weakref
+
+from typing import Callable, Dict, Optional, Sequence
+
+from ._ntcore import NetworkTableInstance, NetworkTableEntry, NetworkTableType, Value
+
+__all__ = ["ntproperty", "ChooserControl"]
+
+
+class _NtProperty:
+    """
+    Don't use this directly, use @ntproperty instead
+    """
+
+    entry: NetworkTableEntry
+    defaultValue: Value
+
+    _instlock = threading.Lock()
+    _instances: Dict[int, weakref.WeakSet] = {}
+
+    @classmethod
+    def attach(cls, self: "_NtProperty", inst: NetworkTableInstance):
+        with cls._instlock:
+            handle = inst._getHandle()
+            props = cls._instances.get(handle)
+            if not props:
+                props = weakref.WeakSet()
+                cls._instances[handle] = props
+            props.add(self)
+
+    @classmethod
+    def onInstancePostReset(cls, inst: NetworkTableInstance):
+        with cls._instlock:
+            props = cls._instances.get(inst._getHandle(), [])
+            for prop in props:
+                prop.reset()
+
+    @classmethod
+    def onInstanceDestroy(cls, inst: NetworkTableInstance):
+        with cls._instlock:
+            cls._instances.pop(inst._getHandle(), None)
+
+    def __init__(
+        self,
+        key: str,
+        defaultValue,
+        writeDefault: bool,
+        persistent: bool,
+        type: Optional[NetworkTableType],
+        inst: NetworkTableInstance,
+    ) -> None:
+        # Autodetect the type if not provided, and store the default
+        # value as that specific type
+        if type is None:
+            self.defaultValue = Value.makeValue(defaultValue)
+            self.mkv = Value.getFactoryByType(self.defaultValue.type())
+        else:
+            self.mkv = Value.getFactoryByType(type)
+            self.defaultValue = self.mkv(defaultValue)
+
+        self.key = key
+        self.writeDefault = writeDefault
+        self.persistent = persistent
+        # never overwrite persistent values with defaults
+        if persistent:
+            self.writeDefault = False
+        self.inst = inst
+        _NtProperty.attach(self, inst)
+
+        # Set it up
+        self.reset()
+
+    def reset(self):
+        self.entry = self.inst.getEntry(self.key)
+        if self.writeDefault:
+            print("set v", self.defaultValue)
+            self.entry.setValue(self.defaultValue)
+        else:
+            print("set default", self.defaultValue)
+            self.entry.setDefaultValue(self.defaultValue)
+
+        if self.persistent:
+            self.entry.setPersistent()
+
+    def get(self, _):
+        return self.entry.value
+
+    def set(self, _, value):
+        self.entry.setValue(self.mkv(value))
+
+
+def ntproperty(
+    key: str,
+    defaultValue,
+    *,
+    writeDefault: bool = True,
+    doc: str = None,
+    persistent: bool = False,
+    type: Optional[NetworkTableType] = None,
+    inst: Optional[NetworkTableInstance] = None
+) -> property:
+    """
+    A property that you can add to your classes to access NetworkTables
+    variables like a normal variable.
+
+    :param key: A full NetworkTables key (eg ``/SmartDashboard/foo``)
+    :param defaultValue: Default value to use if not in the table
+    :type  defaultValue: any
+    :param writeDefault: If True, put the default value to the table,
+                         overwriting existing values
+    :param doc: If given, will be the docstring of the property.
+    :param persistent: If True, persist set values across restarts.
+                       *writeDefault* is ignored if this is True.
+    :param type: Specify the type of this entry. If not specified,
+                 will autodetect the type from the default value
+    :param inst: The NetworkTables instance to use.
+
+    Example usage::
+
+        class Foo(object):
+
+            something = ntproperty('/SmartDashboard/something', True)
+
+            ...
+
+            def do_thing(self):
+                if self.something:    # reads from value
+                    ...
+
+                    self.something = False # writes value
+
+    .. note:: When using empty lists/tuples, you must explicitly specify
+              the type.
+
+    .. warning::
+
+       This function assumes that the value's type
+       never changes. If it does, you'll get really strange
+       errors... so don't do that.
+    """
+    if inst is None:
+        inst = NetworkTableInstance.getDefault()
+
+    ntprop = _NtProperty(key, defaultValue, writeDefault, persistent, type, inst)
+    return property(fget=ntprop.get, fset=ntprop.set, doc=doc)
+
+
+class ChooserControl:
+    """
+    Interacts with a :class:`wpilib.SendableChooser`
+    object over NetworkTables.
+    """
+
+    def __init__(
+        self,
+        key: str,
+        on_choices: Optional[Callable[[Sequence[str]], None]] = None,
+        on_selected: Optional[Callable[[str], None]] = None,
+        *,
+        inst: Optional[NetworkTableInstance] = None
+    ) -> None:
+        """
+        :param key: NetworkTables key
+        :param on_choices: A function that will be called when the
+                           choices change.
+        :param on_selection: A function that will be called when the
+                             selection changes.
+        :param inst: The NetworkTables instance to use.
+        """
+
+        if inst is None:
+            inst = NetworkTableInstance.getDefault()
+
+        self.subtable = inst.getTable("SmartDashboard").getSubTable(key)
+
+        self.on_choices = on_choices
+        self.on_selected = on_selected
+
+        if on_choices or on_selected:
+            self.subtable.addTableListener(self._on_change, True)
+
+    def close(self) -> None:
+        """Stops listening for changes to the ``SendableChooser``"""
+        if self.on_choices or self.on_selected:
+            self.subtable.removeTableListener(self._on_change)
+
+    def getChoices(self) -> Sequence[str]:
+        """
+        Returns the current choices. If the chooser doesn't exist, this
+        will return an empty tuple.
+        """
+        return self.subtable.getStringArray("options", [])
+
+    def getSelected(self) -> Optional[str]:
+        """
+        Returns the current selection or None
+        """
+        selected = self.subtable.getString("selected", None)
+        if selected is None:
+            selected = self.subtable.getString("default", None)
+        return selected
+
+    def setSelected(self, selection: str) -> None:
+        """
+        Sets the active selection on the chooser
+
+        :param selection: Active selection name
+        """
+        self.subtable.putString("selected", selection)
+
+    def _on_change(self, table, key, value, isNew):
+        if key == "options":
+            if self.on_choices is not None:
+                self.on_choices(value)
+        elif key == "selected":
+            if self.on_selected is not None:
+                self.on_selected(value)
+        elif key == "default":
+            if (
+                self.on_selected is not None
+                and self.subtable.getString("selected", None) is None
+            ):
+                self.on_selected(value)
```

## ntcore/version.py

```diff
@@ -1,4 +1,4 @@
-# file generated by setuptools_scm
-# don't change, don't track in version control
-__version__ = version = '2024.3.2.0'
-__version_tuple__ = version_tuple = (2024, 3, 2, 0)
+# file generated by setuptools_scm
+# don't change, don't track in version control
+__version__ = version = '2024.3.2.1'
+__version_tuple__ = version_tuple = (2024, 3, 2, 1)
```

## ntcore/_ntcore/__init__.pyi

```diff
@@ -1,7426 +1,7440 @@
-from __future__ import annotations
-import typing
-import typing_extensions
-import wpiutil
-import wpiutil._wpiutil
-import wpiutil._wpiutil.log
-from . import meta
-__all__ = ['BooleanArrayEntry', 'BooleanArrayPublisher', 'BooleanArraySubscriber', 'BooleanArrayTopic', 'BooleanEntry', 'BooleanPublisher', 'BooleanSubscriber', 'BooleanTopic', 'ConnectionInfo', 'DoubleArrayEntry', 'DoubleArrayPublisher', 'DoubleArraySubscriber', 'DoubleArrayTopic', 'DoubleEntry', 'DoublePublisher', 'DoubleSubscriber', 'DoubleTopic', 'Event', 'EventFlags', 'FloatArrayEntry', 'FloatArrayPublisher', 'FloatArraySubscriber', 'FloatArrayTopic', 'FloatEntry', 'FloatPublisher', 'FloatSubscriber', 'FloatTopic', 'GenericEntry', 'GenericPublisher', 'GenericSubscriber', 'IntegerArrayEntry', 'IntegerArrayPublisher', 'IntegerArraySubscriber', 'IntegerArrayTopic', 'IntegerEntry', 'IntegerPublisher', 'IntegerSubscriber', 'IntegerTopic', 'LogMessage', 'MultiSubscriber', 'NTSendable', 'NTSendableBuilder', 'NetworkTable', 'NetworkTableEntry', 'NetworkTableInstance', 'NetworkTableListener', 'NetworkTableListenerPoller', 'NetworkTableType', 'PubSubOptions', 'Publisher', 'RawEntry', 'RawPublisher', 'RawSubscriber', 'RawTopic', 'StringArrayEntry', 'StringArrayPublisher', 'StringArraySubscriber', 'StringArrayTopic', 'StringEntry', 'StringPublisher', 'StringSubscriber', 'StringTopic', 'StructArrayEntry', 'StructArrayPublisher', 'StructArraySubscriber', 'StructArrayTopic', 'StructEntry', 'StructPublisher', 'StructSubscriber', 'StructTopic', 'Subscriber', 'TimeSyncEventData', 'TimestampedBoolean', 'TimestampedBooleanArray', 'TimestampedDouble', 'TimestampedDoubleArray', 'TimestampedFloat', 'TimestampedFloatArray', 'TimestampedInteger', 'TimestampedIntegerArray', 'TimestampedRaw', 'TimestampedString', 'TimestampedStringArray', 'TimestampedStruct', 'TimestampedStructArray', 'Topic', 'TopicInfo', 'Value', 'ValueEventData', 'meta']
-class BooleanArrayEntry(BooleanArraySubscriber, BooleanArrayPublisher):
-    """
-    NetworkTables BooleanArray entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> BooleanArrayEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> BooleanArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class BooleanArrayPublisher(Publisher):
-    """
-    NetworkTables BooleanArray publisher.
-    """
-    def __enter__(self) -> BooleanArrayPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> BooleanArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: list[int], time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: list[int]) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class BooleanArraySubscriber(Subscriber):
-    """
-    NetworkTables BooleanArray subscriber.
-    """
-    def __enter__(self) -> BooleanArraySubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> list[int]:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: list[int]) -> list[int]:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedBooleanArray:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: list[int]) -> TimestampedBooleanArray:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> BooleanArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedBooleanArray]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class BooleanArrayTopic(Topic):
-    """
-    NetworkTables BooleanArray topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'boolean[]'
-    def __enter__(self) -> BooleanArrayTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: list[int], options: PubSubOptions = ...) -> BooleanArrayEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: list[int], options: PubSubOptions = ...) -> BooleanArrayEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> BooleanArrayPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> BooleanArrayPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: list[int], options: PubSubOptions = ...) -> BooleanArraySubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: list[int], options: PubSubOptions = ...) -> BooleanArraySubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class BooleanEntry(BooleanSubscriber, BooleanPublisher):
-    """
-    NetworkTables Boolean entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> BooleanEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> BooleanTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class BooleanPublisher(Publisher):
-    """
-    NetworkTables Boolean publisher.
-    """
-    def __enter__(self) -> BooleanPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> BooleanTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: bool, time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: bool) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class BooleanSubscriber(Subscriber):
-    """
-    NetworkTables Boolean subscriber.
-    """
-    def __enter__(self) -> BooleanSubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> bool:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: bool) -> bool:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedBoolean:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: bool) -> TimestampedBoolean:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> BooleanTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedBoolean]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class BooleanTopic(Topic):
-    """
-    NetworkTables Boolean topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'boolean'
-    def __enter__(self) -> BooleanTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: bool, options: PubSubOptions = ...) -> BooleanEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: bool, options: PubSubOptions = ...) -> BooleanEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> BooleanPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> BooleanPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: bool, options: PubSubOptions = ...) -> BooleanSubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: bool, options: PubSubOptions = ...) -> BooleanSubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class ConnectionInfo:
-    """
-    NetworkTables Connection Information
-    """
-    def __init__(self) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def last_update(self) -> int:
-        """
-        The last time any update was received from the remote node (same scale as
-        returned by nt::Now()).
-        """
-    @last_update.setter
-    def last_update(self, arg0: int) -> None:
-        ...
-    @property
-    def protocol_version(self) -> int:
-        """
-        The protocol version being used for this connection.  This in protocol
-        layer format, so 0x0200 = 2.0, 0x0300 = 3.0).
-        """
-    @protocol_version.setter
-    def protocol_version(self, arg0: int) -> None:
-        ...
-    @property
-    def remote_id(self) -> str:
-        """
-        The remote identifier (as set on the remote node by
-        NetworkTableInstance::StartClient4() or nt::StartClient4()).
-        """
-    @remote_id.setter
-    def remote_id(self, arg0: str) -> None:
-        ...
-    @property
-    def remote_ip(self) -> str:
-        """
-        The IP address of the remote node.
-        """
-    @remote_ip.setter
-    def remote_ip(self, arg0: str) -> None:
-        ...
-    @property
-    def remote_port(self) -> int:
-        """
-        The port number of the remote node.
-        """
-    @remote_port.setter
-    def remote_port(self, arg0: int) -> None:
-        ...
-class DoubleArrayEntry(DoubleArraySubscriber, DoubleArrayPublisher):
-    """
-    NetworkTables DoubleArray entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> DoubleArrayEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> DoubleArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class DoubleArrayPublisher(Publisher):
-    """
-    NetworkTables DoubleArray publisher.
-    """
-    def __enter__(self) -> DoubleArrayPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> DoubleArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: list[float], time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: list[float]) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class DoubleArraySubscriber(Subscriber):
-    """
-    NetworkTables DoubleArray subscriber.
-    """
-    def __enter__(self) -> DoubleArraySubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> list[float]:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: list[float]) -> list[float]:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedDoubleArray:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: list[float]) -> TimestampedDoubleArray:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> DoubleArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedDoubleArray]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class DoubleArrayTopic(Topic):
-    """
-    NetworkTables DoubleArray topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'double[]'
-    def __enter__(self) -> DoubleArrayTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: list[float], options: PubSubOptions = ...) -> DoubleArrayEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: list[float], options: PubSubOptions = ...) -> DoubleArrayEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> DoubleArrayPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> DoubleArrayPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: list[float], options: PubSubOptions = ...) -> DoubleArraySubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: list[float], options: PubSubOptions = ...) -> DoubleArraySubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class DoubleEntry(DoubleSubscriber, DoublePublisher):
-    """
-    NetworkTables Double entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> DoubleEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> DoubleTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class DoublePublisher(Publisher):
-    """
-    NetworkTables Double publisher.
-    """
-    def __enter__(self) -> DoublePublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> DoubleTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: float, time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: float) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class DoubleSubscriber(Subscriber):
-    """
-    NetworkTables Double subscriber.
-    """
-    def __enter__(self) -> DoubleSubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> float:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: float) -> float:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedDouble:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: float) -> TimestampedDouble:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> DoubleTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedDouble]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class DoubleTopic(Topic):
-    """
-    NetworkTables Double topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'double'
-    def __enter__(self) -> DoubleTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: float, options: PubSubOptions = ...) -> DoubleEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: float, options: PubSubOptions = ...) -> DoubleEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> DoublePublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> DoublePublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: float, options: PubSubOptions = ...) -> DoubleSubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: float, options: PubSubOptions = ...) -> DoubleSubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class Event:
-    """
-    NetworkTables event
-    """
-    def __repr__(self) -> str:
-        ...
-    def is_(self, kind: int) -> bool:
-        """
-        Test event flags.
-        
-        :param kind: event flag(s) to test
-        
-        :returns: True if flags matches kind
-        """
-    @property
-    def data(self) -> ConnectionInfo | TopicInfo | ValueEventData | LogMessage | TimeSyncEventData:
-        ...
-    @property
-    def flags(self) -> int:
-        """
-        Event flags (NT_EventFlags). Also indicates the data included with the
-        event:
-        - NT_EVENT_CONNECTED or NT_EVENT_DISCONNECTED: GetConnectionInfo()
-        - NT_EVENT_PUBLISH, NT_EVENT_UNPUBLISH, or NT_EVENT_PROPERTIES:
-        GetTopicInfo()
-        - NT_EVENT_VALUE, NT_EVENT_VALUE_LOCAL: GetValueData()
-        - NT_EVENT_LOGMESSAGE: GetLogMessage()
-        - NT_EVENT_TIMESYNC: GetTimeSyncEventData()
-        """
-    @flags.setter
-    def flags(self, arg0: int) -> None:
-        ...
-    @property
-    def listener(self) -> int:
-        """
-        Listener that triggered this event.
-        """
-class EventFlags:
-    """
-    Event notification flags.
-    
-    The flags are a bitmask and must be OR'ed together to indicate the
-    combination of events desired to be received.
-    """
-    kConnected: typing.ClassVar[int] = 2
-    kConnection: typing.ClassVar[int] = 6
-    kDisconnected: typing.ClassVar[int] = 4
-    kImmediate: typing.ClassVar[int] = 1
-    kLogMessage: typing.ClassVar[int] = 256
-    kNone: typing.ClassVar[int] = 0
-    kProperties: typing.ClassVar[int] = 32
-    kPublish: typing.ClassVar[int] = 8
-    kTimeSync: typing.ClassVar[int] = 512
-    kTopic: typing.ClassVar[int] = 56
-    kUnpublish: typing.ClassVar[int] = 16
-    kValueAll: typing.ClassVar[int] = 192
-    kValueLocal: typing.ClassVar[int] = 128
-    kValueRemote: typing.ClassVar[int] = 64
-class FloatArrayEntry(FloatArraySubscriber, FloatArrayPublisher):
-    """
-    NetworkTables FloatArray entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> FloatArrayEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> FloatArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class FloatArrayPublisher(Publisher):
-    """
-    NetworkTables FloatArray publisher.
-    """
-    def __enter__(self) -> FloatArrayPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> FloatArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: list[float], time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: list[float]) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class FloatArraySubscriber(Subscriber):
-    """
-    NetworkTables FloatArray subscriber.
-    """
-    def __enter__(self) -> FloatArraySubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> list[float]:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: list[float]) -> list[float]:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedFloatArray:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: list[float]) -> TimestampedFloatArray:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> FloatArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedFloatArray]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class FloatArrayTopic(Topic):
-    """
-    NetworkTables FloatArray topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'float[]'
-    def __enter__(self) -> FloatArrayTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: list[float], options: PubSubOptions = ...) -> FloatArrayEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: list[float], options: PubSubOptions = ...) -> FloatArrayEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> FloatArrayPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> FloatArrayPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: list[float], options: PubSubOptions = ...) -> FloatArraySubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: list[float], options: PubSubOptions = ...) -> FloatArraySubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class FloatEntry(FloatSubscriber, FloatPublisher):
-    """
-    NetworkTables Float entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> FloatEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> FloatTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class FloatPublisher(Publisher):
-    """
-    NetworkTables Float publisher.
-    """
-    def __enter__(self) -> FloatPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> FloatTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: float, time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: float) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class FloatSubscriber(Subscriber):
-    """
-    NetworkTables Float subscriber.
-    """
-    def __enter__(self) -> FloatSubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> float:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: float) -> float:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedFloat:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: float) -> TimestampedFloat:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> FloatTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedFloat]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class FloatTopic(Topic):
-    """
-    NetworkTables Float topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'float'
-    def __enter__(self) -> FloatTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: float, options: PubSubOptions = ...) -> FloatEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: float, options: PubSubOptions = ...) -> FloatEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> FloatPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> FloatPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: float, options: PubSubOptions = ...) -> FloatSubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: float, options: PubSubOptions = ...) -> FloatSubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class GenericEntry(GenericSubscriber, GenericPublisher):
-    """
-    NetworkTables generic entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> GenericEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> Topic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class GenericPublisher(Publisher):
-    """
-    NetworkTables generic publisher.
-    """
-    def getTopic(self) -> Topic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: Value) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        """
-    def setBoolean(self, value: bool, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    @typing.overload
-    def setBooleanArray(self, value: list[bool], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    @typing.overload
-    def setBooleanArray(self, value: list[int], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefault(self, value: Value) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-    def setDefaultBoolean(self, defaultValue: bool) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultBooleanArray(self, defaultValue: list[int]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultDouble(self, defaultValue: float) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultDoubleArray(self, defaultValue: list[float]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultFloat(self, defaultValue: float) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultFloatArray(self, defaultValue: list[float]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultInteger(self, defaultValue: int) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultIntegerArray(self, defaultValue: list[int]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultRaw(self, defaultValue: typing_extensions.Buffer) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultString(self, defaultValue: str) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultStringArray(self, defaultValue: list[str]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDouble(self, value: float, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDoubleArray(self, value: list[float], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setFloat(self, value: float, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setFloatArray(self, value: list[float], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setInteger(self, value: int, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setIntegerArray(self, value: list[int], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setRaw(self, value: typing_extensions.Buffer, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setString(self, value: str, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setStringArray(self, value: list[str], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-class GenericSubscriber(Subscriber):
-    """
-    NetworkTables generic subscriber.
-    """
-    def get(self) -> Value:
-        """
-        Get the last published value.
-        If no value has been published, returns a value with unassigned type.
-        
-        :returns: value
-        """
-    def getBoolean(self, defaultValue: bool) -> bool:
-        """
-        Gets the entry's value as a boolean. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getBooleanArray(self, defaultValue: list[int]) -> list[int]:
-        """
-        Gets the entry's value as a boolean array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-                  
-                  .. note:: The returned array is std::vector<int> instead of std::vector<bool>
-                     because std::vector<bool> is special-cased in C++.  0 is false, any
-                     non-zero value is true.
-        """
-    def getDouble(self, defaultValue: float) -> float:
-        """
-        Gets the entry's value as a double. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getDoubleArray(self, defaultValue: list[float]) -> list[float]:
-        """
-        Gets the entry's value as a double array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getFloat(self, defaultValue: float) -> float:
-        """
-        Gets the entry's value as a float. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getFloatArray(self, defaultValue: list[float]) -> list[float]:
-        """
-        Gets the entry's value as a float array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getInteger(self, defaultValue: int) -> int:
-        """
-        Gets the entry's value as a integer. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getIntegerArray(self, defaultValue: list[int]) -> list[int]:
-        """
-        Gets the entry's value as a integer array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getRaw(self, defaultValue: typing_extensions.Buffer) -> bytes:
-        """
-        Gets the entry's value as a raw. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getString(self, defaultValue: str) -> str:
-        """
-        Gets the entry's value as a string. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getStringArray(self, defaultValue: list[str]) -> list[str]:
-        """
-        Gets the entry's value as a string array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getTopic(self) -> Topic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[Value]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class IntegerArrayEntry(IntegerArraySubscriber, IntegerArrayPublisher):
-    """
-    NetworkTables IntegerArray entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> IntegerArrayEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> IntegerArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class IntegerArrayPublisher(Publisher):
-    """
-    NetworkTables IntegerArray publisher.
-    """
-    def __enter__(self) -> IntegerArrayPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> IntegerArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: list[int], time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: list[int]) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class IntegerArraySubscriber(Subscriber):
-    """
-    NetworkTables IntegerArray subscriber.
-    """
-    def __enter__(self) -> IntegerArraySubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> list[int]:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: list[int]) -> list[int]:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedIntegerArray:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: list[int]) -> TimestampedIntegerArray:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> IntegerArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedIntegerArray]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class IntegerArrayTopic(Topic):
-    """
-    NetworkTables IntegerArray topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'int[]'
-    def __enter__(self) -> IntegerArrayTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: list[int], options: PubSubOptions = ...) -> IntegerArrayEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: list[int], options: PubSubOptions = ...) -> IntegerArrayEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> IntegerArrayPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> IntegerArrayPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: list[int], options: PubSubOptions = ...) -> IntegerArraySubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: list[int], options: PubSubOptions = ...) -> IntegerArraySubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class IntegerEntry(IntegerSubscriber, IntegerPublisher):
-    """
-    NetworkTables Integer entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> IntegerEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> IntegerTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class IntegerPublisher(Publisher):
-    """
-    NetworkTables Integer publisher.
-    """
-    def __enter__(self) -> IntegerPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> IntegerTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: int, time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: int) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class IntegerSubscriber(Subscriber):
-    """
-    NetworkTables Integer subscriber.
-    """
-    def __enter__(self) -> IntegerSubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> int:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: int) -> int:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedInteger:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: int) -> TimestampedInteger:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> IntegerTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedInteger]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class IntegerTopic(Topic):
-    """
-    NetworkTables Integer topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'int'
-    def __enter__(self) -> IntegerTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: int, options: PubSubOptions = ...) -> IntegerEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: int, options: PubSubOptions = ...) -> IntegerEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> IntegerPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> IntegerPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: int, options: PubSubOptions = ...) -> IntegerSubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: int, options: PubSubOptions = ...) -> IntegerSubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class LogMessage:
-    """
-    NetworkTables log message.
-    """
-    @property
-    def filename(self) -> str:
-        """
-        The filename of the source file that generated the message.
-        """
-    @property
-    def level(self) -> int:
-        """
-        Log level of the message.  See NT_LogLevel.
-        """
-    @level.setter
-    def level(self, arg0: int) -> None:
-        ...
-    @property
-    def line(self) -> int:
-        """
-        The line number in the source file that generated the message.
-        """
-    @line.setter
-    def line(self, arg0: int) -> None:
-        ...
-    @property
-    def message(self) -> str:
-        """
-        The message.
-        """
-class MultiSubscriber:
-    """
-    Subscribe to multiple topics based on one or more topic name prefixes. Can be
-    used in combination with ValueListenerPoller to listen for value changes
-    across all matching topics.
-    """
-    def __enter__(self) -> MultiSubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, inst: NetworkTableInstance, prefixes: list[str], options: PubSubOptions = ...) -> None:
-        """
-        Create a multiple subscriber.
-        
-        :param inst:     instance
-        :param prefixes: topic name prefixes
-        :param options:  subscriber options
-        """
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-class NTSendable(wpiutil._wpiutil.Sendable):
-    """
-    Interface for NetworkTable Sendable objects.
-    """
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def initSendable(self, builder: NTSendableBuilder) -> None:
-        """
-        Initializes this Sendable object.
-        
-        :param builder: sendable builder
-        """
-    @typing.overload
-    def initSendable(self, builder: wpiutil._wpiutil.SendableBuilder) -> None:
-        ...
-class NTSendableBuilder(wpiutil._wpiutil.SendableBuilder):
-    """
-    Helper class for building Sendable dashboard representations for
-    NetworkTables.
-    """
-    def __init__(self) -> None:
-        ...
-    def getBackendKind(self) -> wpiutil._wpiutil.SendableBuilder.BackendKind:
-        """
-        Gets the kind of backend being used.
-        
-        :returns: Backend kind
-        """
-    def getTable(self) -> NetworkTable:
-        """
-        Get the network table.
-        
-        :returns: The network table
-        """
-    def getTopic(self, key: str) -> Topic:
-        """
-        Add a property without getters or setters.  This can be used to get
-        entry handles for the function called by SetUpdateTable().
-        
-        :param key: property name
-        
-        :returns: Network table topic
-        """
-    def setUpdateTable(self, func: typing.Callable[[], None]) -> None:
-        """
-        Set the function that should be called to update the network table
-        for things other than properties.  Note this function is not passed
-        the network table object; instead it should use the entry handles
-        returned by GetEntry().
-        
-        :param func: function
-        """
-class NetworkTable:
-    """
-    A network table that knows its subtable path.
-    @ingroup ntcore_cpp_api
-    """
-    PATH_SEPARATOR_CHAR: typing.ClassVar[str] = '/'
-    @staticmethod
-    def basenameKey(key: str) -> str:
-        """
-        Gets the "base name" of a key. For example, "/foo/bar" becomes "bar".
-        If the key has a trailing slash, returns an empty string.
-        
-        :param key: key
-        
-        :returns: base name
-        """
-    @staticmethod
-    def getHierarchy(key: str) -> list[str]:
-        """
-        Gets a list of the names of all the super tables of a given key. For
-        example, the key "/foo/bar/baz" has a hierarchy of "/", "/foo",
-        "/foo/bar", and "/foo/bar/baz".
-        
-        :param key: the key
-        
-        :returns: List of super tables
-        """
-    @staticmethod
-    def normalizeKey(key: str, withLeadingSlash: bool = True) -> str:
-        """
-        Normalizes an network table key to contain no consecutive slashes and
-        optionally start with a leading slash. For example:
-        
-        <pre><code>
-        normalizeKey("/foo/bar", true)  == "/foo/bar"
-        normalizeKey("foo/bar", true)   == "/foo/bar"
-        normalizeKey("/foo/bar", false) == "foo/bar"
-        normalizeKey("foo//bar", false) == "foo/bar"
-        </code></pre>
-        
-        :param key:              the key to normalize
-        :param withLeadingSlash: whether or not the normalized key should begin
-                                 with a leading slash
-        
-        :returns: normalized key
-        """
-    def __contains__(self, arg0: str) -> bool:
-        ...
-    @typing.overload
-    def addListener(self, eventMask: int, listener: typing.Callable[[NetworkTable, str, Event], None]) -> int:
-        """
-        Listen to topics only within this table.
-        
-        :param eventMask: Bitmask of EventFlags values
-        :param listener:  listener to add
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, key: str, eventMask: int, listener: typing.Callable[[NetworkTable, str, Event], None]) -> int:
-        """
-        Listen to a single key.
-        
-        :param key:       the key name
-        :param eventMask: Bitmask of EventFlags values
-        :param listener:  listener to add
-        
-        :returns: Listener handle
-        """
-    def addSubTableListener(self, listener: typing.Callable[[NetworkTable, str, NetworkTable], None]) -> int:
-        """
-        Listen for sub-table creation. This calls the listener once for each newly
-        created sub-table. It immediately calls the listener for any existing
-        sub-tables.
-        
-        :param listener: listener to add
-        
-        :returns: Listener handle
-        """
-    def clearPersistent(self, key: str) -> None:
-        """
-        Stop making a key's value persistent through program restarts.
-        The key cannot be null.
-        
-        :param key: the key name
-        """
-    def containsKey(self, key: str) -> bool:
-        """
-        Determines whether the given key is in this table.
-        
-        :param key: the key to search for
-        
-        :returns: true if the table as a value assigned to the given key
-        """
-    def containsSubTable(self, key: str) -> bool:
-        """
-        Determines whether there exists a non-empty subtable for this key
-        in this table.
-        
-        :param key: the key to search for
-        
-        :returns: true if there is a subtable with the key which contains at least
-                  one key/subtable of its own
-        """
-    def getBoolean(self, key: str, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the boolean associated with the given name. If the key does not
-        exist or is of different type, it will return the default value.
-        
-        :param key:          the key to look up
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the value associated with the given key or the given default value
-                  if there is no value associated with the key
-        """
-    def getBooleanArray(self, key: str, defaultValue: typing.Any) -> typing.Any:
-        """
-        Returns the boolean array the key maps to. If the key does not exist or is
-        of different type, it will return the default value.
-        
-        :param key:          the key to look up
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the value associated with the given key or the given default value
-                  if there is no value associated with the key
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-                  
-                  .. note:: The returned array is std::vector<int> instead of std::vector<bool>
-                     because std::vector<bool> is special-cased in C++.  0 is false, any
-                     non-zero value is true.
-        """
-    def getBooleanArrayTopic(self, name: str) -> BooleanArrayTopic:
-        """
-        Get boolean[] topic.
-        
-        :param name: topic name
-        
-        :returns: BooleanArrayTopic
-        """
-    def getBooleanTopic(self, name: str) -> BooleanTopic:
-        """
-        Get boolean topic.
-        
-        :param name: topic name
-        
-        :returns: BooleanTopic
-        """
-    def getDoubleArrayTopic(self, name: str) -> DoubleArrayTopic:
-        """
-        Get double[] topic.
-        
-        :param name: topic name
-        
-        :returns: DoubleArrayTopic
-        """
-    def getDoubleTopic(self, name: str) -> DoubleTopic:
-        """
-        Get double topic.
-        
-        :param name: topic name
-        
-        :returns: DoubleTopic
-        """
-    def getEntry(self, key: str) -> NetworkTableEntry:
-        """
-        Gets the entry for a subkey.
-        
-        :param key: the key name
-        
-        :returns: Network table entry.
-        """
-    def getFloatArrayTopic(self, name: str) -> FloatArrayTopic:
-        """
-        Get float[] topic.
-        
-        :param name: topic name
-        
-        :returns: FloatArrayTopic
-        """
-    def getFloatTopic(self, name: str) -> FloatTopic:
-        """
-        Get float topic.
-        
-        :param name: topic name
-        
-        :returns: FloatTopic
-        """
-    def getInstance(self) -> NetworkTableInstance:
-        """
-        Gets the instance for the table.
-        
-        :returns: Instance
-        """
-    def getIntegerArrayTopic(self, name: str) -> IntegerArrayTopic:
-        """
-        Get integer[] topic.
-        
-        :param name: topic name
-        
-        :returns: IntegerArrayTopic
-        """
-    def getIntegerTopic(self, name: str) -> IntegerTopic:
-        """
-        Get integer topic.
-        
-        :param name: topic name
-        
-        :returns: IntegerTopic
-        """
-    def getKeys(self, types: int = 0) -> list[str]:
-        """
-        Gets all keys in the table (not including sub-tables).
-        
-        :param types: bitmask of types; 0 is treated as a "don't care".
-        
-        :returns: keys currently in the table
-        """
-    def getNumber(self, key: str, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the number associated with the given name.
-        
-        :param key:          the key to look up
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the value associated with the given key or the given default value
-                  if there is no value associated with the key
-        """
-    def getNumberArray(self, key: str, defaultValue: typing.Any) -> typing.Any:
-        """
-        Returns the number array the key maps to. If the key does not exist or is
-        of different type, it will return the default value.
-        
-        :param key:          the key to look up
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the value associated with the given key or the given default value
-                  if there is no value associated with the key
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getPath(self) -> str:
-        """
-        Gets the full path of this table.  Does not include the trailing "/".
-        
-        :returns: The path (e.g "", "/foo").
-        """
-    def getRaw(self, key: str, defaultValue: typing.Any) -> typing.Any:
-        """
-        Returns the raw value (byte array) the key maps to. If the key does not
-        exist or is of different type, it will return the default value.
-        
-        :param key:          the key to look up
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the value associated with the given key or the given default value
-                  if there is no value associated with the key
-                  
-                  .. note:: This makes a copy of the raw contents.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getRawTopic(self, name: str) -> RawTopic:
-        """
-        Get raw topic.
-        
-        :param name: topic name
-        
-        :returns: BooleanArrayTopic
-        """
-    def getString(self, key: str, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the string associated with the given name. If the key does not
-        exist or is of different type, it will return the default value.
-        
-        :param key:          the key to look up
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the value associated with the given key or the given default value
-                  if there is no value associated with the key
-        """
-    def getStringArray(self, key: str, defaultValue: typing.Any) -> typing.Any:
-        """
-        Returns the string array the key maps to. If the key does not exist or is
-        of different type, it will return the default value.
-        
-        :param key:          the key to look up
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the value associated with the given key or the given default value
-                  if there is no value associated with the key
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getStringArrayTopic(self, name: str) -> StringArrayTopic:
-        """
-        Get String[] topic.
-        
-        :param name: topic name
-        
-        :returns: StringArrayTopic
-        """
-    def getStringTopic(self, name: str) -> StringTopic:
-        """
-        Get String topic.
-        
-        :param name: topic name
-        
-        :returns: StringTopic
-        """
-    def getStructArrayTopic(self, name: str, type: type) -> StructArrayTopic:
-        """
-        Gets a raw struct serialized array topic.
-        
-        :param name: topic name
-        :param type: optional struct type info
-        
-        :returns: Topic
-        """
-    def getStructTopic(self, name: str, type: type) -> StructTopic:
-        """
-        Gets a raw struct serialized value topic.
-        
-        :param name: topic name
-        :param type: optional struct type info
-        
-        :returns: Topic
-        """
-    def getSubTable(self, key: str) -> NetworkTable:
-        """
-        Returns the table at the specified key. If there is no table at the
-        specified key, it will create a new table
-        
-        :param key: the key name
-        
-        :returns: the networktable to be returned
-        """
-    def getSubTables(self) -> list[str]:
-        """
-        Gets the names of all subtables in the table.
-        
-        :returns: subtables currently in the table
-        """
-    def getTopic(self, name: str) -> Topic:
-        """
-        Get (generic) topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getTopicInfo(self, types: int = 0) -> list[TopicInfo]:
-        """
-        Gets topic information for all keys in the table (not including
-        sub-tables).
-        
-        :param types: bitmask of types; 0 is treated as a "don't care".
-        
-        :returns: topic information for keys currently in the table
-        """
-    def getTopics(self, types: int = 0) -> list[Topic]:
-        """
-        Gets all topics in the table (not including sub-tables).
-        
-        :param types: bitmask of types; 0 is treated as a "don't care".
-        
-        :returns: topic for keys currently in the table
-        """
-    def getValue(self, key: str, value: typing.Any) -> typing.Any:
-        ...
-    def isPersistent(self, key: str) -> bool:
-        """
-        Returns whether the value is persistent through program restarts.
-        The key cannot be null.
-        
-        :param key: the key name
-        """
-    def putBoolean(self, key: str, value: bool) -> bool:
-        """
-        Put a boolean in the table
-        
-        :param key:   the key to be assigned to
-        :param value: the value that will be assigned
-        
-        :returns: False if the table key already exists with a different type
-        """
-    def putBooleanArray(self, key: str, value: list[int]) -> bool:
-        """
-        Put a boolean array in the table
-        
-        :param key:   the key to be assigned to
-        :param value: the value that will be assigned
-        
-        :returns: False if the table key already exists with a different type
-                  
-                  .. note:: The array must be of int's rather than of bool's because
-                     std::vector<bool> is special-cased in C++.  0 is false, any
-                     non-zero value is true.
-        """
-    def putNumber(self, key: str, value: float) -> bool:
-        """
-        Put a number in the table
-        
-        :param key:   the key to be assigned to
-        :param value: the value that will be assigned
-        
-        :returns: False if the table key already exists with a different type
-        """
-    def putNumberArray(self, key: str, value: list[float]) -> bool:
-        """
-        Put a number array in the table
-        
-        :param key:   the key to be assigned to
-        :param value: the value that will be assigned
-        
-        :returns: False if the table key already exists with a different type
-        """
-    def putRaw(self, key: str, value: typing_extensions.Buffer) -> bool:
-        """
-        Put a raw value (byte array) in the table
-        
-        :param key:   the key to be assigned to
-        :param value: the value that will be assigned
-        
-        :returns: False if the table key already exists with a different type
-        """
-    def putString(self, key: str, value: str) -> bool:
-        """
-        Put a string in the table
-        
-        :param key:   the key to be assigned to
-        :param value: the value that will be assigned
-        
-        :returns: False if the table key already exists with a different type
-        """
-    def putStringArray(self, key: str, value: list[str]) -> bool:
-        """
-        Put a string array in the table
-        
-        :param key:   the key to be assigned to
-        :param value: the value that will be assigned
-        
-        :returns: False if the table key already exists with a different type
-        """
-    @typing.overload
-    def putValue(self, key: str, value: float) -> bool:
-        ...
-    @typing.overload
-    def putValue(self, key: str, value: bool) -> bool:
-        ...
-    @typing.overload
-    def putValue(self, key: str, value: bytes) -> bool:
-        ...
-    @typing.overload
-    def putValue(self, key: str, value: str) -> bool:
-        ...
-    @typing.overload
-    def putValue(self, key: str, value: typing.Sequence) -> bool:
-        ...
-    def removeListener(self, listener: int) -> None:
-        """
-        Remove a listener.
-        
-        :param listener: listener handle
-        """
-    def setDefaultBoolean(self, key: str, defaultValue: bool) -> bool:
-        """
-        Gets the current value in the table, setting it if it does not exist.
-        
-        :param key:          the key
-        :param defaultValue: the default value to set if key doesn't exist.
-        
-        :returns: False if the table key exists with a different type
-        """
-    def setDefaultBooleanArray(self, key: str, defaultValue: list[int]) -> bool:
-        """
-        Gets the current value in the table, setting it if it does not exist.
-        
-        :param key:          the key
-        :param defaultValue: the default value to set if key doesn't exist.
-        
-        :returns: False if the table key exists with a different type
-        """
-    def setDefaultNumber(self, key: str, defaultValue: float) -> bool:
-        """
-        Gets the current value in the table, setting it if it does not exist.
-        
-        :param key:          the key
-        :param defaultValue: the default value to set if key doesn't exist.
-        
-        :returns: False if the table key exists with a different type
-        """
-    def setDefaultNumberArray(self, key: str, defaultValue: list[float]) -> bool:
-        """
-        Gets the current value in the table, setting it if it does not exist.
-        
-        :param key:          the key
-        :param defaultValue: the default value to set if key doesn't exist.
-        
-        :returns: False if the table key exists with a different type
-        """
-    def setDefaultRaw(self, key: str, defaultValue: typing_extensions.Buffer) -> bool:
-        """
-        Gets the current value in the table, setting it if it does not exist.
-        
-        :param key:          the key
-        :param defaultValue: the default value to set if key doesn't exist.
-        
-        :returns: False if the table key exists with a different type
-        """
-    def setDefaultString(self, key: str, defaultValue: str) -> bool:
-        """
-        Gets the current value in the table, setting it if it does not exist.
-        
-        :param key:          the key
-        :param defaultValue: the default value to set if key doesn't exist.
-        
-        :returns: False if the table key exists with a different type
-        """
-    def setDefaultStringArray(self, key: str, defaultValue: list[str]) -> bool:
-        """
-        Gets the current value in the table, setting it if it does not exist.
-        
-        :param key:          the key
-        :param defaultValue: the default value to set if key doesn't exist.
-        
-        :returns: False if the table key exists with a different type
-        """
-    @typing.overload
-    def setDefaultValue(self, key: str, value: float) -> bool:
-        ...
-    @typing.overload
-    def setDefaultValue(self, key: str, value: bool) -> bool:
-        ...
-    @typing.overload
-    def setDefaultValue(self, key: str, value: bytes) -> bool:
-        ...
-    @typing.overload
-    def setDefaultValue(self, key: str, value: str) -> bool:
-        ...
-    @typing.overload
-    def setDefaultValue(self, key: str, value: typing.Sequence) -> bool:
-        ...
-    def setPersistent(self, key: str) -> None:
-        """
-        Makes a key's value persistent through program restarts.
-        
-        :param key: the key to make persistent
-        """
-class NetworkTableEntry:
-    """
-    NetworkTables Entry
-    
-    .. note:: For backwards compatibility, the NetworkTableEntry destructor does not
-       release the entry.
-    
-    @ingroup ntcore_cpp_api
-    """
-    class Flags:
-        """
-        Flag values (as returned by GetFlags()).
-        
-        :deprecated: Use IsPersistent() instead.
-        
-        Members:
-        
-          kPersistent
-        """
-        __members__: typing.ClassVar[dict[str, NetworkTableEntry.Flags]]  # value = {'kPersistent': <Flags.kPersistent: 1>}
-        kPersistent: typing.ClassVar[NetworkTableEntry.Flags]  # value = <Flags.kPersistent: 1>
-        def __and__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __eq__(self, other: typing.Any) -> bool:
-            ...
-        def __ge__(self, other: typing.Any) -> bool:
-            ...
-        def __getstate__(self) -> int:
-            ...
-        def __gt__(self, other: typing.Any) -> bool:
-            ...
-        def __hash__(self) -> int:
-            ...
-        def __index__(self) -> int:
-            ...
-        def __init__(self, value: int) -> None:
-            ...
-        def __int__(self) -> int:
-            ...
-        def __invert__(self) -> typing.Any:
-            ...
-        def __le__(self, other: typing.Any) -> bool:
-            ...
-        def __lt__(self, other: typing.Any) -> bool:
-            ...
-        def __ne__(self, other: typing.Any) -> bool:
-            ...
-        def __or__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __rand__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __repr__(self) -> str:
-            ...
-        def __ror__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __rxor__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __setstate__(self, state: int) -> None:
-            ...
-        def __str__(self) -> str:
-            ...
-        def __xor__(self, other: typing.Any) -> typing.Any:
-            ...
-        @property
-        def name(self) -> str:
-            ...
-        @property
-        def value(self) -> int:
-            ...
-    __hash__: typing.ClassVar[None] = None
-    def __eq__(self, arg0: NetworkTableEntry) -> bool:
-        """
-        Equality operator.  Returns true if both instances refer to the same
-        native handle.
-        """
-    def clearFlags(self, flags: int) -> None:
-        """
-        Clears flags.
-        
-        :deprecated: Use SetPersistent() or topic properties instead
-        
-        :param flags: the flags to clear (bitmask)
-        """
-    def clearPersistent(self) -> None:
-        """
-        Stop making value persistent through program restarts.
-        """
-    def delete(self) -> None:
-        """
-        Deletes the entry.
-        
-        :deprecated: Use Unpublish() instead.
-        """
-    def exists(self) -> bool:
-        """
-        Determines if the entry currently exists.
-        
-        :returns: True if the entry exists, false otherwise.
-        """
-    def getBoolean(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a boolean. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getBooleanArray(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a boolean array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-                  
-                  .. note:: The returned array is std::vector<int> instead of std::vector<bool>
-                     because std::vector<bool> is special-cased in C++.  0 is false, any
-                     non-zero value is true.
-        """
-    def getDouble(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a double. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getDoubleArray(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a double array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getFlags(self) -> int:
-        """
-        Returns the flags.
-        
-        :deprecated: Use IsPersistent() or topic properties instead
-        
-        :returns: the flags (bitmask)
-        """
-    def getFloat(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a float. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getFloatArray(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a float array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getInstance(self) -> NetworkTableInstance:
-        """
-        Gets the instance for the entry.
-        
-        :returns: Instance
-        """
-    def getInteger(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a integer. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getIntegerArray(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a integer array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getLastChange(self) -> int:
-        """
-        Gets the last time the entry's value was changed.
-        
-        :returns: Entry last change time
-        """
-    def getName(self) -> str:
-        """
-        Gets the name of the entry (the key).
-        
-        :returns: the entry's name
-        """
-    def getRaw(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a raw. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getString(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a string. If the entry does not exist or is of
-        different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-        """
-    def getStringArray(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Gets the entry's value as a string array. If the entry does not exist
-        or is of different type, it will return the default value.
-        
-        :param defaultValue: the value to be returned if no value is found
-        
-        :returns: the entry's value or the given default value
-                  
-                  .. note:: This makes a copy of the array.  If the overhead of this is a
-                     concern, use GetValue() instead.
-        """
-    def getTopic(self) -> Topic:
-        """
-        Gets the entry's topic.
-        
-        :returns: Topic
-        """
-    def getType(self) -> NetworkTableType:
-        """
-        Gets the type of the entry.
-        
-        :returns: the entry's type
-        """
-    def getValue(self) -> Value:
-        """
-        Gets the entry's value. If the entry does not exist, returns an empty
-        value.
-        
-        :returns: the entry's value or an empty value if it does not exist.
-        """
-    def isPersistent(self) -> bool:
-        """
-        Returns whether the value is persistent through program restarts.
-        
-        :returns: True if the value is persistent.
-        """
-    def readQueue(self) -> list[Value]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        
-        The "poll storage" subscribe option can be used to set the queue depth.
-        
-        :returns: Array of values; empty array if no new changes have been
-                  published since the previous call.
-        """
-    def setBoolean(self, value: bool, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setBooleanArray(self, value: list[bool], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultBoolean(self, defaultValue: bool) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultBooleanArray(self, defaultValue: list[int]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultDouble(self, defaultValue: float) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultDoubleArray(self, defaultValue: list[float]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultFloat(self, defaultValue: float) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultFloatArray(self, defaultValue: list[float]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultInteger(self, defaultValue: int) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultIntegerArray(self, defaultValue: list[int]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultRaw(self, defaultValue: typing_extensions.Buffer) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultString(self, defaultValue: str) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDefaultStringArray(self, defaultValue: list[str]) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    @typing.overload
-    def setDefaultValue(self, defaultValue: Value) -> bool:
-        """
-        Sets the entry's value if it does not exist.
-        
-        :param defaultValue: the default value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    @typing.overload
-    def setDefaultValue(self, value: float) -> bool:
-        ...
-    @typing.overload
-    def setDefaultValue(self, value: bool) -> bool:
-        ...
-    @typing.overload
-    def setDefaultValue(self, value: bytes) -> bool:
-        ...
-    @typing.overload
-    def setDefaultValue(self, value: str) -> bool:
-        ...
-    @typing.overload
-    def setDefaultValue(self, value: typing.Sequence) -> bool:
-        ...
-    def setDouble(self, value: float, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setDoubleArray(self, value: list[float], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setFlags(self, flags: int) -> None:
-        """
-        Sets flags.
-        
-        :deprecated: Use SetPersistent() or topic properties instead
-        
-        :param flags: the flags to set (bitmask)
-        """
-    def setFloat(self, value: float, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setFloatArray(self, value: list[float], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setInteger(self, value: int, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setIntegerArray(self, value: list[int], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setPersistent(self) -> None:
-        """
-        Make value persistent through program restarts.
-        """
-    def setRaw(self, value: typing_extensions.Buffer, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setString(self, value: str, time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    def setStringArray(self, value: list[str], time: int = 0) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        :param time:  the timestamp to set (0 = nt::Now())
-        
-        :returns: False if the entry exists with a different type
-        """
-    @typing.overload
-    def setValue(self, value: Value) -> bool:
-        """
-        Sets the entry's value.
-        
-        :param value: the value to set
-        
-        :returns: False if the entry exists with a different type
-        """
-    @typing.overload
-    def setValue(self, value: float) -> bool:
-        ...
-    @typing.overload
-    def setValue(self, value: bool) -> bool:
-        ...
-    @typing.overload
-    def setValue(self, value: bytes) -> bool:
-        ...
-    @typing.overload
-    def setValue(self, value: str) -> bool:
-        ...
-    @typing.overload
-    def setValue(self, value: typing.Sequence) -> bool:
-        ...
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's been published.
-        """
-    @property
-    def value(self) -> typing.Any:
-        ...
-class NetworkTableInstance:
-    """
-    NetworkTables Instance.
-    
-    Instances are completely independent from each other.  Table operations on
-    one instance will not be visible to other instances unless the instances are
-    connected via the network.  The main limitation on instances is that you
-    cannot have two servers on the same network port.  The main utility of
-    instances is for unit testing, but they can also enable one program to
-    connect to two different NetworkTables networks.
-    
-    The global "default" instance (as returned by GetDefault()) is
-    always available, and is intended for the common case when there is only
-    a single NetworkTables instance being used in the program.  The
-    default instance cannot be destroyed.
-    
-    Additional instances can be created with the Create() function.
-    Instances are not reference counted or RAII.  Instead, they must be
-    explicitly destroyed (with Destroy()).
-    
-    @ingroup ntcore_cpp_api
-    """
-    class LogLevel:
-        """
-        Logging levels (as used by SetLogger()).
-        
-        Members:
-        
-          kLogCritical
-        
-          kLogError
-        
-          kLogWarning
-        
-          kLogInfo
-        
-          kLogDebug
-        
-          kLogDebug1
-        
-          kLogDebug2
-        
-          kLogDebug3
-        
-          kLogDebug4
-        """
-        __members__: typing.ClassVar[dict[str, NetworkTableInstance.LogLevel]]  # value = {'kLogCritical': <LogLevel.kLogCritical: 50>, 'kLogError': <LogLevel.kLogError: 40>, 'kLogWarning': <LogLevel.kLogWarning: 30>, 'kLogInfo': <LogLevel.kLogInfo: 20>, 'kLogDebug': <LogLevel.kLogDebug: 10>, 'kLogDebug1': <LogLevel.kLogDebug1: 9>, 'kLogDebug2': <LogLevel.kLogDebug2: 8>, 'kLogDebug3': <LogLevel.kLogDebug3: 7>, 'kLogDebug4': <LogLevel.kLogDebug4: 6>}
-        kLogCritical: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogCritical: 50>
-        kLogDebug: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug: 10>
-        kLogDebug1: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug1: 9>
-        kLogDebug2: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug2: 8>
-        kLogDebug3: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug3: 7>
-        kLogDebug4: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug4: 6>
-        kLogError: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogError: 40>
-        kLogInfo: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogInfo: 20>
-        kLogWarning: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogWarning: 30>
-        def __eq__(self, other: typing.Any) -> bool:
-            ...
-        def __getstate__(self) -> int:
-            ...
-        def __hash__(self) -> int:
-            ...
-        def __index__(self) -> int:
-            ...
-        def __init__(self, value: int) -> None:
-            ...
-        def __int__(self) -> int:
-            ...
-        def __ne__(self, other: typing.Any) -> bool:
-            ...
-        def __repr__(self) -> str:
-            ...
-        def __setstate__(self, state: int) -> None:
-            ...
-        def __str__(self) -> str:
-            ...
-        @property
-        def name(self) -> str:
-            ...
-        @property
-        def value(self) -> int:
-            ...
-    class NetworkMode:
-        """
-        Client/server mode flag values (as returned by GetNetworkMode()).
-        This is a bitmask.
-        
-        Members:
-        
-          kNetModeNone
-        
-          kNetModeServer
-        
-          kNetModeClient3
-        
-          kNetModeClient4
-        
-          kNetModeLocal
-        
-          kNetModeStarting
-        """
-        __members__: typing.ClassVar[dict[str, NetworkTableInstance.NetworkMode]]  # value = {'kNetModeNone': <NetworkMode.kNetModeNone: 0>, 'kNetModeServer': <NetworkMode.kNetModeServer: 1>, 'kNetModeClient3': <NetworkMode.kNetModeClient3: 2>, 'kNetModeClient4': <NetworkMode.kNetModeClient4: 4>, 'kNetModeLocal': <NetworkMode.kNetModeLocal: 16>, 'kNetModeStarting': <NetworkMode.kNetModeStarting: 8>}
-        kNetModeClient3: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeClient3: 2>
-        kNetModeClient4: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeClient4: 4>
-        kNetModeLocal: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeLocal: 16>
-        kNetModeNone: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeNone: 0>
-        kNetModeServer: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeServer: 1>
-        kNetModeStarting: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeStarting: 8>
-        def __and__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __eq__(self, other: typing.Any) -> bool:
-            ...
-        def __ge__(self, other: typing.Any) -> bool:
-            ...
-        def __getstate__(self) -> int:
-            ...
-        def __gt__(self, other: typing.Any) -> bool:
-            ...
-        def __hash__(self) -> int:
-            ...
-        def __index__(self) -> int:
-            ...
-        def __init__(self, value: int) -> None:
-            ...
-        def __int__(self) -> int:
-            ...
-        def __invert__(self) -> typing.Any:
-            ...
-        def __le__(self, other: typing.Any) -> bool:
-            ...
-        def __lt__(self, other: typing.Any) -> bool:
-            ...
-        def __ne__(self, other: typing.Any) -> bool:
-            ...
-        def __or__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __rand__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __repr__(self) -> str:
-            ...
-        def __ror__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __rxor__(self, other: typing.Any) -> typing.Any:
-            ...
-        def __setstate__(self, state: int) -> None:
-            ...
-        def __str__(self) -> str:
-            ...
-        def __xor__(self, other: typing.Any) -> typing.Any:
-            ...
-        @property
-        def name(self) -> str:
-            ...
-        @property
-        def value(self) -> int:
-            ...
-    __hash__: typing.ClassVar[None] = None
-    kDefaultPort3: typing.ClassVar[int] = 1735
-    kDefaultPort4: typing.ClassVar[int] = 5810
-    @staticmethod
-    def create() -> NetworkTableInstance:
-        """
-        Create an instance.
-        
-        :returns: Newly created instance
-        """
-    @staticmethod
-    def destroy(inst: NetworkTableInstance) -> None:
-        """
-        Destroys an instance (note: this has global effect).
-        
-        :param inst: Instance
-        """
-    @staticmethod
-    def getDefault() -> NetworkTableInstance:
-        """
-        Get global default instance.
-        
-        :returns: Global default instance
-        """
-    @staticmethod
-    def removeListener(listener: int) -> None:
-        """
-        Remove a listener.
-        
-        :param listener: Listener handle to remove
-        """
-    @staticmethod
-    def stopConnectionDataLog(logger: int) -> None:
-        """
-        Stops logging connection changes to a DataLog.
-        
-        :param logger: data logger handle
-        """
-    @staticmethod
-    def stopEntryDataLog(logger: int) -> None:
-        """
-        Stops logging entry changes to a DataLog.
-        
-        :param logger: data logger handle
-        """
-    def __eq__(self, arg0: NetworkTableInstance) -> bool:
-        """
-        Equality operator.  Returns true if both instances refer to the same
-        native handle.
-        """
-    def _getHandle(self) -> int:
-        """
-        Gets the native handle for the entry.
-        
-        :returns: Native handle
-        """
-    def _reset(self) -> None:
-        ...
-    def addConnectionListener(self, immediate_notify: bool, callback: typing.Callable[[Event], None]) -> int:
-        """
-        Add a connection listener. The callback function is called asynchronously
-        on a separate thread, so it's important to use synchronization or atomics
-        when accessing any shared state from the callback function.
-        
-        :param immediate_notify: notify listener of all existing connections
-        :param callback:         listener to add
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, topic: Topic, eventMask: int, listener: typing.Callable[[Event], None]) -> int:
-        """
-        Add a listener for changes on a particular topic. The callback
-        function is called asynchronously on a separate thread, so it's important
-        to use synchronization or atomics when accessing any shared state from the
-        callback function.
-        
-        This creates a corresponding internal subscriber with the lifetime of the
-        listener.
-        
-        :param topic:     Topic
-        :param eventMask: Bitmask of EventFlags values
-        :param listener:  Listener function
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, subscriber: Subscriber, eventMask: int, listener: typing.Callable[[Event], None]) -> int:
-        """
-        Add a listener for changes on a subscriber. The callback
-        function is called asynchronously on a separate thread, so it's important
-        to use synchronization or atomics when accessing any shared state from the
-        callback function. This does NOT keep the subscriber active.
-        
-        :param subscriber: Subscriber
-        :param eventMask:  Bitmask of EventFlags values
-        :param listener:   Listener function
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, subscriber: MultiSubscriber, eventMask: int, listener: typing.Callable[[Event], None]) -> int:
-        """
-        Add a listener for changes on a subscriber. The callback
-        function is called asynchronously on a separate thread, so it's important
-        to use synchronization or atomics when accessing any shared state from the
-        callback function. This does NOT keep the subscriber active.
-        
-        :param subscriber: Subscriber
-        :param eventMask:  Bitmask of EventFlags values
-        :param listener:   Listener function
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, entry: NetworkTableEntry, eventMask: int, listener: typing.Callable[[Event], None]) -> int:
-        """
-        Add a listener for changes on an entry. The callback function
-        is called asynchronously on a separate thread, so it's important to use
-        synchronization or atomics when accessing any shared state from the
-        callback function.
-        
-        :param entry:     Entry
-        :param eventMask: Bitmask of EventFlags values
-        :param listener:  Listener function
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, prefixes: list[str], eventMask: int, listener: typing.Callable[[Event], None]) -> int:
-        """
-        Add a listener for changes to topics with names that start with any
-        of the given prefixes. The callback function is called asynchronously on a
-        separate thread, so it's important to use synchronization or atomics when
-        accessing any shared state from the callback function.
-        
-        This creates a corresponding internal subscriber with the lifetime of the
-        listener.
-        
-        :param prefixes:  Topic name string prefixes
-        :param eventMask: Bitmask of EventFlags values
-        :param listener:  Listener function
-        
-        :returns: Listener handle
-        """
-    def addLogger(self, minLevel: int, maxLevel: int, func: typing.Callable[[Event], None]) -> int:
-        """
-        Add logger callback function.  By default, log messages are sent to stderr;
-        this function sends log messages with the specified levels to the provided
-        callback function instead.  The callback function will only be called for
-        log messages with level greater than or equal to minLevel and less than or
-        equal to maxLevel; messages outside this range will be silently ignored.
-        
-        :param minLevel: minimum log level
-        :param maxLevel: maximum log level
-        :param func:     callback function
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addSchema(self, name: str, type: str, schema: typing_extensions.Buffer) -> None:
-        """
-        Registers a data schema.  Data schemas provide information for how a
-        certain data type string can be decoded.  The type string of a data schema
-        indicates the type of the schema itself (e.g. "protobuf" for protobuf
-        schemas, "struct" for struct schemas, etc). In NetworkTables, schemas are
-        published just like normal topics, with the name being generated from the
-        provided name: "/.schema/<name>".  Duplicate calls to this function with
-        the same name are silently ignored.
-        
-        :param name:   Name (the string passed as the data type for topics using this
-                       schema)
-        :param type:   Type of schema (e.g. "protobuf", "struct", etc)
-        :param schema: Schema data
-        """
-    @typing.overload
-    def addSchema(self, name: str, type: str, schema: str) -> None:
-        """
-        Registers a data schema.  Data schemas provide information for how a
-        certain data type string can be decoded.  The type string of a data schema
-        indicates the type of the schema itself (e.g. "protobuf" for protobuf
-        schemas, "struct" for struct schemas, etc). In NetworkTables, schemas are
-        published just like normal topics, with the name being generated from the
-        provided name: "/.schema/<name>".  Duplicate calls to this function with
-        the same name are silently ignored.
-        
-        :param name:   Name (the string passed as the data type for topics using this
-                       schema)
-        :param type:   Type of schema (e.g. "protobuf", "struct", etc)
-        :param schema: Schema data
-        """
-    def addTimeSyncListener(self, immediate_notify: bool, callback: typing.Callable[[Event], None]) -> int:
-        """
-        Add a time synchronization listener. The callback function is called
-        asynchronously on a separate thread, so it's important to use
-        synchronization or atomics when accessing any shared state from the
-        callback function.
-        
-        :param immediate_notify: notify listener of current time synchronization
-                                 value
-        :param callback:         listener to add
-        
-        :returns: Listener handle
-        """
-    def configPythonLogging(self, *, min: NetworkTableInstance.LogLevel = ..., max: NetworkTableInstance.LogLevel = ..., name: str = 'nt') -> None:
-        """
-        Configure python logging for this instance.
-        
-        :param min:  Minimum NT level to log
-        :param max:  Maximum NT level to log
-        :param name: Name of python logger
-        
-        .. note:: This must be called before the instance is started
-        """
-    def disconnect(self) -> None:
-        """
-        Disconnects the client if it's running and connected. This will
-        automatically start reconnection attempts to the current server list.
-        """
-    def flush(self) -> None:
-        """
-        Flushes all updated values immediately to the network.
-        .. note:: This is rate-limited to protect the network from flooding.
-           This is primarily useful for synchronizing network updates with
-           user code.
-        """
-    def flushLocal(self) -> None:
-        """
-        Flushes all updated values immediately to the local client/server. This
-        does not flush to the network.
-        """
-    def getBooleanArrayTopic(self, name: str) -> BooleanArrayTopic:
-        """
-        Gets a boolean array topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getBooleanTopic(self, name: str) -> BooleanTopic:
-        """
-        Gets a boolean topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getConnections(self) -> list[ConnectionInfo]:
-        """
-        Get information on the currently established network connections.
-        If operating as a client, this will return either zero or one values.
-        
-        :returns: array of connection information
-        """
-    def getDoubleArrayTopic(self, name: str) -> DoubleArrayTopic:
-        """
-        Gets a double array topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getDoubleTopic(self, name: str) -> DoubleTopic:
-        """
-        Gets a double topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getEntry(self, name: str) -> NetworkTableEntry:
-        """
-        Gets the entry for a key.
-        
-        :param name: Key
-        
-        :returns: Network table entry.
-        """
-    def getFloatArrayTopic(self, name: str) -> FloatArrayTopic:
-        """
-        Gets a float array topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getFloatTopic(self, name: str) -> FloatTopic:
-        """
-        Gets a float topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getIntegerArrayTopic(self, name: str) -> IntegerArrayTopic:
-        """
-        Gets an integer array topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getIntegerTopic(self, name: str) -> IntegerTopic:
-        """
-        Gets an integer topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getNetworkMode(self) -> int:
-        """
-        Get the current network mode.
-        
-        :returns: Bitmask of NetworkMode.
-        """
-    def getRawTopic(self, name: str) -> RawTopic:
-        """
-        Gets a raw topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getServerTimeOffset(self) -> int | None:
-        """
-        Get the time offset between server time and local time. Add this value to
-        local time to get the estimated equivalent server time. In server mode,
-        this always returns 0. In client mode, this returns the time offset only if
-        the client and server are connected and have exchanged synchronization
-        messages. Note the time offset may change over time as it is periodically
-        updated; to receive updates as events, add a listener to the "time sync"
-        event.
-        
-        :returns: Time offset in microseconds (optional)
-        """
-    def getStringArrayTopic(self, name: str) -> StringArrayTopic:
-        """
-        Gets a string array topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getStringTopic(self, name: str) -> StringTopic:
-        """
-        Gets a string topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    def getStructArrayTopic(self, name: str, type: type) -> StructArrayTopic:
-        """
-        Gets a raw struct serialized array topic.
-        
-        :param name: topic name
-        :param type: optional struct type info
-        
-        :returns: Topic
-        """
-    def getStructTopic(self, name: str, type: type) -> StructTopic:
-        """
-        Gets a raw struct serialized value topic.
-        
-        :param name: topic name
-        :param type: optional struct type info
-        
-        :returns: Topic
-        """
-    def getTable(self, key: str) -> NetworkTable:
-        """
-        Gets the table with the specified key.
-        
-        :param key: the key name
-        
-        :returns: The network table
-        """
-    def getTopic(self, name: str) -> Topic:
-        """
-        Gets a "generic" (untyped) topic.
-        
-        :param name: topic name
-        
-        :returns: Topic
-        """
-    @typing.overload
-    def getTopicInfo(self) -> list[TopicInfo]:
-        """
-        Get Topic Information about multiple topics.
-        
-        Returns an array of topic information (handle, name, type, and properties).
-        
-        :returns: Array of topic information.
-        """
-    @typing.overload
-    def getTopicInfo(self, prefix: str) -> list[TopicInfo]:
-        """
-        Get Topic Information about multiple topics.
-        
-        Returns an array of topic information (handle, name, type, and properties).
-        The results are filtered by string prefix to only
-        return a subset of all topics.
-        
-        :param prefix: name required prefix; only topics whose name
-                       starts with this string are returned
-        
-        :returns: Array of topic information.
-        """
-    @typing.overload
-    def getTopicInfo(self, prefix: str, types: int) -> list[TopicInfo]:
-        """
-        Get Topic Information about multiple topics.
-        
-        Returns an array of topic information (handle, name, type, and properties).
-        The results are filtered by string prefix and type to only
-        return a subset of all topics.
-        
-        :param prefix: name required prefix; only topics whose name
-                       starts with this string are returned
-        :param types:  bitmask of NT_Type values; 0 is treated specially
-                       as a "don't care"
-        
-        :returns: Array of topic information.
-        """
-    @typing.overload
-    def getTopicInfo(self, prefix: str, types: list[str]) -> list[TopicInfo]:
-        """
-        Get Topic Information about multiple topics.
-        
-        Returns an array of topic information (handle, name, type, and properties).
-        The results are filtered by string prefix and type to only
-        return a subset of all topics.
-        
-        :param prefix: name required prefix; only topics whose name
-                       starts with this string are returned
-        :param types:  array of type strings
-        
-        :returns: Array of topic information.
-        """
-    @typing.overload
-    def getTopics(self) -> list[Topic]:
-        """
-        Get Published Topics.
-        
-        Returns an array of topics.
-        
-        :returns: Array of topics.
-        """
-    @typing.overload
-    def getTopics(self, prefix: str) -> list[Topic]:
-        """
-        Get Published Topics.
-        
-        Returns an array of topics.  The results are filtered by
-        string prefix to only return a subset of all topics.
-        
-        :param prefix: name required prefix; only topics whose name
-                       starts with this string are returned
-        
-        :returns: Array of topics.
-        """
-    @typing.overload
-    def getTopics(self, prefix: str, types: int) -> list[Topic]:
-        """
-        Get Published Topics.
-        
-        Returns an array of topics.  The results are filtered by
-        string prefix and type to only return a subset of all topics.
-        
-        :param prefix: name required prefix; only topics whose name
-                       starts with this string are returned
-        :param types:  bitmask of NT_Type values; 0 is treated specially
-                       as a "don't care"
-        
-        :returns: Array of topics.
-        """
-    @typing.overload
-    def getTopics(self, prefix: str, types: list[str]) -> list[Topic]:
-        """
-        Get Published Topics.
-        
-        Returns an array of topics.  The results are filtered by
-        string prefix and type to only return a subset of all topics.
-        
-        :param prefix: name required prefix; only topics whose name
-                       starts with this string are returned
-        :param types:  array of type strings
-        
-        :returns: Array of topic handles.
-        """
-    def hasSchema(self, name: str) -> bool:
-        """
-        Returns whether there is a data schema already registered with the given
-        name. This does NOT perform a check as to whether the schema has already
-        been published by another node on the network.
-        
-        :param name: Name (the string passed as the data type for topics using this
-                     schema)
-        
-        :returns: True if schema already registered
-        """
-    def isConnected(self) -> bool:
-        """
-        Return whether or not the instance is connected to another node.
-        
-        :returns: True if connected.
-        """
-    @typing.overload
-    def setServer(self, server_name: str, port: int = 0) -> None:
-        """
-        Sets server address and port for client (without restarting client).
-        
-        :param server_name: server name (UTF-8 string, null terminated)
-        :param port:        port to communicate over (0 = default)
-        """
-    @typing.overload
-    def setServer(self, servers: list[tuple[str, int]]) -> None:
-        """
-        Sets server addresses and ports for client (without restarting client).
-        The client will attempt to connect to each server in round robin fashion.
-        
-        :param servers: array of server address and port pairs
-        """
-    @typing.overload
-    def setServer(self, servers: list[str], port: int = 0) -> None:
-        """
-        Sets server addresses and port for client (without restarting client).
-        The client will attempt to connect to each server in round robin fashion.
-        
-        :param servers: array of server names
-        :param port:    port to communicate over (0 = default)
-        """
-    def setServerTeam(self, team: int, port: int = 0) -> None:
-        """
-        Sets server addresses and port for client (without restarting client).
-        Connects using commonly known robot addresses for the specified team.
-        
-        :param team: team number
-        :param port: port to communicate over (0 = default)
-        """
-    def startClient3(self, identity: str) -> None:
-        """
-        Starts a NT3 client.  Use SetServer or SetServerTeam to set the server name
-        and port.
-        
-        :param identity: network identity to advertise (cannot be empty string)
-        """
-    def startClient4(self, identity: str) -> None:
-        """
-        Starts a NT4 client.  Use SetServer or SetServerTeam to set the server name
-        and port.
-        
-        :param identity: network identity to advertise (cannot be empty string)
-        """
-    def startConnectionDataLog(self, log: wpiutil._wpiutil.log.DataLog, name: str) -> int:
-        """
-        Starts logging connection changes to a DataLog.
-        
-        :param log:  data log object; lifetime must extend until
-                     StopConnectionDataLog is called or the instance is destroyed
-        :param name: data log entry name
-        
-        :returns: Data logger handle
-        """
-    def startDSClient(self, port: int = 0) -> None:
-        """
-        Starts requesting server address from Driver Station.
-        This connects to the Driver Station running on localhost to obtain the
-        server IP address.
-        
-        :param port: server port to use in combination with IP from DS (0 = default)
-        """
-    def startEntryDataLog(self, log: wpiutil._wpiutil.log.DataLog, prefix: str, logPrefix: str) -> int:
-        """
-        Starts logging entry changes to a DataLog.
-        
-        :param log:       data log object; lifetime must extend until StopEntryDataLog is
-                          called or the instance is destroyed
-        :param prefix:    only store entries with names that start with this prefix;
-                          the prefix is not included in the data log entry name
-        :param logPrefix: prefix to add to data log entry names
-        
-        :returns: Data logger handle
-        """
-    def startLocal(self) -> None:
-        """
-        Starts local-only operation.  Prevents calls to StartServer or StartClient
-        from taking effect.  Has no effect if StartServer or StartClient
-        has already been called.
-        """
-    def startServer(self, persist_filename: str = 'networktables.json', listen_address: str = '', port3: int = 1735, port4: int = 5810) -> None:
-        """
-        Starts a server using the specified filename, listening address, and port.
-        
-        :param persist_filename: the name of the persist file to use (UTF-8 string,
-                                 null terminated)
-        :param listen_address:   the address to listen on, or null to listen on any
-                                 address (UTF-8 string, null terminated)
-        :param port3:            port to communicate over (NT3)
-        :param port4:            port to communicate over (NT4)
-        """
-    def stopClient(self) -> None:
-        """
-        Stops the client if it is running.
-        """
-    def stopDSClient(self) -> None:
-        """
-        Stops requesting server address from Driver Station.
-        """
-    def stopLocal(self) -> None:
-        """
-        Stops local-only operation.  StartServer or StartClient can be called after
-        this call to start a server or client.
-        """
-    def stopServer(self) -> None:
-        """
-        Stops the server if it is running.
-        """
-    def waitForListenerQueue(self, timeout: float) -> bool:
-        """
-        Wait for the listener queue to be empty. This is primarily
-        useful for deterministic testing. This blocks until either the
-        listener queue is empty (e.g. there are no more events that need to be
-        passed along to callbacks or poll queues) or the timeout expires.
-        
-        :param timeout: timeout, in seconds. Set to 0 for non-blocking behavior, or
-                        a negative value to block indefinitely
-        
-        :returns: False if timed out, otherwise true.
-        """
-class NetworkTableListener:
-    """
-    Event listener. This calls back to a callback function when an event
-    matching the specified mask occurs. The callback function is called
-    asynchronously on a separate thread, so it's important to use synchronization
-    or atomics when accessing any shared state from the callback function.
-    """
-    @staticmethod
-    def createConnectionListener(inst: NetworkTableInstance, immediate_notify: bool, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
-        """
-        Create a connection listener.
-        
-        :param inst:             instance
-        :param immediate_notify: notify listener of all existing connections
-        :param listener:         listener function
-        
-        :returns: Listener
-        """
-    @staticmethod
-    @typing.overload
-    def createListener(inst: NetworkTableInstance, prefixes: list[str], mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
-        """
-        Create a listener for changes to topics with names that start with any of
-        the given prefixes. This creates a corresponding internal subscriber with
-        the lifetime of the listener.
-        
-        :param inst:     Instance
-        :param prefixes: Topic name string prefixes
-        :param mask:     Bitmask of EventFlags values
-        :param listener: Listener function
-        
-        :returns: Listener
-        """
-    @staticmethod
-    @typing.overload
-    def createListener(topic: Topic, mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
-        """
-        Create a listener for changes on a particular topic. This creates a
-        corresponding internal subscriber with the lifetime of the listener.
-        
-        :param topic:    Topic
-        :param mask:     Bitmask of EventFlags values
-        :param listener: Listener function
-        
-        :returns: Listener
-        """
-    @staticmethod
-    @typing.overload
-    def createListener(subscriber: Subscriber, mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
-        """
-        Create a listener for topic changes on a subscriber. This does NOT keep the
-        subscriber active.
-        
-        :param subscriber: Subscriber
-        :param mask:       Bitmask of EventFlags values
-        :param listener:   Listener function
-        
-        :returns: Listener
-        """
-    @staticmethod
-    @typing.overload
-    def createListener(subscriber: MultiSubscriber, mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
-        """
-        Create a listener for topic changes on a subscriber. This does NOT keep the
-        subscriber active.
-        
-        :param subscriber: Subscriber
-        :param mask:       Bitmask of EventFlags values
-        :param listener:   Listener function
-        
-        :returns: Listener
-        """
-    @staticmethod
-    @typing.overload
-    def createListener(entry: NetworkTableEntry, mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
-        """
-        Create a listener for topic changes on an entry.
-        
-        :param entry:    Entry
-        :param mask:     Bitmask of EventFlags values
-        :param listener: Listener function
-        
-        :returns: Listener
-        """
-    @staticmethod
-    def createLogger(inst: NetworkTableInstance, minLevel: int, maxLevel: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
-        """
-        Create a listener for log messages.  By default, log messages are sent to
-        stderr; this function sends log messages with the specified levels to the
-        provided callback function instead.  The callback function will only be
-        called for log messages with level greater than or equal to minLevel and
-        less than or equal to maxLevel; messages outside this range will be
-        silently ignored.
-        
-        :param inst:     instance
-        :param minLevel: minimum log level
-        :param maxLevel: maximum log level
-        :param listener: listener function
-        
-        :returns: Listener
-        """
-    @staticmethod
-    def createTimeSyncListener(inst: NetworkTableInstance, immediate_notify: bool, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
-        """
-        Create a time synchronization listener.
-        
-        :param inst:             instance
-        :param immediate_notify: notify listener of current time synchronization
-                                 value
-        :param listener:         listener function
-        
-        :returns: Listener
-        """
-    def __enter__(self) -> NetworkTableListener:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the listener
-        """
-    def getHandle(self) -> int:
-        """
-        Gets the native handle.
-        
-        :returns: Handle
-        """
-    def waitForQueue(self, timeout: float) -> bool:
-        """
-        Wait for the listener queue to be empty. This is primarily useful for
-        deterministic testing. This blocks until either the listener queue is
-        empty (e.g. there are no more events that need to be passed along to
-        callbacks or poll queues) or the timeout expires.
-        
-        :param timeout: timeout, in seconds. Set to 0 for non-blocking behavior, or
-                        a negative value to block indefinitely
-        
-        :returns: False if timed out, otherwise true.
-        """
-class NetworkTableListenerPoller:
-    """
-    Event polled listener. This queues events matching the specified mask. Code
-    using the listener must periodically call ReadQueue() to read the
-    events.
-    """
-    def __enter__(self) -> NetworkTableListenerPoller:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, inst: NetworkTableInstance) -> None:
-        """
-        Construct a listener poller.
-        
-        :param inst: Instance
-        """
-    def addConnectionListener(self, immediate_notify: bool) -> int:
-        """
-        Add a connection listener. The callback function is called asynchronously
-        on a separate thread, so it's important to use synchronization or atomics
-        when accessing any shared state from the callback function.
-        
-        :param immediate_notify: notify listener of all existing connections
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, prefixes: list[str], mask: int) -> int:
-        """
-        Start listening to topic changes for topics with names that start with any
-        of the given prefixes. This creates a corresponding internal subscriber
-        with the lifetime of the listener.
-        
-        :param prefixes: Topic name string prefixes
-        :param mask:     Bitmask of EventFlags values
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, topic: Topic, mask: int) -> int:
-        """
-        Start listening to changes to a particular topic. This creates a
-        corresponding internal subscriber with the lifetime of the listener.
-        
-        :param topic: Topic
-        :param mask:  Bitmask of EventFlags values
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, subscriber: Subscriber, mask: int) -> int:
-        """
-        Start listening to topic changes on a subscriber. This does NOT keep the
-        subscriber active.
-        
-        :param subscriber: Subscriber
-        :param mask:       Bitmask of EventFlags values
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, subscriber: MultiSubscriber, mask: int) -> int:
-        """
-        Start listening to topic changes on a subscriber. This does NOT keep the
-        subscriber active.
-        
-        :param subscriber: Subscriber
-        :param mask:       Bitmask of EventFlags values
-        
-        :returns: Listener handle
-        """
-    @typing.overload
-    def addListener(self, entry: NetworkTableEntry, mask: int) -> int:
-        """
-        Start listening to topic changes on an entry.
-        
-        :param entry: Entry
-        :param mask:  Bitmask of EventFlags values
-        
-        :returns: Listener handle
-        """
-    def addLogger(self, minLevel: int, maxLevel: int) -> int:
-        """
-        Add logger callback function.  By default, log messages are sent to stderr;
-        this function sends log messages with the specified levels to the provided
-        callback function instead.  The callback function will only be called for
-        log messages with level greater than or equal to minLevel and less than or
-        equal to maxLevel; messages outside this range will be silently ignored.
-        
-        :param minLevel: minimum log level
-        :param maxLevel: maximum log level
-        
-        :returns: Listener handle
-        """
-    def addTimeSyncListener(self, immediate_notify: bool) -> int:
-        """
-        Add a time synchronization listener. The callback function is called
-        asynchronously on a separate thread, so it's important to use
-        synchronization or atomics when accessing any shared state from the
-        callback function.
-        
-        :param immediate_notify: notify listener of current time synchronization
-                                 value
-        
-        :returns: Listener handle
-        """
-    def close(self) -> None:
-        """
-        Destroys the poller
-        """
-    def getHandle(self) -> int:
-        """
-        Gets the native handle.
-        
-        :returns: Handle
-        """
-    def readQueue(self) -> list[Event]:
-        """
-        Read events.
-        
-        :returns: Events since the previous call to ReadQueue()
-        """
-    def removeListener(self, listener: int) -> None:
-        """
-        Remove a listener.
-        
-        :param listener: Listener handle
-        """
-class NetworkTableType:
-    """
-    NetworkTable entry type.
-    @ingroup ntcore_cpp_api
-    
-    Members:
-    
-      kUnassigned : Unassigned data type.
-    
-      kBoolean : Boolean data type.
-    
-      kDouble : Double precision floating-point data type.
-    
-      kString : String data type.
-    
-      kRaw : Raw data type.
-    
-      kBooleanArray : Boolean array data type.
-    
-      kDoubleArray : Double precision floating-point array data type.
-    
-      kStringArray : String array data type.
-    
-      kInteger : Integer data type.
-    
-      kFloat : Single precision floating-point data type.
-    
-      kIntegerArray : Integer array data type.
-    
-      kFloatArray : Single precision floating-point array data type.
-    """
-    __members__: typing.ClassVar[dict[str, NetworkTableType]]  # value = {'kUnassigned': <NetworkTableType.kUnassigned: 0>, 'kBoolean': <NetworkTableType.kBoolean: 1>, 'kDouble': <NetworkTableType.kDouble: 2>, 'kString': <NetworkTableType.kString: 4>, 'kRaw': <NetworkTableType.kRaw: 8>, 'kBooleanArray': <NetworkTableType.kBooleanArray: 16>, 'kDoubleArray': <NetworkTableType.kDoubleArray: 32>, 'kStringArray': <NetworkTableType.kStringArray: 64>, 'kInteger': <NetworkTableType.kInteger: 256>, 'kFloat': <NetworkTableType.kFloat: 512>, 'kIntegerArray': <NetworkTableType.kIntegerArray: 1024>, 'kFloatArray': <NetworkTableType.kFloatArray: 2048>}
-    kBoolean: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kBoolean: 1>
-    kBooleanArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kBooleanArray: 16>
-    kDouble: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kDouble: 2>
-    kDoubleArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kDoubleArray: 32>
-    kFloat: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kFloat: 512>
-    kFloatArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kFloatArray: 2048>
-    kInteger: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kInteger: 256>
-    kIntegerArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kIntegerArray: 1024>
-    kRaw: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kRaw: 8>
-    kString: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kString: 4>
-    kStringArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kStringArray: 64>
-    kUnassigned: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kUnassigned: 0>
-    def __eq__(self, other: typing.Any) -> bool:
-        ...
-    def __getstate__(self) -> int:
-        ...
-    def __hash__(self) -> int:
-        ...
-    def __index__(self) -> int:
-        ...
-    def __init__(self, value: int) -> None:
-        ...
-    def __int__(self) -> int:
-        ...
-    def __ne__(self, other: typing.Any) -> bool:
-        ...
-    def __repr__(self) -> str:
-        ...
-    def __setstate__(self, state: int) -> None:
-        ...
-    def __str__(self) -> str:
-        ...
-    @property
-    def name(self) -> str:
-        ...
-    @property
-    def value(self) -> int:
-        ...
-class PubSubOptions:
-    """
-    NetworkTables publish/subscribe options.
-    """
-    kDefaultPeriodic: typing.ClassVar[float] = 0.1
-    def __init__(self, *, pollStorage: int = 0, periodic: float = 0.1, excludePublisher: Publisher | None = None, sendAll: bool = False, topicsOnly: bool = False, keepDuplicates: bool = False, prefixMatch: bool = False, disableRemote: bool = False, disableLocal: bool = False, excludeSelf: bool = False, hidden: bool = False) -> None:
-        """
-              :param pollStorage:      Polling storage size for a subscription. Specifies the maximum number of
-                                       updates NetworkTables should store between calls to the subscriber's
-                                       ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if
-                                       sendAll is true.
-              :param periodic:         How frequently changes will be sent over the network, in seconds.
-                                       NetworkTables may send more frequently than this (e.g. use a combined
-                                       minimum period for all values) or apply a restricted range to this value.
-                                       The default is 100 ms.
-              :param excludePublisher: For subscriptions, if non-zero, value updates for ReadQueue() are not
-                                       queued for this publisher.
-              :param sendAll:          Send all value changes over the network.
-              :param topicsOnly:       For subscriptions, don't ask for value changes (only topic announcements).
-              :param keepDuplicates:   Preserve duplicate value changes (rather than ignoring them).
-              :param prefixMatch:      Perform prefix match on subscriber topic names. Is ignored/overridden by
-                                       Subscribe() functions; only present in struct for the purposes of getting
-                                       information about subscriptions.
-              :param disableRemote:    For subscriptions, if remote value updates should not be queued for
-                                       ReadQueue(). See also disableLocal.
-              :param disableLocal:     For subscriptions, if local value updates should not be queued for
-                                       ReadQueue(). See also disableRemote.
-              :param excludeSelf:      For entries, don't queue (for ReadQueue) value updates for the entry's
-                                       internal publisher.
-              :param hidden:           For subscriptions, don't share the existence of the subscription with the
-                                       network. Note this means updates will not be received from the network
-                                       unless another subscription overlaps with this one, and the subscription
-                                       will not appear in metatopics.
-        """
-    @property
-    def disableLocal(self) -> bool:
-        """
-        For subscriptions, if local value updates should not be queued for
-        ReadQueue(). See also disableRemote.
-        """
-    @disableLocal.setter
-    def disableLocal(self, arg0: bool) -> None:
-        ...
-    @property
-    def disableRemote(self) -> bool:
-        """
-        For subscriptions, if remote value updates should not be queued for
-        ReadQueue(). See also disableLocal.
-        """
-    @disableRemote.setter
-    def disableRemote(self, arg0: bool) -> None:
-        ...
-    @property
-    def excludePublisher(self) -> int:
-        """
-        For subscriptions, if non-zero, value updates for ReadQueue() are not
-        queued for this publisher.
-        """
-    @excludePublisher.setter
-    def excludePublisher(self, arg0: int) -> None:
-        ...
-    @property
-    def excludeSelf(self) -> bool:
-        """
-        For entries, don't queue (for ReadQueue) value updates for the entry's
-        internal publisher.
-        """
-    @excludeSelf.setter
-    def excludeSelf(self, arg0: bool) -> None:
-        ...
-    @property
-    def hidden(self) -> bool:
-        """
-        For subscriptions, don't share the existence of the subscription with the
-        network. Note this means updates will not be received from the network
-        unless another subscription overlaps with this one, and the subscription
-        will not appear in metatopics.
-        """
-    @hidden.setter
-    def hidden(self, arg0: bool) -> None:
-        ...
-    @property
-    def keepDuplicates(self) -> bool:
-        """
-        Preserve duplicate value changes (rather than ignoring them).
-        """
-    @keepDuplicates.setter
-    def keepDuplicates(self, arg0: bool) -> None:
-        ...
-    @property
-    def periodic(self) -> float:
-        """
-        How frequently changes will be sent over the network, in seconds.
-        NetworkTables may send more frequently than this (e.g. use a combined
-        minimum period for all values) or apply a restricted range to this value.
-        The default is 100 ms.
-        """
-    @periodic.setter
-    def periodic(self, arg0: float) -> None:
-        ...
-    @property
-    def pollStorage(self) -> int:
-        """
-        Polling storage size for a subscription. Specifies the maximum number of
-        updates NetworkTables should store between calls to the subscriber's
-        ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if
-        sendAll is true.
-        """
-    @pollStorage.setter
-    def pollStorage(self, arg0: int) -> None:
-        ...
-    @property
-    def prefixMatch(self) -> bool:
-        """
-        Perform prefix match on subscriber topic names. Is ignored/overridden by
-        Subscribe() functions; only present in struct for the purposes of getting
-        information about subscriptions.
-        """
-    @prefixMatch.setter
-    def prefixMatch(self, arg0: bool) -> None:
-        ...
-    @property
-    def sendAll(self) -> bool:
-        """
-        Send all value changes over the network.
-        """
-    @sendAll.setter
-    def sendAll(self, arg0: bool) -> None:
-        ...
-    @property
-    def topicsOnly(self) -> bool:
-        """
-        For subscriptions, don't ask for value changes (only topic announcements).
-        """
-    @topicsOnly.setter
-    def topicsOnly(self, arg0: bool) -> None:
-        ...
-class Publisher:
-    """
-    NetworkTables publisher.
-    """
-    def getTopic(self) -> Topic:
-        """
-        Gets the published-to topic.
-        
-        :returns: Topic
-        """
-    @property
-    def _m_pubHandle(self) -> int:
-        """
-        NetworkTables handle.
-        """
-class RawEntry(RawSubscriber, RawPublisher):
-    """
-    NetworkTables Raw entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> RawEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> RawTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class RawPublisher(Publisher):
-    """
-    NetworkTables Raw publisher.
-    """
-    def __enter__(self) -> RawPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> RawTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: typing_extensions.Buffer, time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: typing_extensions.Buffer) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class RawSubscriber(Subscriber):
-    """
-    NetworkTables Raw subscriber.
-    """
-    def __enter__(self) -> RawSubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> bytes:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: typing_extensions.Buffer) -> bytes:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedRaw:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: typing_extensions.Buffer) -> TimestampedRaw:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> RawTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedRaw]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class RawTopic(Topic):
-    """
-    NetworkTables Raw topic.
-    """
-    def __enter__(self) -> RawTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, typeString: str, defaultValue: typing_extensions.Buffer, options: PubSubOptions = ...) -> RawEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, typeString: str, options: PubSubOptions = ...) -> RawPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> RawPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, typeString: str, defaultValue: typing_extensions.Buffer, options: PubSubOptions = ...) -> RawSubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class StringArrayEntry(StringArraySubscriber, StringArrayPublisher):
-    """
-    NetworkTables StringArray entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> StringArrayEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> StringArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class StringArrayPublisher(Publisher):
-    """
-    NetworkTables StringArray publisher.
-    """
-    def __enter__(self) -> StringArrayPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> StringArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: list[str], time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: list[str]) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class StringArraySubscriber(Subscriber):
-    """
-    NetworkTables StringArray subscriber.
-    """
-    def __enter__(self) -> StringArraySubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> list[str]:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: list[str]) -> list[str]:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedStringArray:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: list[str]) -> TimestampedStringArray:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> StringArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedStringArray]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class StringArrayTopic(Topic):
-    """
-    NetworkTables StringArray topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'string[]'
-    def __enter__(self) -> StringArrayTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: list[str], options: PubSubOptions = ...) -> StringArrayEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: list[str], options: PubSubOptions = ...) -> StringArrayEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> StringArrayPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> StringArrayPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: list[str], options: PubSubOptions = ...) -> StringArraySubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: list[str], options: PubSubOptions = ...) -> StringArraySubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class StringEntry(StringSubscriber, StringPublisher):
-    """
-    NetworkTables String entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> StringEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> StringTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class StringPublisher(Publisher):
-    """
-    NetworkTables String publisher.
-    """
-    def __enter__(self) -> StringPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> StringTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: str, time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: str) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class StringSubscriber(Subscriber):
-    """
-    NetworkTables String subscriber.
-    """
-    def __enter__(self) -> StringSubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> str:
-        """
-        Get the last published value.
-        If no value has been published, returns the stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: str) -> str:
-        """
-        Get the last published value.
-        If no value has been published, returns the passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedString:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published, returns the stored default value and a
-        timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: str) -> TimestampedString:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published, returns the passed defaultValue and a
-        timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> StringTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedString]:
-        """
-        Get an array of all value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no new changes have
-                  been published since the previous call.
-        """
-class StringTopic(Topic):
-    """
-    NetworkTables String topic.
-    """
-    kTypeString: typing.ClassVar[str] = 'string'
-    def __enter__(self) -> StringTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def __init__(self, topic: Topic) -> None:
-        """
-        Construct from a generic topic.
-        
-        :param topic: Topic
-        """
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: str, options: PubSubOptions = ...) -> StringEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getEntryEx(self, typeString: str, defaultValue: str, options: PubSubOptions = ...) -> StringEntry:
-        """
-        Create a new entry for the topic, with specific type string.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> StringPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> StringPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: str, options: PubSubOptions = ...) -> StringSubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-    def subscribeEx(self, typeString: str, defaultValue: str, options: PubSubOptions = ...) -> StringSubscriber:
-        """
-        Create a new subscriber to the topic, with specific type string.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString:   type string
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class StructArrayEntry(StructArraySubscriber, StructArrayPublisher):
-    """
-    NetworkTables struct-encoded value array entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> StructArrayEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> StructArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class StructArrayPublisher(Publisher):
-    """
-    NetworkTables struct-encoded value array publisher.
-    """
-    def __enter__(self) -> StructArrayPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> StructArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: list[typing.Any], time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: list[typing.Any]) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class StructArraySubscriber(Subscriber):
-    """
-    NetworkTables struct-encoded value array subscriber.
-    """
-    def __enter__(self) -> StructArraySubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> list[typing.Any]:
-        """
-        Get the last published value.
-        If no value has been published or the value cannot be unpacked, returns the
-        stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: list[typing.Any]) -> list[typing.Any]:
-        """
-        Get the last published value.
-        If no value has been published or the value cannot be unpacked, returns the
-        passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedStructArray:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published or the value cannot be unpacked, returns the
-        stored default value and a timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: list[typing.Any]) -> TimestampedStructArray:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published or the value cannot be unpacked, returns the
-        passed defaultValue and a timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> StructArrayTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedStructArray]:
-        """
-        Get an array of all valid value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value. Values that cannot be unpacked
-        are dropped.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no valid new changes
-                  have been published since the previous call.
-        """
-class StructArrayTopic(Topic):
-    """
-    NetworkTables struct-encoded value array topic.
-    """
-    def __enter__(self) -> StructArrayTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: list[typing.Any], options: PubSubOptions = ...) -> StructArrayEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> StructArrayPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, properties: wpiutil.json, options: PubSubOptions = ...) -> StructArrayPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: list[typing.Any], options: PubSubOptions = ...) -> StructArraySubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class StructEntry(StructSubscriber, StructPublisher):
-    """
-    NetworkTables struct-encoded value entry.
-    
-    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
-    """
-    def __enter__(self) -> StructEntry:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the entry
-        """
-    def getTopic(self) -> StructTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def unpublish(self) -> None:
-        """
-        Stops publishing the entry if it's published.
-        """
-class StructPublisher(Publisher):
-    """
-    NetworkTables struct-encoded value publisher.
-    """
-    def __enter__(self) -> StructPublisher:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the publisher
-        """
-    def getTopic(self) -> StructTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def set(self, value: typing.Any, time: int = 0) -> None:
-        """
-        Publish a new value.
-        
-        :param value: value to publish
-        :param time:  timestamp; 0 indicates current NT time should be used
-        """
-    def setDefault(self, value: typing.Any) -> None:
-        """
-        Publish a default value.
-        On reconnect, a default value will never be used in preference to a
-        published value.
-        
-        :param value: value
-        """
-class StructSubscriber(Subscriber):
-    """
-    NetworkTables struct-encoded value subscriber.
-    """
-    def __enter__(self) -> StructSubscriber:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the subscriber
-        """
-    @typing.overload
-    def get(self) -> typing.Any:
-        """
-        Get the last published value.
-        If no value has been published or the value cannot be unpacked, returns the
-        stored default value.
-        
-        :returns: value
-        """
-    @typing.overload
-    def get(self, defaultValue: typing.Any) -> typing.Any:
-        """
-        Get the last published value.
-        If no value has been published or the value cannot be unpacked, returns the
-        passed defaultValue.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: value
-        """
-    @typing.overload
-    def getAtomic(self) -> TimestampedStruct:
-        """
-        Get the last published value along with its timestamp
-        If no value has been published or the value cannot be unpacked, returns the
-        stored default value and a timestamp of 0.
-        
-        :returns: timestamped value
-        """
-    @typing.overload
-    def getAtomic(self, defaultValue: typing.Any) -> TimestampedStruct:
-        """
-        Get the last published value along with its timestamp.
-        If no value has been published or the value cannot be unpacked, returns the
-        passed defaultValue and a timestamp of 0.
-        
-        :param defaultValue: default value to return if no value has been published
-        
-        :returns: timestamped value
-        """
-    def getTopic(self) -> StructTopic:
-        """
-        Get the corresponding topic.
-        
-        :returns: Topic
-        """
-    def readQueue(self) -> list[TimestampedStruct]:
-        """
-        Get an array of all valid value changes since the last call to ReadQueue.
-        Also provides a timestamp for each value. Values that cannot be unpacked
-        are dropped.
-        
-        .. note:: The "poll storage" subscribe option can be used to set the queue
-           depth.
-        
-        :returns: Array of timestamped values; empty array if no valid new changes
-                  have been published since the previous call.
-        """
-class StructTopic(Topic):
-    """
-    NetworkTables struct-encoded value topic.
-    """
-    def __enter__(self) -> StructTopic:
-        ...
-    def __exit__(self, *args) -> None:
-        ...
-    def close(self) -> None:
-        """
-        Destroys the topic
-        """
-    def getEntry(self, defaultValue: typing.Any, options: PubSubOptions = ...) -> StructEntry:
-        """
-        Create a new entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def publish(self, options: PubSubOptions = ...) -> StructPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish options
-        
-        :returns: publisher
-        """
-    def publishEx(self, properties: wpiutil.json, options: PubSubOptions = ...) -> StructPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def subscribe(self, defaultValue: typing.Any, options: PubSubOptions = ...) -> StructSubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param defaultValue: default value used when a default is not provided to a
-                             getter function
-        :param options:      subscribe options
-        
-        :returns: subscriber
-        """
-class Subscriber:
-    """
-    NetworkTables subscriber.
-    """
-    def exists(self) -> bool:
-        """
-        Determines if the topic is currently being published.
-        
-        :returns: True if the topic exists, false otherwise.
-        """
-    def getLastChange(self) -> int:
-        """
-        Gets the last time the value was changed.
-        Note: this is not atomic with Get(); use GetAtomic() to get
-        both the value and last change as an atomic operation.
-        
-        :returns: Topic last change time
-        """
-    def getTopic(self) -> Topic:
-        """
-        Gets the subscribed-to topic.
-        
-        :returns: Topic
-        """
-    @property
-    def _m_subHandle(self) -> int:
-        ...
-class TimeSyncEventData:
-    """
-    NetworkTables time sync event data.
-    """
-    def __init__(self, serverTimeOffset: int, rtt2: int, valid: bool) -> None:
-        ...
-    @property
-    def rtt2(self) -> int:
-        """
-        Measured round trip time divided by 2, in microseconds.
-        """
-    @rtt2.setter
-    def rtt2(self, arg0: int) -> None:
-        ...
-    @property
-    def serverTimeOffset(self) -> int:
-        """
-        Offset between local time and server time, in microseconds. Add this value
-        to local time to get the estimated equivalent server time.
-        """
-    @serverTimeOffset.setter
-    def serverTimeOffset(self, arg0: int) -> None:
-        ...
-    @property
-    def valid(self) -> bool:
-        """
-        If serverTimeOffset and RTT are valid. An event with this set to false is
-        sent when the client disconnects.
-        """
-    @valid.setter
-    def valid(self, arg0: bool) -> None:
-        ...
-class TimestampedBoolean:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: bool) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> bool:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: bool) -> None:
-        ...
-class TimestampedBooleanArray:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: list[int]) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> list[int]:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: list[int]) -> None:
-        ...
-class TimestampedDouble:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: float) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> float:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: float) -> None:
-        ...
-class TimestampedDoubleArray:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: list[float]) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> list[float]:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: list[float]) -> None:
-        ...
-class TimestampedFloat:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: float) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> float:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: float) -> None:
-        ...
-class TimestampedFloatArray:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: list[float]) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> list[float]:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: list[float]) -> None:
-        ...
-class TimestampedInteger:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: int) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> int:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: int) -> None:
-        ...
-class TimestampedIntegerArray:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: list[int]) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> list[int]:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: list[int]) -> None:
-        ...
-class TimestampedRaw:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: bytes) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> bytes:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: bytes) -> None:
-        ...
-class TimestampedString:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: str) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> str:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: str) -> None:
-        ...
-class TimestampedStringArray:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: list[str]) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> list[str]:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: list[str]) -> None:
-        ...
-class TimestampedStruct:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: typing.Any) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> typing.Any:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: typing.Any) -> None:
-        ...
-class TimestampedStructArray:
-    """
-    Timestamped value.
-    @ingroup ntcore_cpp_handle_api
-    """
-    @typing.overload
-    def __init__(self) -> None:
-        ...
-    @typing.overload
-    def __init__(self, time: int, serverTime: int, value: list[typing.Any]) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    @property
-    def serverTime(self) -> int:
-        """
-        Time in server time base.  May be 0 or 1 for locally set values.
-        """
-    @serverTime.setter
-    def serverTime(self, arg0: int) -> None:
-        ...
-    @property
-    def time(self) -> int:
-        """
-        Time in local time base.
-        """
-    @time.setter
-    def time(self, arg0: int) -> None:
-        ...
-    @property
-    def value(self) -> list[typing.Any]:
-        """
-        Value.
-        """
-    @value.setter
-    def value(self, arg0: list[typing.Any]) -> None:
-        ...
-class Topic:
-    """
-    NetworkTables Topic.
-    """
-    __hash__: typing.ClassVar[None] = None
-    def __eq__(self, arg0: Topic) -> bool:
-        """
-        Equality operator.  Returns true if both instances refer to the same
-        native handle.
-        """
-    def deleteProperty(self, name: str) -> None:
-        """
-        Deletes a property.  Has no effect if the property does not exist.
-        
-        :param name: property name
-        """
-    def exists(self) -> bool:
-        """
-        Determines if the topic is currently being published.
-        
-        :returns: True if the topic exists, false otherwise.
-        """
-    def genericPublish(self, typeString: str, options: PubSubOptions = ...) -> GenericPublisher:
-        """
-        Create a new publisher to the topic.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    def genericPublishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> GenericPublisher:
-        """
-        Create a new publisher to the topic, with type string and initial
-        properties.
-        
-        The publisher is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: It is not possible to publish two different data types to the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored). To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param properties: JSON properties
-        :param options:    publish options
-        
-        :returns: publisher
-        """
-    @typing.overload
-    def genericSubscribe(self, options: PubSubOptions = ...) -> GenericSubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        :param options: subscribe options
-        
-        :returns: subscriber
-        """
-    @typing.overload
-    def genericSubscribe(self, typeString: str, options: PubSubOptions = ...) -> GenericSubscriber:
-        """
-        Create a new subscriber to the topic.
-        
-        The subscriber is only active as long as the returned object
-        is not destroyed.
-        
-        .. note:: Subscribers that do not match the published data type do not return
-           any values. To determine if the data type matches, use the appropriate
-           Topic functions.
-        
-        :param typeString: type string
-        :param options:    subscribe options
-        
-        :returns: subscriber
-        """
-    @typing.overload
-    def getGenericEntry(self, options: PubSubOptions = ...) -> GenericEntry:
-        """
-        Create a new generic entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param options: publish and/or subscribe options
-        
-        :returns: entry
-        """
-    @typing.overload
-    def getGenericEntry(self, typeString: str, options: PubSubOptions = ...) -> GenericEntry:
-        """
-        Create a new generic entry for the topic.
-        
-        Entries act as a combination of a subscriber and a weak publisher. The
-        subscriber is active as long as the entry is not destroyed. The publisher
-        is created when the entry is first written to, and remains active until
-        either Unpublish() is called or the entry is destroyed.
-        
-        .. note:: It is not possible to use two different data types with the same
-           topic. Conflicts between publishers are typically resolved by the
-           server on a first-come, first-served basis. Any published values that
-           do not match the topic's data type are dropped (ignored), and the entry
-           will show no new values if the data type does not match. To determine
-           if the data type matches, use the appropriate Topic functions.
-        
-        :param typeString: type string
-        :param options:    publish and/or subscribe options
-        
-        :returns: entry
-        """
-    def getInfo(self) -> TopicInfo:
-        """
-        Gets combined information about the topic.
-        
-        :returns: Topic information
-        """
-    def getInstance(self) -> NetworkTableInstance:
-        """
-        Gets the instance for the topic.
-        
-        :returns: Instance
-        """
-    def getName(self) -> str:
-        """
-        Gets the name of the topic.
-        
-        :returns: the topic's name
-        """
-    def getProperties(self) -> wpiutil.json:
-        """
-        Gets all topic properties as a JSON object.  Each key in the object
-        is the property name, and the corresponding value is the property value.
-        
-        :returns: JSON object
-        """
-    def getProperty(self, name: str) -> wpiutil.json:
-        """
-        Gets the current value of a property (as a JSON object).
-        
-        :param name: property name
-        
-        :returns: JSON object; null object if the property does not exist.
-        """
-    def getType(self) -> NetworkTableType:
-        """
-        Gets the type of the topic.
-        
-        :returns: the topic's type
-        """
-    def getTypeString(self) -> str:
-        """
-        Gets the type string of the topic. This may have more information
-        than the numeric type (especially for raw values).
-        
-        :returns: the topic's type
-        """
-    def isCached(self) -> bool:
-        """
-        Returns whether the topic's last value is stored.
-        
-        :returns: True if the topic is cached.
-        """
-    def isPersistent(self) -> bool:
-        """
-        Returns whether the value is persistent through server restarts.
-        
-        :returns: True if the value is persistent.
-        """
-    def isRetained(self) -> bool:
-        """
-        Returns whether the topic is retained by server when there are no
-        publishers.
-        
-        :returns: True if the topic is retained.
-        """
-    def setCached(self, cached: bool) -> None:
-        """
-        Allow storage of the topic's last value, allowing the value to be read (and
-        not just accessed through event queues and listeners).
-        
-        :param cached: True for cached, false for not cached.
-        """
-    def setPersistent(self, persistent: bool) -> None:
-        """
-        Make value persistent through server restarts.
-        
-        :param persistent: True for persistent, false for not persistent.
-        """
-    def setProperties(self, properties: wpiutil.json) -> bool:
-        """
-        Updates multiple topic properties.  Each key in the passed-in object is
-        the name of the property to add/update, and the corresponding value is the
-        property value to set for that property.  Null values result in deletion
-        of the corresponding property.
-        
-        :param properties: JSON object with keys to add/update/delete
-        
-        :returns: False if properties is not an object
-        """
-    def setProperty(self, name: str, value: wpiutil.json) -> None:
-        """
-        Sets a property value.
-        
-        :param name:  property name
-        :param value: property value
-        """
-    def setRetained(self, retained: bool) -> None:
-        """
-        Make the server retain the topic even when there are no publishers.
-        
-        :param retained: True for retained, false for not retained.
-        """
-class TopicInfo:
-    """
-    NetworkTables Topic Information
-    """
-    def __init__(self) -> None:
-        ...
-    def __repr__(self) -> str:
-        ...
-    def getProperties(self) -> wpiutil.json:
-        """
-        Get topic properties as a JSON object.
-        """
-    @property
-    def name(self) -> str:
-        """
-        Topic name
-        """
-    @name.setter
-    def name(self, arg0: str) -> None:
-        ...
-    @property
-    def properties(self) -> str:
-        """
-        Topic properties JSON string
-        """
-    @properties.setter
-    def properties(self, arg0: str) -> None:
-        ...
-    @property
-    def topic(self) -> Topic:
-        ...
-    @property
-    def type(self) -> NetworkTableType:
-        ...
-    @property
-    def type_str(self) -> str:
-        """
-        Topic type string
-        """
-    @type_str.setter
-    def type_str(self, arg0: str) -> None:
-        ...
-class Value:
-    """
-    A network table entry value.
-    @ingroup ntcore_cpp_api
-    """
-    @staticmethod
-    def getFactoryByType(type: NetworkTableType) -> typing.Callable:
-        ...
-    @staticmethod
-    def makeBoolean(value: bool, time: int = 0) -> Value:
-        """
-        Creates a boolean entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-        """
-    @staticmethod
-    def makeBooleanArray(value: list[bool], time: int = 0) -> Value:
-        """
-        Creates a boolean array entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-        """
-    @staticmethod
-    def makeDouble(value: float, time: int = 0) -> Value:
-        """
-        Creates a double entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-        """
-    @staticmethod
-    def makeDoubleArray(value: list[float], time: int = 0) -> Value:
-        """
-        Creates a double array entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-                  
-                  .. note:: This function moves the values out of the vector.
-        """
-    @staticmethod
-    def makeFloat(value: float, time: int = 0) -> Value:
-        """
-        Creates a float entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-        """
-    @staticmethod
-    def makeFloatArray(value: list[float], time: int = 0) -> Value:
-        """
-        Creates a float array entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-                  
-                  .. note:: This function moves the values out of the vector.
-        """
-    @staticmethod
-    def makeInteger(value: int, time: int = 0) -> Value:
-        """
-        Creates an integer entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-        """
-    @staticmethod
-    def makeIntegerArray(value: list[int], time: int = 0) -> Value:
-        """
-        Creates an integer array entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-                  
-                  .. note:: This function moves the values out of the vector.
-        """
-    @staticmethod
-    def makeRaw(value: typing_extensions.Buffer, time: int = 0) -> Value:
-        """
-        Creates a raw entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-        """
-    @staticmethod
-    def makeString(value: str, time: int = 0) -> Value:
-        """
-        Creates a string entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-        """
-    @staticmethod
-    def makeStringArray(value: list[str], time: int = 0) -> Value:
-        """
-        Creates a string array entry value.
-        
-        :param value: the value
-        :param time:  if nonzero, the creation time to use (instead of the current
-                      time)
-        
-        :returns: The entry value
-                  
-                  .. note:: This function moves the values out of the vector.
-        """
-    @staticmethod
-    def makeValue(value: typing.Any) -> Value:
-        ...
-    def __repr__(self) -> str:
-        ...
-    def getBoolean(self) -> bool:
-        """
-        Get the entry's boolean value.
-        
-        :returns: The boolean value.
-        """
-    def getBooleanArray(self) -> typing.Any:
-        """
-        Get the entry's boolean array value.
-        
-        :returns: The boolean array value.
-        """
-    def getDouble(self) -> float:
-        """
-        Get the entry's double value.
-        
-        :returns: The double value.
-        """
-    def getDoubleArray(self) -> list[float]:
-        """
-        Get the entry's double array value.
-        
-        :returns: The double array value.
-        """
-    def getFloat(self) -> float:
-        """
-        Get the entry's float value.
-        
-        :returns: The float value.
-        """
-    def getFloatArray(self) -> list[float]:
-        """
-        Get the entry's float array value.
-        
-        :returns: The float array value.
-        """
-    def getInteger(self) -> int:
-        """
-        Get the entry's integer value.
-        
-        :returns: The integer value.
-        """
-    def getIntegerArray(self) -> list[int]:
-        """
-        Get the entry's integer array value.
-        
-        :returns: The integer array value.
-        """
-    def getRaw(self) -> typing_extensions.Buffer:
-        """
-        Get the entry's raw value.
-        
-        :returns: The raw value.
-        """
-    def getString(self) -> str:
-        """
-        Get the entry's string value.
-        
-        :returns: The string value.
-        """
-    def getStringArray(self) -> list[str]:
-        """
-        Get the entry's string array value.
-        
-        :returns: The string array value.
-        """
-    def isBoolean(self) -> bool:
-        """
-        Determine if entry value contains a boolean.
-        
-        :returns: True if the entry value is of boolean type.
-        """
-    def isBooleanArray(self) -> bool:
-        """
-        Determine if entry value contains a boolean array.
-        
-        :returns: True if the entry value is of boolean array type.
-        """
-    def isDouble(self) -> bool:
-        """
-        Determine if entry value contains a double.
-        
-        :returns: True if the entry value is of double type.
-        """
-    def isDoubleArray(self) -> bool:
-        """
-        Determine if entry value contains a double array.
-        
-        :returns: True if the entry value is of double array type.
-        """
-    def isFloat(self) -> bool:
-        """
-        Determine if entry value contains a float.
-        
-        :returns: True if the entry value is of float type.
-        """
-    def isFloatArray(self) -> bool:
-        """
-        Determine if entry value contains a float array.
-        
-        :returns: True if the entry value is of float array type.
-        """
-    def isInteger(self) -> bool:
-        """
-        Determine if entry value contains an integer.
-        
-        :returns: True if the entry value is of integer type.
-        """
-    def isIntegerArray(self) -> bool:
-        """
-        Determine if entry value contains an integer array.
-        
-        :returns: True if the entry value is of integer array type.
-        """
-    def isRaw(self) -> bool:
-        """
-        Determine if entry value contains a raw.
-        
-        :returns: True if the entry value is of raw type.
-        """
-    def isString(self) -> bool:
-        """
-        Determine if entry value contains a string.
-        
-        :returns: True if the entry value is of string type.
-        """
-    def isStringArray(self) -> bool:
-        """
-        Determine if entry value contains a string array.
-        
-        :returns: True if the entry value is of string array type.
-        """
-    def isValid(self) -> bool:
-        """
-        Determine if entry value contains a value or is unassigned.
-        
-        :returns: True if the entry value contains a value.
-        """
-    def last_change(self) -> int:
-        """
-        Get the creation time of the value, in local time.
-        
-        :returns: The time, in the units returned by nt::Now().
-        """
-    def server_time(self) -> int:
-        """
-        Get the creation time of the value, in server time.
-        
-        :returns: The server time.
-        """
-    def setServerTime(self, time: int) -> None:
-        """
-        Set the creation time of the value, in server time.
-        
-        :param time: The server time.
-        """
-    def setTime(self, time: int) -> None:
-        """
-        Set the local creation time of the value.
-        
-        :param time: The time.
-        """
-    def size(self) -> int:
-        """
-        Get the approximate in-memory size of the value in bytes. This is zero for
-        values that do not require additional memory beyond the memory of the Value
-        itself.
-        
-        :returns: The size in bytes.
-        """
-    def time(self) -> int:
-        """
-        Get the creation time of the value, in local time.
-        
-        :returns: The time, in the units returned by nt::Now().
-        """
-    def type(self) -> NetworkTableType:
-        """
-        Get the data type.
-        
-        :returns: The type.
-        """
-    def value(self) -> typing.Any:
-        """
-        Get the data value stored.
-        
-        :returns: The type.
-        """
-class ValueEventData:
-    """
-    NetworkTables Value Event Data
-    """
-    def __repr__(self) -> str:
-        ...
-    @property
-    def topic(self) -> Topic:
-        ...
-    @property
-    def value(self) -> Value:
-        """
-        The new value.
-        """
-def _addPolledLogger(poller: int, min_level: int, max_level: int) -> int:
-    """
-    Set the log level for a log poller.  Events will only be generated for
-    log messages with level greater than or equal to min_level and less than or
-    equal to max_level; messages outside this range will be silently ignored.
-    
-    :param poller:    poller handle
-    :param min_level: minimum log level
-    :param max_level: maximum log level
-    
-    :returns: Logger handle
-    """
-def _now() -> int:
-    """
-    Returns monotonic current time in 1 us increments.
-    This is the same time base used for value and connection timestamps.
-    This function by default simply wraps wpi::Now(), but if SetNow() is
-    called, this function instead returns the value passed to SetNow();
-    this can be used to reduce overhead.
-    
-    :returns: Timestamp
-    """
-def _removeListener(listener: int) -> None:
-    """
-    Removes a listener.
-    
-    :param listener: Listener handle to remove
-    """
-def _setNow(timestamp: int) -> None:
-    """
-    Sets the current timestamp used for timestamping values that do not
-    provide a timestamp (e.g. a value of 0 is passed).  For consistency,
-    it also results in Now() returning the set value.  This should generally
-    be used only if the overhead of calling wpi::Now() is a concern.
-    If used, it should be called periodically with the value of wpi::Now().
-    
-    :param timestamp: timestamp (1 us increments)
-    """
-_st_cleanup: typing.Any  # value = <capsule object>
+from __future__ import annotations
+import typing
+import typing_extensions
+import wpiutil
+import wpiutil._wpiutil
+import wpiutil._wpiutil.log
+from . import meta
+__all__ = ['BooleanArrayEntry', 'BooleanArrayPublisher', 'BooleanArraySubscriber', 'BooleanArrayTopic', 'BooleanEntry', 'BooleanPublisher', 'BooleanSubscriber', 'BooleanTopic', 'ConnectionInfo', 'DoubleArrayEntry', 'DoubleArrayPublisher', 'DoubleArraySubscriber', 'DoubleArrayTopic', 'DoubleEntry', 'DoublePublisher', 'DoubleSubscriber', 'DoubleTopic', 'Event', 'EventFlags', 'FloatArrayEntry', 'FloatArrayPublisher', 'FloatArraySubscriber', 'FloatArrayTopic', 'FloatEntry', 'FloatPublisher', 'FloatSubscriber', 'FloatTopic', 'GenericEntry', 'GenericPublisher', 'GenericSubscriber', 'IntegerArrayEntry', 'IntegerArrayPublisher', 'IntegerArraySubscriber', 'IntegerArrayTopic', 'IntegerEntry', 'IntegerPublisher', 'IntegerSubscriber', 'IntegerTopic', 'LogMessage', 'MultiSubscriber', 'NTSendable', 'NTSendableBuilder', 'NetworkTable', 'NetworkTableEntry', 'NetworkTableInstance', 'NetworkTableListener', 'NetworkTableListenerPoller', 'NetworkTableType', 'PubSubOptions', 'Publisher', 'RawEntry', 'RawPublisher', 'RawSubscriber', 'RawTopic', 'StringArrayEntry', 'StringArrayPublisher', 'StringArraySubscriber', 'StringArrayTopic', 'StringEntry', 'StringPublisher', 'StringSubscriber', 'StringTopic', 'StructArrayEntry', 'StructArrayPublisher', 'StructArraySubscriber', 'StructArrayTopic', 'StructEntry', 'StructPublisher', 'StructSubscriber', 'StructTopic', 'Subscriber', 'TimeSyncEventData', 'TimestampedBoolean', 'TimestampedBooleanArray', 'TimestampedDouble', 'TimestampedDoubleArray', 'TimestampedFloat', 'TimestampedFloatArray', 'TimestampedInteger', 'TimestampedIntegerArray', 'TimestampedRaw', 'TimestampedString', 'TimestampedStringArray', 'TimestampedStruct', 'TimestampedStructArray', 'Topic', 'TopicInfo', 'Value', 'ValueEventData', 'meta']
+class BooleanArrayEntry(BooleanArraySubscriber, BooleanArrayPublisher):
+    """
+    NetworkTables BooleanArray entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> BooleanArrayEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> BooleanArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class BooleanArrayPublisher(Publisher):
+    """
+    NetworkTables BooleanArray publisher.
+    """
+    def __enter__(self) -> BooleanArrayPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> BooleanArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: list[int], time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: list[int]) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class BooleanArraySubscriber(Subscriber):
+    """
+    NetworkTables BooleanArray subscriber.
+    """
+    def __enter__(self) -> BooleanArraySubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> list[int]:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: list[int]) -> list[int]:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedBooleanArray:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: list[int]) -> TimestampedBooleanArray:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> BooleanArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedBooleanArray]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class BooleanArrayTopic(Topic):
+    """
+    NetworkTables BooleanArray topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'boolean[]'
+    def __enter__(self) -> BooleanArrayTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: list[int], options: PubSubOptions = ...) -> BooleanArrayEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: list[int], options: PubSubOptions = ...) -> BooleanArrayEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> BooleanArrayPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> BooleanArrayPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: list[int], options: PubSubOptions = ...) -> BooleanArraySubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: list[int], options: PubSubOptions = ...) -> BooleanArraySubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class BooleanEntry(BooleanSubscriber, BooleanPublisher):
+    """
+    NetworkTables Boolean entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> BooleanEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> BooleanTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class BooleanPublisher(Publisher):
+    """
+    NetworkTables Boolean publisher.
+    """
+    def __enter__(self) -> BooleanPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> BooleanTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: bool, time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: bool) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class BooleanSubscriber(Subscriber):
+    """
+    NetworkTables Boolean subscriber.
+    """
+    def __enter__(self) -> BooleanSubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> bool:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: bool) -> bool:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedBoolean:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: bool) -> TimestampedBoolean:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> BooleanTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedBoolean]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class BooleanTopic(Topic):
+    """
+    NetworkTables Boolean topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'boolean'
+    def __enter__(self) -> BooleanTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: bool, options: PubSubOptions = ...) -> BooleanEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: bool, options: PubSubOptions = ...) -> BooleanEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> BooleanPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> BooleanPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: bool, options: PubSubOptions = ...) -> BooleanSubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: bool, options: PubSubOptions = ...) -> BooleanSubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class ConnectionInfo:
+    """
+    NetworkTables Connection Information
+    """
+    def __init__(self) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def last_update(self) -> int:
+        """
+        The last time any update was received from the remote node (same scale as
+        returned by nt::Now()).
+        """
+    @last_update.setter
+    def last_update(self, arg0: int) -> None:
+        ...
+    @property
+    def protocol_version(self) -> int:
+        """
+        The protocol version being used for this connection.  This in protocol
+        layer format, so 0x0200 = 2.0, 0x0300 = 3.0).
+        """
+    @protocol_version.setter
+    def protocol_version(self, arg0: int) -> None:
+        ...
+    @property
+    def remote_id(self) -> str:
+        """
+        The remote identifier (as set on the remote node by
+        NetworkTableInstance::StartClient4() or nt::StartClient4()).
+        """
+    @remote_id.setter
+    def remote_id(self, arg0: str) -> None:
+        ...
+    @property
+    def remote_ip(self) -> str:
+        """
+        The IP address of the remote node.
+        """
+    @remote_ip.setter
+    def remote_ip(self, arg0: str) -> None:
+        ...
+    @property
+    def remote_port(self) -> int:
+        """
+        The port number of the remote node.
+        """
+    @remote_port.setter
+    def remote_port(self, arg0: int) -> None:
+        ...
+class DoubleArrayEntry(DoubleArraySubscriber, DoubleArrayPublisher):
+    """
+    NetworkTables DoubleArray entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> DoubleArrayEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> DoubleArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class DoubleArrayPublisher(Publisher):
+    """
+    NetworkTables DoubleArray publisher.
+    """
+    def __enter__(self) -> DoubleArrayPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> DoubleArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: list[float], time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: list[float]) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class DoubleArraySubscriber(Subscriber):
+    """
+    NetworkTables DoubleArray subscriber.
+    """
+    def __enter__(self) -> DoubleArraySubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> list[float]:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: list[float]) -> list[float]:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedDoubleArray:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: list[float]) -> TimestampedDoubleArray:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> DoubleArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedDoubleArray]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class DoubleArrayTopic(Topic):
+    """
+    NetworkTables DoubleArray topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'double[]'
+    def __enter__(self) -> DoubleArrayTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: list[float], options: PubSubOptions = ...) -> DoubleArrayEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: list[float], options: PubSubOptions = ...) -> DoubleArrayEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> DoubleArrayPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> DoubleArrayPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: list[float], options: PubSubOptions = ...) -> DoubleArraySubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: list[float], options: PubSubOptions = ...) -> DoubleArraySubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class DoubleEntry(DoubleSubscriber, DoublePublisher):
+    """
+    NetworkTables Double entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> DoubleEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> DoubleTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class DoublePublisher(Publisher):
+    """
+    NetworkTables Double publisher.
+    """
+    def __enter__(self) -> DoublePublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> DoubleTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: float, time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: float) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class DoubleSubscriber(Subscriber):
+    """
+    NetworkTables Double subscriber.
+    """
+    def __enter__(self) -> DoubleSubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> float:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: float) -> float:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedDouble:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: float) -> TimestampedDouble:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> DoubleTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedDouble]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class DoubleTopic(Topic):
+    """
+    NetworkTables Double topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'double'
+    def __enter__(self) -> DoubleTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: float, options: PubSubOptions = ...) -> DoubleEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: float, options: PubSubOptions = ...) -> DoubleEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> DoublePublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> DoublePublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: float, options: PubSubOptions = ...) -> DoubleSubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: float, options: PubSubOptions = ...) -> DoubleSubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class Event:
+    """
+    NetworkTables event
+    """
+    def __repr__(self) -> str:
+        ...
+    def is_(self, kind: int) -> bool:
+        """
+        Test event flags.
+        
+        :param kind: event flag(s) to test
+        
+        :returns: True if flags matches kind
+        """
+    @property
+    def data(self) -> ConnectionInfo | TopicInfo | ValueEventData | LogMessage | TimeSyncEventData:
+        ...
+    @property
+    def flags(self) -> int:
+        """
+        Event flags (NT_EventFlags). Also indicates the data included with the
+        event:
+        - NT_EVENT_CONNECTED or NT_EVENT_DISCONNECTED: GetConnectionInfo()
+        - NT_EVENT_PUBLISH, NT_EVENT_UNPUBLISH, or NT_EVENT_PROPERTIES:
+        GetTopicInfo()
+        - NT_EVENT_VALUE, NT_EVENT_VALUE_LOCAL: GetValueData()
+        - NT_EVENT_LOGMESSAGE: GetLogMessage()
+        - NT_EVENT_TIMESYNC: GetTimeSyncEventData()
+        """
+    @flags.setter
+    def flags(self, arg0: int) -> None:
+        ...
+    @property
+    def listener(self) -> int:
+        """
+        Listener that triggered this event.
+        """
+class EventFlags:
+    """
+    Event notification flags.
+    
+    The flags are a bitmask and must be OR'ed together to indicate the
+    combination of events desired to be received.
+    """
+    kConnected: typing.ClassVar[int] = 2
+    kConnection: typing.ClassVar[int] = 6
+    kDisconnected: typing.ClassVar[int] = 4
+    kImmediate: typing.ClassVar[int] = 1
+    kLogMessage: typing.ClassVar[int] = 256
+    kNone: typing.ClassVar[int] = 0
+    kProperties: typing.ClassVar[int] = 32
+    kPublish: typing.ClassVar[int] = 8
+    kTimeSync: typing.ClassVar[int] = 512
+    kTopic: typing.ClassVar[int] = 56
+    kUnpublish: typing.ClassVar[int] = 16
+    kValueAll: typing.ClassVar[int] = 192
+    kValueLocal: typing.ClassVar[int] = 128
+    kValueRemote: typing.ClassVar[int] = 64
+class FloatArrayEntry(FloatArraySubscriber, FloatArrayPublisher):
+    """
+    NetworkTables FloatArray entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> FloatArrayEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> FloatArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class FloatArrayPublisher(Publisher):
+    """
+    NetworkTables FloatArray publisher.
+    """
+    def __enter__(self) -> FloatArrayPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> FloatArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: list[float], time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: list[float]) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class FloatArraySubscriber(Subscriber):
+    """
+    NetworkTables FloatArray subscriber.
+    """
+    def __enter__(self) -> FloatArraySubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> list[float]:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: list[float]) -> list[float]:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedFloatArray:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: list[float]) -> TimestampedFloatArray:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> FloatArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedFloatArray]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class FloatArrayTopic(Topic):
+    """
+    NetworkTables FloatArray topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'float[]'
+    def __enter__(self) -> FloatArrayTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: list[float], options: PubSubOptions = ...) -> FloatArrayEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: list[float], options: PubSubOptions = ...) -> FloatArrayEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> FloatArrayPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> FloatArrayPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: list[float], options: PubSubOptions = ...) -> FloatArraySubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: list[float], options: PubSubOptions = ...) -> FloatArraySubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class FloatEntry(FloatSubscriber, FloatPublisher):
+    """
+    NetworkTables Float entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> FloatEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> FloatTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class FloatPublisher(Publisher):
+    """
+    NetworkTables Float publisher.
+    """
+    def __enter__(self) -> FloatPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> FloatTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: float, time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: float) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class FloatSubscriber(Subscriber):
+    """
+    NetworkTables Float subscriber.
+    """
+    def __enter__(self) -> FloatSubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> float:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: float) -> float:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedFloat:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: float) -> TimestampedFloat:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> FloatTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedFloat]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class FloatTopic(Topic):
+    """
+    NetworkTables Float topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'float'
+    def __enter__(self) -> FloatTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: float, options: PubSubOptions = ...) -> FloatEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: float, options: PubSubOptions = ...) -> FloatEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> FloatPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> FloatPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: float, options: PubSubOptions = ...) -> FloatSubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: float, options: PubSubOptions = ...) -> FloatSubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class GenericEntry(GenericSubscriber, GenericPublisher):
+    """
+    NetworkTables generic entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> GenericEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> Topic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class GenericPublisher(Publisher):
+    """
+    NetworkTables generic publisher.
+    """
+    def getTopic(self) -> Topic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: Value) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        """
+    def setBoolean(self, value: bool, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    @typing.overload
+    def setBooleanArray(self, value: list[bool], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    @typing.overload
+    def setBooleanArray(self, value: list[int], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefault(self, value: Value) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+    def setDefaultBoolean(self, defaultValue: bool) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultBooleanArray(self, defaultValue: list[int]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultDouble(self, defaultValue: float) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultDoubleArray(self, defaultValue: list[float]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultFloat(self, defaultValue: float) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultFloatArray(self, defaultValue: list[float]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultInteger(self, defaultValue: int) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultIntegerArray(self, defaultValue: list[int]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultRaw(self, defaultValue: typing_extensions.Buffer) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultString(self, defaultValue: str) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultStringArray(self, defaultValue: list[str]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDouble(self, value: float, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDoubleArray(self, value: list[float], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setFloat(self, value: float, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setFloatArray(self, value: list[float], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setInteger(self, value: int, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setIntegerArray(self, value: list[int], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setRaw(self, value: typing_extensions.Buffer, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setString(self, value: str, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setStringArray(self, value: list[str], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+class GenericSubscriber(Subscriber):
+    """
+    NetworkTables generic subscriber.
+    """
+    def get(self) -> Value:
+        """
+        Get the last published value.
+        If no value has been published, returns a value with unassigned type.
+        
+        :returns: value
+        """
+    def getBoolean(self, defaultValue: bool) -> bool:
+        """
+        Gets the entry's value as a boolean. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getBooleanArray(self, defaultValue: list[int]) -> list[int]:
+        """
+        Gets the entry's value as a boolean array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+                  
+                  .. note:: The returned array is std::vector<int> instead of std::vector<bool>
+                     because std::vector<bool> is special-cased in C++.  0 is false, any
+                     non-zero value is true.
+        """
+    def getDouble(self, defaultValue: float) -> float:
+        """
+        Gets the entry's value as a double. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getDoubleArray(self, defaultValue: list[float]) -> list[float]:
+        """
+        Gets the entry's value as a double array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getFloat(self, defaultValue: float) -> float:
+        """
+        Gets the entry's value as a float. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getFloatArray(self, defaultValue: list[float]) -> list[float]:
+        """
+        Gets the entry's value as a float array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getInteger(self, defaultValue: int) -> int:
+        """
+        Gets the entry's value as a integer. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getIntegerArray(self, defaultValue: list[int]) -> list[int]:
+        """
+        Gets the entry's value as a integer array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getRaw(self, defaultValue: typing_extensions.Buffer) -> bytes:
+        """
+        Gets the entry's value as a raw. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getString(self, defaultValue: str) -> str:
+        """
+        Gets the entry's value as a string. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getStringArray(self, defaultValue: list[str]) -> list[str]:
+        """
+        Gets the entry's value as a string array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getTopic(self) -> Topic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[Value]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class IntegerArrayEntry(IntegerArraySubscriber, IntegerArrayPublisher):
+    """
+    NetworkTables IntegerArray entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> IntegerArrayEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> IntegerArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class IntegerArrayPublisher(Publisher):
+    """
+    NetworkTables IntegerArray publisher.
+    """
+    def __enter__(self) -> IntegerArrayPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> IntegerArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: list[int], time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: list[int]) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class IntegerArraySubscriber(Subscriber):
+    """
+    NetworkTables IntegerArray subscriber.
+    """
+    def __enter__(self) -> IntegerArraySubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> list[int]:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: list[int]) -> list[int]:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedIntegerArray:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: list[int]) -> TimestampedIntegerArray:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> IntegerArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedIntegerArray]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class IntegerArrayTopic(Topic):
+    """
+    NetworkTables IntegerArray topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'int[]'
+    def __enter__(self) -> IntegerArrayTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: list[int], options: PubSubOptions = ...) -> IntegerArrayEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: list[int], options: PubSubOptions = ...) -> IntegerArrayEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> IntegerArrayPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> IntegerArrayPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: list[int], options: PubSubOptions = ...) -> IntegerArraySubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: list[int], options: PubSubOptions = ...) -> IntegerArraySubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class IntegerEntry(IntegerSubscriber, IntegerPublisher):
+    """
+    NetworkTables Integer entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> IntegerEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> IntegerTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class IntegerPublisher(Publisher):
+    """
+    NetworkTables Integer publisher.
+    """
+    def __enter__(self) -> IntegerPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> IntegerTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: int, time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: int) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class IntegerSubscriber(Subscriber):
+    """
+    NetworkTables Integer subscriber.
+    """
+    def __enter__(self) -> IntegerSubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> int:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: int) -> int:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedInteger:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: int) -> TimestampedInteger:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> IntegerTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedInteger]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class IntegerTopic(Topic):
+    """
+    NetworkTables Integer topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'int'
+    def __enter__(self) -> IntegerTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: int, options: PubSubOptions = ...) -> IntegerEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: int, options: PubSubOptions = ...) -> IntegerEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> IntegerPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> IntegerPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: int, options: PubSubOptions = ...) -> IntegerSubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: int, options: PubSubOptions = ...) -> IntegerSubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class LogMessage:
+    """
+    NetworkTables log message.
+    """
+    @property
+    def filename(self) -> str:
+        """
+        The filename of the source file that generated the message.
+        """
+    @property
+    def level(self) -> int:
+        """
+        Log level of the message.  See NT_LogLevel.
+        """
+    @level.setter
+    def level(self, arg0: int) -> None:
+        ...
+    @property
+    def line(self) -> int:
+        """
+        The line number in the source file that generated the message.
+        """
+    @line.setter
+    def line(self, arg0: int) -> None:
+        ...
+    @property
+    def message(self) -> str:
+        """
+        The message.
+        """
+class MultiSubscriber:
+    """
+    Subscribe to multiple topics based on one or more topic name prefixes. Can be
+    used in combination with ValueListenerPoller to listen for value changes
+    across all matching topics.
+    """
+    def __enter__(self) -> MultiSubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, inst: NetworkTableInstance, prefixes: list[str], options: PubSubOptions = ...) -> None:
+        """
+        Create a multiple subscriber.
+        
+        :param inst:     instance
+        :param prefixes: topic name prefixes
+        :param options:  subscriber options
+        """
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+class NTSendable(wpiutil._wpiutil.Sendable):
+    """
+    Interface for NetworkTable Sendable objects.
+    """
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def initSendable(self, builder: NTSendableBuilder) -> None:
+        """
+        Initializes this Sendable object.
+        
+        :param builder: sendable builder
+        """
+    @typing.overload
+    def initSendable(self, builder: wpiutil._wpiutil.SendableBuilder) -> None:
+        ...
+class NTSendableBuilder(wpiutil._wpiutil.SendableBuilder):
+    """
+    Helper class for building Sendable dashboard representations for
+    NetworkTables.
+    """
+    def __init__(self) -> None:
+        ...
+    def getBackendKind(self) -> wpiutil._wpiutil.SendableBuilder.BackendKind:
+        """
+        Gets the kind of backend being used.
+        
+        :returns: Backend kind
+        """
+    def getTable(self) -> NetworkTable:
+        """
+        Get the network table.
+        
+        :returns: The network table
+        """
+    def getTopic(self, key: str) -> Topic:
+        """
+        Add a property without getters or setters.  This can be used to get
+        entry handles for the function called by SetUpdateTable().
+        
+        :param key: property name
+        
+        :returns: Network table topic
+        """
+    def setUpdateTable(self, func: typing.Callable[[], None]) -> None:
+        """
+        Set the function that should be called to update the network table
+        for things other than properties.  Note this function is not passed
+        the network table object; instead it should use the entry handles
+        returned by GetEntry().
+        
+        :param func: function
+        """
+class NetworkTable:
+    """
+    A network table that knows its subtable path.
+    @ingroup ntcore_cpp_api
+    """
+    PATH_SEPARATOR_CHAR: typing.ClassVar[str] = '/'
+    @staticmethod
+    def basenameKey(key: str) -> str:
+        """
+        Gets the "base name" of a key. For example, "/foo/bar" becomes "bar".
+        If the key has a trailing slash, returns an empty string.
+        
+        :param key: key
+        
+        :returns: base name
+        """
+    @staticmethod
+    def getHierarchy(key: str) -> list[str]:
+        """
+        Gets a list of the names of all the super tables of a given key. For
+        example, the key "/foo/bar/baz" has a hierarchy of "/", "/foo",
+        "/foo/bar", and "/foo/bar/baz".
+        
+        :param key: the key
+        
+        :returns: List of super tables
+        """
+    @staticmethod
+    def normalizeKey(key: str, withLeadingSlash: bool = True) -> str:
+        """
+        Normalizes an network table key to contain no consecutive slashes and
+        optionally start with a leading slash. For example:
+        
+        <pre><code>
+        normalizeKey("/foo/bar", true)  == "/foo/bar"
+        normalizeKey("foo/bar", true)   == "/foo/bar"
+        normalizeKey("/foo/bar", false) == "foo/bar"
+        normalizeKey("foo//bar", false) == "foo/bar"
+        </code></pre>
+        
+        :param key:              the key to normalize
+        :param withLeadingSlash: whether or not the normalized key should begin
+                                 with a leading slash
+        
+        :returns: normalized key
+        """
+    def __contains__(self, arg0: str) -> bool:
+        ...
+    @typing.overload
+    def addListener(self, eventMask: int, listener: typing.Callable[[NetworkTable, str, Event], None]) -> int:
+        """
+        Listen to topics only within this table.
+        
+        :param eventMask: Bitmask of EventFlags values
+        :param listener:  listener to add
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, key: str, eventMask: int, listener: typing.Callable[[NetworkTable, str, Event], None]) -> int:
+        """
+        Listen to a single key.
+        
+        :param key:       the key name
+        :param eventMask: Bitmask of EventFlags values
+        :param listener:  listener to add
+        
+        :returns: Listener handle
+        """
+    def addSubTableListener(self, listener: typing.Callable[[NetworkTable, str, NetworkTable], None]) -> int:
+        """
+        Listen for sub-table creation. This calls the listener once for each newly
+        created sub-table. It immediately calls the listener for any existing
+        sub-tables.
+        
+        :param listener: listener to add
+        
+        :returns: Listener handle
+        """
+    def clearPersistent(self, key: str) -> None:
+        """
+        Stop making a key's value persistent through program restarts.
+        The key cannot be null.
+        
+        :param key: the key name
+        """
+    def containsKey(self, key: str) -> bool:
+        """
+        Determines whether the given key is in this table.
+        
+        :param key: the key to search for
+        
+        :returns: true if the table as a value assigned to the given key
+        """
+    def containsSubTable(self, key: str) -> bool:
+        """
+        Determines whether there exists a non-empty subtable for this key
+        in this table.
+        
+        :param key: the key to search for
+        
+        :returns: true if there is a subtable with the key which contains at least
+                  one key/subtable of its own
+        """
+    def getBoolean(self, key: str, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the boolean associated with the given name. If the key does not
+        exist or is of different type, it will return the default value.
+        
+        :param key:          the key to look up
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the value associated with the given key or the given default value
+                  if there is no value associated with the key
+        """
+    def getBooleanArray(self, key: str, defaultValue: typing.Any) -> typing.Any:
+        """
+        Returns the boolean array the key maps to. If the key does not exist or is
+        of different type, it will return the default value.
+        
+        :param key:          the key to look up
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the value associated with the given key or the given default value
+                  if there is no value associated with the key
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+                  
+                  .. note:: The returned array is std::vector<int> instead of std::vector<bool>
+                     because std::vector<bool> is special-cased in C++.  0 is false, any
+                     non-zero value is true.
+        """
+    def getBooleanArrayTopic(self, name: str) -> BooleanArrayTopic:
+        """
+        Get boolean[] topic.
+        
+        :param name: topic name
+        
+        :returns: BooleanArrayTopic
+        """
+    def getBooleanTopic(self, name: str) -> BooleanTopic:
+        """
+        Get boolean topic.
+        
+        :param name: topic name
+        
+        :returns: BooleanTopic
+        """
+    def getDoubleArrayTopic(self, name: str) -> DoubleArrayTopic:
+        """
+        Get double[] topic.
+        
+        :param name: topic name
+        
+        :returns: DoubleArrayTopic
+        """
+    def getDoubleTopic(self, name: str) -> DoubleTopic:
+        """
+        Get double topic.
+        
+        :param name: topic name
+        
+        :returns: DoubleTopic
+        """
+    def getEntry(self, key: str) -> NetworkTableEntry:
+        """
+        Gets the entry for a subkey.
+        
+        :param key: the key name
+        
+        :returns: Network table entry.
+        """
+    def getFloatArrayTopic(self, name: str) -> FloatArrayTopic:
+        """
+        Get float[] topic.
+        
+        :param name: topic name
+        
+        :returns: FloatArrayTopic
+        """
+    def getFloatTopic(self, name: str) -> FloatTopic:
+        """
+        Get float topic.
+        
+        :param name: topic name
+        
+        :returns: FloatTopic
+        """
+    def getInstance(self) -> NetworkTableInstance:
+        """
+        Gets the instance for the table.
+        
+        :returns: Instance
+        """
+    def getIntegerArrayTopic(self, name: str) -> IntegerArrayTopic:
+        """
+        Get integer[] topic.
+        
+        :param name: topic name
+        
+        :returns: IntegerArrayTopic
+        """
+    def getIntegerTopic(self, name: str) -> IntegerTopic:
+        """
+        Get integer topic.
+        
+        :param name: topic name
+        
+        :returns: IntegerTopic
+        """
+    def getKeys(self, types: int = 0) -> list[str]:
+        """
+        Gets all keys in the table (not including sub-tables).
+        
+        :param types: bitmask of types; 0 is treated as a "don't care".
+        
+        :returns: keys currently in the table
+        """
+    def getNumber(self, key: str, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the number associated with the given name.
+        
+        :param key:          the key to look up
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the value associated with the given key or the given default value
+                  if there is no value associated with the key
+        """
+    def getNumberArray(self, key: str, defaultValue: typing.Any) -> typing.Any:
+        """
+        Returns the number array the key maps to. If the key does not exist or is
+        of different type, it will return the default value.
+        
+        :param key:          the key to look up
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the value associated with the given key or the given default value
+                  if there is no value associated with the key
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getPath(self) -> str:
+        """
+        Gets the full path of this table.  Does not include the trailing "/".
+        
+        :returns: The path (e.g "", "/foo").
+        """
+    def getRaw(self, key: str, defaultValue: typing.Any) -> typing.Any:
+        """
+        Returns the raw value (byte array) the key maps to. If the key does not
+        exist or is of different type, it will return the default value.
+        
+        :param key:          the key to look up
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the value associated with the given key or the given default value
+                  if there is no value associated with the key
+                  
+                  .. note:: This makes a copy of the raw contents.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getRawTopic(self, name: str) -> RawTopic:
+        """
+        Get raw topic.
+        
+        :param name: topic name
+        
+        :returns: BooleanArrayTopic
+        """
+    def getString(self, key: str, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the string associated with the given name. If the key does not
+        exist or is of different type, it will return the default value.
+        
+        :param key:          the key to look up
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the value associated with the given key or the given default value
+                  if there is no value associated with the key
+        """
+    def getStringArray(self, key: str, defaultValue: typing.Any) -> typing.Any:
+        """
+        Returns the string array the key maps to. If the key does not exist or is
+        of different type, it will return the default value.
+        
+        :param key:          the key to look up
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the value associated with the given key or the given default value
+                  if there is no value associated with the key
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getStringArrayTopic(self, name: str) -> StringArrayTopic:
+        """
+        Get String[] topic.
+        
+        :param name: topic name
+        
+        :returns: StringArrayTopic
+        """
+    def getStringTopic(self, name: str) -> StringTopic:
+        """
+        Get String topic.
+        
+        :param name: topic name
+        
+        :returns: StringTopic
+        """
+    def getStructArrayTopic(self, name: str, type: type) -> StructArrayTopic:
+        """
+        Gets a raw struct serialized array topic.
+        
+        :param name: topic name
+        :param type: optional struct type info
+        
+        :returns: Topic
+        """
+    def getStructTopic(self, name: str, type: type) -> StructTopic:
+        """
+        Gets a raw struct serialized value topic.
+        
+        :param name: topic name
+        :param type: optional struct type info
+        
+        :returns: Topic
+        """
+    def getSubTable(self, key: str) -> NetworkTable:
+        """
+        Returns the table at the specified key. If there is no table at the
+        specified key, it will create a new table
+        
+        :param key: the key name
+        
+        :returns: the networktable to be returned
+        """
+    def getSubTables(self) -> list[str]:
+        """
+        Gets the names of all subtables in the table.
+        
+        :returns: subtables currently in the table
+        """
+    def getTopic(self, name: str) -> Topic:
+        """
+        Get (generic) topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getTopicInfo(self, types: int = 0) -> list[TopicInfo]:
+        """
+        Gets topic information for all keys in the table (not including
+        sub-tables).
+        
+        :param types: bitmask of types; 0 is treated as a "don't care".
+        
+        :returns: topic information for keys currently in the table
+        """
+    def getTopics(self, types: int = 0) -> list[Topic]:
+        """
+        Gets all topics in the table (not including sub-tables).
+        
+        :param types: bitmask of types; 0 is treated as a "don't care".
+        
+        :returns: topic for keys currently in the table
+        """
+    def getValue(self, key: str, value: typing.Any) -> typing.Any:
+        ...
+    def isPersistent(self, key: str) -> bool:
+        """
+        Returns whether the value is persistent through program restarts.
+        The key cannot be null.
+        
+        :param key: the key name
+        """
+    def putBoolean(self, key: str, value: bool) -> bool:
+        """
+        Put a boolean in the table
+        
+        :param key:   the key to be assigned to
+        :param value: the value that will be assigned
+        
+        :returns: False if the table key already exists with a different type
+        """
+    def putBooleanArray(self, key: str, value: list[int]) -> bool:
+        """
+        Put a boolean array in the table
+        
+        :param key:   the key to be assigned to
+        :param value: the value that will be assigned
+        
+        :returns: False if the table key already exists with a different type
+                  
+                  .. note:: The array must be of int's rather than of bool's because
+                     std::vector<bool> is special-cased in C++.  0 is false, any
+                     non-zero value is true.
+        """
+    def putNumber(self, key: str, value: float) -> bool:
+        """
+        Put a number in the table
+        
+        :param key:   the key to be assigned to
+        :param value: the value that will be assigned
+        
+        :returns: False if the table key already exists with a different type
+        """
+    def putNumberArray(self, key: str, value: list[float]) -> bool:
+        """
+        Put a number array in the table
+        
+        :param key:   the key to be assigned to
+        :param value: the value that will be assigned
+        
+        :returns: False if the table key already exists with a different type
+        """
+    def putRaw(self, key: str, value: typing_extensions.Buffer) -> bool:
+        """
+        Put a raw value (byte array) in the table
+        
+        :param key:   the key to be assigned to
+        :param value: the value that will be assigned
+        
+        :returns: False if the table key already exists with a different type
+        """
+    def putString(self, key: str, value: str) -> bool:
+        """
+        Put a string in the table
+        
+        :param key:   the key to be assigned to
+        :param value: the value that will be assigned
+        
+        :returns: False if the table key already exists with a different type
+        """
+    def putStringArray(self, key: str, value: list[str]) -> bool:
+        """
+        Put a string array in the table
+        
+        :param key:   the key to be assigned to
+        :param value: the value that will be assigned
+        
+        :returns: False if the table key already exists with a different type
+        """
+    @typing.overload
+    def putValue(self, key: str, value: float) -> bool:
+        ...
+    @typing.overload
+    def putValue(self, key: str, value: bool) -> bool:
+        ...
+    @typing.overload
+    def putValue(self, key: str, value: bytes) -> bool:
+        ...
+    @typing.overload
+    def putValue(self, key: str, value: str) -> bool:
+        ...
+    @typing.overload
+    def putValue(self, key: str, value: typing.Sequence) -> bool:
+        ...
+    def removeListener(self, listener: int) -> None:
+        """
+        Remove a listener.
+        
+        :param listener: listener handle
+        """
+    def setDefaultBoolean(self, key: str, defaultValue: bool) -> bool:
+        """
+        Gets the current value in the table, setting it if it does not exist.
+        
+        :param key:          the key
+        :param defaultValue: the default value to set if key doesn't exist.
+        
+        :returns: False if the table key exists with a different type
+        """
+    def setDefaultBooleanArray(self, key: str, defaultValue: list[int]) -> bool:
+        """
+        Gets the current value in the table, setting it if it does not exist.
+        
+        :param key:          the key
+        :param defaultValue: the default value to set if key doesn't exist.
+        
+        :returns: False if the table key exists with a different type
+        """
+    def setDefaultNumber(self, key: str, defaultValue: float) -> bool:
+        """
+        Gets the current value in the table, setting it if it does not exist.
+        
+        :param key:          the key
+        :param defaultValue: the default value to set if key doesn't exist.
+        
+        :returns: False if the table key exists with a different type
+        """
+    def setDefaultNumberArray(self, key: str, defaultValue: list[float]) -> bool:
+        """
+        Gets the current value in the table, setting it if it does not exist.
+        
+        :param key:          the key
+        :param defaultValue: the default value to set if key doesn't exist.
+        
+        :returns: False if the table key exists with a different type
+        """
+    def setDefaultRaw(self, key: str, defaultValue: typing_extensions.Buffer) -> bool:
+        """
+        Gets the current value in the table, setting it if it does not exist.
+        
+        :param key:          the key
+        :param defaultValue: the default value to set if key doesn't exist.
+        
+        :returns: False if the table key exists with a different type
+        """
+    def setDefaultString(self, key: str, defaultValue: str) -> bool:
+        """
+        Gets the current value in the table, setting it if it does not exist.
+        
+        :param key:          the key
+        :param defaultValue: the default value to set if key doesn't exist.
+        
+        :returns: False if the table key exists with a different type
+        """
+    def setDefaultStringArray(self, key: str, defaultValue: list[str]) -> bool:
+        """
+        Gets the current value in the table, setting it if it does not exist.
+        
+        :param key:          the key
+        :param defaultValue: the default value to set if key doesn't exist.
+        
+        :returns: False if the table key exists with a different type
+        """
+    @typing.overload
+    def setDefaultValue(self, key: str, value: float) -> bool:
+        ...
+    @typing.overload
+    def setDefaultValue(self, key: str, value: bool) -> bool:
+        ...
+    @typing.overload
+    def setDefaultValue(self, key: str, value: bytes) -> bool:
+        ...
+    @typing.overload
+    def setDefaultValue(self, key: str, value: str) -> bool:
+        ...
+    @typing.overload
+    def setDefaultValue(self, key: str, value: typing.Sequence) -> bool:
+        ...
+    def setPersistent(self, key: str) -> None:
+        """
+        Makes a key's value persistent through program restarts.
+        
+        :param key: the key to make persistent
+        """
+class NetworkTableEntry:
+    """
+    NetworkTables Entry
+    
+    .. note:: For backwards compatibility, the NetworkTableEntry destructor does not
+       release the entry.
+    
+    @ingroup ntcore_cpp_api
+    """
+    class Flags:
+        """
+        Flag values (as returned by GetFlags()).
+        
+        :deprecated: Use IsPersistent() instead.
+        
+        Members:
+        
+          kPersistent
+        """
+        __members__: typing.ClassVar[dict[str, NetworkTableEntry.Flags]]  # value = {'kPersistent': <Flags.kPersistent: 1>}
+        kPersistent: typing.ClassVar[NetworkTableEntry.Flags]  # value = <Flags.kPersistent: 1>
+        def __and__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __eq__(self, other: typing.Any) -> bool:
+            ...
+        def __ge__(self, other: typing.Any) -> bool:
+            ...
+        def __getstate__(self) -> int:
+            ...
+        def __gt__(self, other: typing.Any) -> bool:
+            ...
+        def __hash__(self) -> int:
+            ...
+        def __index__(self) -> int:
+            ...
+        def __init__(self, value: int) -> None:
+            ...
+        def __int__(self) -> int:
+            ...
+        def __invert__(self) -> typing.Any:
+            ...
+        def __le__(self, other: typing.Any) -> bool:
+            ...
+        def __lt__(self, other: typing.Any) -> bool:
+            ...
+        def __ne__(self, other: typing.Any) -> bool:
+            ...
+        def __or__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __rand__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __repr__(self) -> str:
+            ...
+        def __ror__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __rxor__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __setstate__(self, state: int) -> None:
+            ...
+        def __str__(self) -> str:
+            ...
+        def __xor__(self, other: typing.Any) -> typing.Any:
+            ...
+        @property
+        def name(self) -> str:
+            ...
+        @property
+        def value(self) -> int:
+            ...
+    __hash__: typing.ClassVar[None] = None
+    def __eq__(self, arg0: NetworkTableEntry) -> bool:
+        """
+        Equality operator.  Returns true if both instances refer to the same
+        native handle.
+        """
+    def clearFlags(self, flags: int) -> None:
+        """
+        Clears flags.
+        
+        :deprecated: Use SetPersistent() or topic properties instead
+        
+        :param flags: the flags to clear (bitmask)
+        """
+    def clearPersistent(self) -> None:
+        """
+        Stop making value persistent through program restarts.
+        """
+    def delete(self) -> None:
+        """
+        Deletes the entry.
+        
+        :deprecated: Use Unpublish() instead.
+        """
+    def exists(self) -> bool:
+        """
+        Determines if the entry currently exists.
+        
+        :returns: True if the entry exists, false otherwise.
+        """
+    def getBoolean(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a boolean. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getBooleanArray(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a boolean array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+                  
+                  .. note:: The returned array is std::vector<int> instead of std::vector<bool>
+                     because std::vector<bool> is special-cased in C++.  0 is false, any
+                     non-zero value is true.
+        """
+    def getDouble(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a double. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getDoubleArray(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a double array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getFlags(self) -> int:
+        """
+        Returns the flags.
+        
+        :deprecated: Use IsPersistent() or topic properties instead
+        
+        :returns: the flags (bitmask)
+        """
+    def getFloat(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a float. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getFloatArray(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a float array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getInstance(self) -> NetworkTableInstance:
+        """
+        Gets the instance for the entry.
+        
+        :returns: Instance
+        """
+    def getInteger(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a integer. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getIntegerArray(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a integer array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getLastChange(self) -> int:
+        """
+        Gets the last time the entry's value was changed.
+        
+        :returns: Entry last change time
+        """
+    def getName(self) -> str:
+        """
+        Gets the name of the entry (the key).
+        
+        :returns: the entry's name
+        """
+    def getRaw(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a raw. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getString(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a string. If the entry does not exist or is of
+        different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+        """
+    def getStringArray(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Gets the entry's value as a string array. If the entry does not exist
+        or is of different type, it will return the default value.
+        
+        :param defaultValue: the value to be returned if no value is found
+        
+        :returns: the entry's value or the given default value
+                  
+                  .. note:: This makes a copy of the array.  If the overhead of this is a
+                     concern, use GetValue() instead.
+        """
+    def getTopic(self) -> Topic:
+        """
+        Gets the entry's topic.
+        
+        :returns: Topic
+        """
+    def getType(self) -> NetworkTableType:
+        """
+        Gets the type of the entry.
+        
+        :returns: the entry's type
+        """
+    def getValue(self) -> Value:
+        """
+        Gets the entry's value. If the entry does not exist, returns an empty
+        value.
+        
+        :returns: the entry's value or an empty value if it does not exist.
+        """
+    def isPersistent(self) -> bool:
+        """
+        Returns whether the value is persistent through program restarts.
+        
+        :returns: True if the value is persistent.
+        """
+    def readQueue(self) -> list[Value]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        
+        The "poll storage" subscribe option can be used to set the queue depth.
+        
+        :returns: Array of values; empty array if no new changes have been
+                  published since the previous call.
+        """
+    def setBoolean(self, value: bool, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setBooleanArray(self, value: list[bool], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultBoolean(self, defaultValue: bool) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultBooleanArray(self, defaultValue: list[int]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultDouble(self, defaultValue: float) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultDoubleArray(self, defaultValue: list[float]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultFloat(self, defaultValue: float) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultFloatArray(self, defaultValue: list[float]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultInteger(self, defaultValue: int) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultIntegerArray(self, defaultValue: list[int]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultRaw(self, defaultValue: typing_extensions.Buffer) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultString(self, defaultValue: str) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDefaultStringArray(self, defaultValue: list[str]) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    @typing.overload
+    def setDefaultValue(self, defaultValue: Value) -> bool:
+        """
+        Sets the entry's value if it does not exist.
+        
+        :param defaultValue: the default value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    @typing.overload
+    def setDefaultValue(self, value: float) -> bool:
+        ...
+    @typing.overload
+    def setDefaultValue(self, value: bool) -> bool:
+        ...
+    @typing.overload
+    def setDefaultValue(self, value: bytes) -> bool:
+        ...
+    @typing.overload
+    def setDefaultValue(self, value: str) -> bool:
+        ...
+    @typing.overload
+    def setDefaultValue(self, value: typing.Sequence) -> bool:
+        ...
+    def setDouble(self, value: float, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setDoubleArray(self, value: list[float], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setFlags(self, flags: int) -> None:
+        """
+        Sets flags.
+        
+        :deprecated: Use SetPersistent() or topic properties instead
+        
+        :param flags: the flags to set (bitmask)
+        """
+    def setFloat(self, value: float, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setFloatArray(self, value: list[float], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setInteger(self, value: int, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setIntegerArray(self, value: list[int], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setPersistent(self) -> None:
+        """
+        Make value persistent through program restarts.
+        """
+    def setRaw(self, value: typing_extensions.Buffer, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setString(self, value: str, time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    def setStringArray(self, value: list[str], time: int = 0) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        :param time:  the timestamp to set (0 = nt::Now())
+        
+        :returns: False if the entry exists with a different type
+        """
+    @typing.overload
+    def setValue(self, value: Value) -> bool:
+        """
+        Sets the entry's value.
+        
+        :param value: the value to set
+        
+        :returns: False if the entry exists with a different type
+        """
+    @typing.overload
+    def setValue(self, value: float) -> bool:
+        ...
+    @typing.overload
+    def setValue(self, value: bool) -> bool:
+        ...
+    @typing.overload
+    def setValue(self, value: bytes) -> bool:
+        ...
+    @typing.overload
+    def setValue(self, value: str) -> bool:
+        ...
+    @typing.overload
+    def setValue(self, value: typing.Sequence) -> bool:
+        ...
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's been published.
+        """
+    @property
+    def value(self) -> typing.Any:
+        ...
+class NetworkTableInstance:
+    """
+    NetworkTables Instance.
+    
+    Instances are completely independent from each other.  Table operations on
+    one instance will not be visible to other instances unless the instances are
+    connected via the network.  The main limitation on instances is that you
+    cannot have two servers on the same network port.  The main utility of
+    instances is for unit testing, but they can also enable one program to
+    connect to two different NetworkTables networks.
+    
+    The global "default" instance (as returned by GetDefault()) is
+    always available, and is intended for the common case when there is only
+    a single NetworkTables instance being used in the program.  The
+    default instance cannot be destroyed.
+    
+    Additional instances can be created with the Create() function.
+    Instances are not reference counted or RAII.  Instead, they must be
+    explicitly destroyed (with Destroy()).
+    
+    @ingroup ntcore_cpp_api
+    """
+    class LogLevel:
+        """
+        Logging levels (as used by SetLogger()).
+        
+        Members:
+        
+          kLogCritical
+        
+          kLogError
+        
+          kLogWarning
+        
+          kLogInfo
+        
+          kLogDebug
+        
+          kLogDebug1
+        
+          kLogDebug2
+        
+          kLogDebug3
+        
+          kLogDebug4
+        """
+        __members__: typing.ClassVar[dict[str, NetworkTableInstance.LogLevel]]  # value = {'kLogCritical': <LogLevel.kLogCritical: 50>, 'kLogError': <LogLevel.kLogError: 40>, 'kLogWarning': <LogLevel.kLogWarning: 30>, 'kLogInfo': <LogLevel.kLogInfo: 20>, 'kLogDebug': <LogLevel.kLogDebug: 10>, 'kLogDebug1': <LogLevel.kLogDebug1: 9>, 'kLogDebug2': <LogLevel.kLogDebug2: 8>, 'kLogDebug3': <LogLevel.kLogDebug3: 7>, 'kLogDebug4': <LogLevel.kLogDebug4: 6>}
+        kLogCritical: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogCritical: 50>
+        kLogDebug: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug: 10>
+        kLogDebug1: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug1: 9>
+        kLogDebug2: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug2: 8>
+        kLogDebug3: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug3: 7>
+        kLogDebug4: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogDebug4: 6>
+        kLogError: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogError: 40>
+        kLogInfo: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogInfo: 20>
+        kLogWarning: typing.ClassVar[NetworkTableInstance.LogLevel]  # value = <LogLevel.kLogWarning: 30>
+        def __eq__(self, other: typing.Any) -> bool:
+            ...
+        def __getstate__(self) -> int:
+            ...
+        def __hash__(self) -> int:
+            ...
+        def __index__(self) -> int:
+            ...
+        def __init__(self, value: int) -> None:
+            ...
+        def __int__(self) -> int:
+            ...
+        def __ne__(self, other: typing.Any) -> bool:
+            ...
+        def __repr__(self) -> str:
+            ...
+        def __setstate__(self, state: int) -> None:
+            ...
+        def __str__(self) -> str:
+            ...
+        @property
+        def name(self) -> str:
+            ...
+        @property
+        def value(self) -> int:
+            ...
+    class NetworkMode:
+        """
+        Client/server mode flag values (as returned by GetNetworkMode()).
+        This is a bitmask.
+        
+        Members:
+        
+          kNetModeNone
+        
+          kNetModeServer
+        
+          kNetModeClient3
+        
+          kNetModeClient4
+        
+          kNetModeLocal
+        
+          kNetModeStarting
+        """
+        __members__: typing.ClassVar[dict[str, NetworkTableInstance.NetworkMode]]  # value = {'kNetModeNone': <NetworkMode.kNetModeNone: 0>, 'kNetModeServer': <NetworkMode.kNetModeServer: 1>, 'kNetModeClient3': <NetworkMode.kNetModeClient3: 2>, 'kNetModeClient4': <NetworkMode.kNetModeClient4: 4>, 'kNetModeLocal': <NetworkMode.kNetModeLocal: 16>, 'kNetModeStarting': <NetworkMode.kNetModeStarting: 8>}
+        kNetModeClient3: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeClient3: 2>
+        kNetModeClient4: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeClient4: 4>
+        kNetModeLocal: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeLocal: 16>
+        kNetModeNone: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeNone: 0>
+        kNetModeServer: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeServer: 1>
+        kNetModeStarting: typing.ClassVar[NetworkTableInstance.NetworkMode]  # value = <NetworkMode.kNetModeStarting: 8>
+        def __and__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __eq__(self, other: typing.Any) -> bool:
+            ...
+        def __ge__(self, other: typing.Any) -> bool:
+            ...
+        def __getstate__(self) -> int:
+            ...
+        def __gt__(self, other: typing.Any) -> bool:
+            ...
+        def __hash__(self) -> int:
+            ...
+        def __index__(self) -> int:
+            ...
+        def __init__(self, value: int) -> None:
+            ...
+        def __int__(self) -> int:
+            ...
+        def __invert__(self) -> typing.Any:
+            ...
+        def __le__(self, other: typing.Any) -> bool:
+            ...
+        def __lt__(self, other: typing.Any) -> bool:
+            ...
+        def __ne__(self, other: typing.Any) -> bool:
+            ...
+        def __or__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __rand__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __repr__(self) -> str:
+            ...
+        def __ror__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __rxor__(self, other: typing.Any) -> typing.Any:
+            ...
+        def __setstate__(self, state: int) -> None:
+            ...
+        def __str__(self) -> str:
+            ...
+        def __xor__(self, other: typing.Any) -> typing.Any:
+            ...
+        @property
+        def name(self) -> str:
+            ...
+        @property
+        def value(self) -> int:
+            ...
+    __hash__: typing.ClassVar[None] = None
+    kDefaultPort3: typing.ClassVar[int] = 1735
+    kDefaultPort4: typing.ClassVar[int] = 5810
+    @staticmethod
+    def create() -> NetworkTableInstance:
+        """
+        Create an instance.
+        
+        :returns: Newly created instance
+        """
+    @staticmethod
+    def destroy(inst: NetworkTableInstance) -> None:
+        """
+        Destroys an instance (note: this has global effect).
+        
+        :param inst: Instance
+        """
+    @staticmethod
+    def getDefault() -> NetworkTableInstance:
+        """
+        Get global default instance.
+        
+        :returns: Global default instance
+        """
+    @staticmethod
+    def removeListener(listener: int) -> None:
+        """
+        Remove a listener.
+        
+        :param listener: Listener handle to remove
+        """
+    @staticmethod
+    def stopConnectionDataLog(logger: int) -> None:
+        """
+        Stops logging connection changes to a DataLog.
+        
+        :param logger: data logger handle
+        """
+    @staticmethod
+    def stopEntryDataLog(logger: int) -> None:
+        """
+        Stops logging entry changes to a DataLog.
+        
+        :param logger: data logger handle
+        """
+    def __eq__(self, arg0: NetworkTableInstance) -> bool:
+        """
+        Equality operator.  Returns true if both instances refer to the same
+        native handle.
+        """
+    def _getHandle(self) -> int:
+        """
+        Gets the native handle for the entry.
+        
+        :returns: Native handle
+        """
+    def _reset(self) -> None:
+        ...
+    def addConnectionListener(self, immediate_notify: bool, callback: typing.Callable[[Event], None]) -> int:
+        """
+        Add a connection listener. The callback function is called asynchronously
+        on a separate thread, so it's important to use synchronization or atomics
+        when accessing any shared state from the callback function.
+        
+        :param immediate_notify: notify listener of all existing connections
+        :param callback:         listener to add
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, topic: Topic, eventMask: int, listener: typing.Callable[[Event], None]) -> int:
+        """
+        Add a listener for changes on a particular topic. The callback
+        function is called asynchronously on a separate thread, so it's important
+        to use synchronization or atomics when accessing any shared state from the
+        callback function.
+        
+        This creates a corresponding internal subscriber with the lifetime of the
+        listener.
+        
+        :param topic:     Topic
+        :param eventMask: Bitmask of EventFlags values
+        :param listener:  Listener function
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, subscriber: Subscriber, eventMask: int, listener: typing.Callable[[Event], None]) -> int:
+        """
+        Add a listener for changes on a subscriber. The callback
+        function is called asynchronously on a separate thread, so it's important
+        to use synchronization or atomics when accessing any shared state from the
+        callback function. This does NOT keep the subscriber active.
+        
+        :param subscriber: Subscriber
+        :param eventMask:  Bitmask of EventFlags values
+        :param listener:   Listener function
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, subscriber: MultiSubscriber, eventMask: int, listener: typing.Callable[[Event], None]) -> int:
+        """
+        Add a listener for changes on a subscriber. The callback
+        function is called asynchronously on a separate thread, so it's important
+        to use synchronization or atomics when accessing any shared state from the
+        callback function. This does NOT keep the subscriber active.
+        
+        :param subscriber: Subscriber
+        :param eventMask:  Bitmask of EventFlags values
+        :param listener:   Listener function
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, entry: NetworkTableEntry, eventMask: int, listener: typing.Callable[[Event], None]) -> int:
+        """
+        Add a listener for changes on an entry. The callback function
+        is called asynchronously on a separate thread, so it's important to use
+        synchronization or atomics when accessing any shared state from the
+        callback function.
+        
+        :param entry:     Entry
+        :param eventMask: Bitmask of EventFlags values
+        :param listener:  Listener function
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, prefixes: list[str], eventMask: int, listener: typing.Callable[[Event], None]) -> int:
+        """
+        Add a listener for changes to topics with names that start with any
+        of the given prefixes. The callback function is called asynchronously on a
+        separate thread, so it's important to use synchronization or atomics when
+        accessing any shared state from the callback function.
+        
+        This creates a corresponding internal subscriber with the lifetime of the
+        listener.
+        
+        :param prefixes:  Topic name string prefixes
+        :param eventMask: Bitmask of EventFlags values
+        :param listener:  Listener function
+        
+        :returns: Listener handle
+        """
+    def addLogger(self, minLevel: int, maxLevel: int, func: typing.Callable[[Event], None]) -> int:
+        """
+        Add logger callback function.  By default, log messages are sent to stderr;
+        this function sends log messages with the specified levels to the provided
+        callback function instead.  The callback function will only be called for
+        log messages with level greater than or equal to minLevel and less than or
+        equal to maxLevel; messages outside this range will be silently ignored.
+        
+        :param minLevel: minimum log level
+        :param maxLevel: maximum log level
+        :param func:     callback function
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addSchema(self, name: str, type: str, schema: typing_extensions.Buffer) -> None:
+        """
+        Registers a data schema.  Data schemas provide information for how a
+        certain data type string can be decoded.  The type string of a data schema
+        indicates the type of the schema itself (e.g. "protobuf" for protobuf
+        schemas, "struct" for struct schemas, etc). In NetworkTables, schemas are
+        published just like normal topics, with the name being generated from the
+        provided name: "/.schema/<name>".  Duplicate calls to this function with
+        the same name are silently ignored.
+        
+        :param name:   Name (the string passed as the data type for topics using this
+                       schema)
+        :param type:   Type of schema (e.g. "protobuf", "struct", etc)
+        :param schema: Schema data
+        """
+    @typing.overload
+    def addSchema(self, name: str, type: str, schema: str) -> None:
+        """
+        Registers a data schema.  Data schemas provide information for how a
+        certain data type string can be decoded.  The type string of a data schema
+        indicates the type of the schema itself (e.g. "protobuf" for protobuf
+        schemas, "struct" for struct schemas, etc). In NetworkTables, schemas are
+        published just like normal topics, with the name being generated from the
+        provided name: "/.schema/<name>".  Duplicate calls to this function with
+        the same name are silently ignored.
+        
+        :param name:   Name (the string passed as the data type for topics using this
+                       schema)
+        :param type:   Type of schema (e.g. "protobuf", "struct", etc)
+        :param schema: Schema data
+        """
+    def addTimeSyncListener(self, immediate_notify: bool, callback: typing.Callable[[Event], None]) -> int:
+        """
+        Add a time synchronization listener. The callback function is called
+        asynchronously on a separate thread, so it's important to use
+        synchronization or atomics when accessing any shared state from the
+        callback function.
+        
+        :param immediate_notify: notify listener of current time synchronization
+                                 value
+        :param callback:         listener to add
+        
+        :returns: Listener handle
+        """
+    def configPythonLogging(self, *, min: NetworkTableInstance.LogLevel = ..., max: NetworkTableInstance.LogLevel = ..., name: str = 'nt') -> None:
+        """
+        Configure python logging for this instance.
+        
+        :param min:  Minimum NT level to log
+        :param max:  Maximum NT level to log
+        :param name: Name of python logger
+        
+        .. note:: This must be called before the instance is started
+        """
+    def disconnect(self) -> None:
+        """
+        Disconnects the client if it's running and connected. This will
+        automatically start reconnection attempts to the current server list.
+        """
+    def flush(self) -> None:
+        """
+        Flushes all updated values immediately to the network.
+        .. note:: This is rate-limited to protect the network from flooding.
+           This is primarily useful for synchronizing network updates with
+           user code.
+        """
+    def flushLocal(self) -> None:
+        """
+        Flushes all updated values immediately to the local client/server. This
+        does not flush to the network.
+        """
+    def getBooleanArrayTopic(self, name: str) -> BooleanArrayTopic:
+        """
+        Gets a boolean array topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getBooleanTopic(self, name: str) -> BooleanTopic:
+        """
+        Gets a boolean topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getConnections(self) -> list[ConnectionInfo]:
+        """
+        Get information on the currently established network connections.
+        If operating as a client, this will return either zero or one values.
+        
+        :returns: array of connection information
+        """
+    def getDoubleArrayTopic(self, name: str) -> DoubleArrayTopic:
+        """
+        Gets a double array topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getDoubleTopic(self, name: str) -> DoubleTopic:
+        """
+        Gets a double topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getEntry(self, name: str) -> NetworkTableEntry:
+        """
+        Gets the entry for a key.
+        
+        :param name: Key
+        
+        :returns: Network table entry.
+        """
+    def getFloatArrayTopic(self, name: str) -> FloatArrayTopic:
+        """
+        Gets a float array topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getFloatTopic(self, name: str) -> FloatTopic:
+        """
+        Gets a float topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getIntegerArrayTopic(self, name: str) -> IntegerArrayTopic:
+        """
+        Gets an integer array topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getIntegerTopic(self, name: str) -> IntegerTopic:
+        """
+        Gets an integer topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getNetworkMode(self) -> int:
+        """
+        Get the current network mode.
+        
+        :returns: Bitmask of NetworkMode.
+        """
+    def getRawTopic(self, name: str) -> RawTopic:
+        """
+        Gets a raw topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getServerTimeOffset(self) -> int | None:
+        """
+        Get the time offset between server time and local time. Add this value to
+        local time to get the estimated equivalent server time. In server mode,
+        this always returns 0. In client mode, this returns the time offset only if
+        the client and server are connected and have exchanged synchronization
+        messages. Note the time offset may change over time as it is periodically
+        updated; to receive updates as events, add a listener to the "time sync"
+        event.
+        
+        :returns: Time offset in microseconds (optional)
+        """
+    def getStringArrayTopic(self, name: str) -> StringArrayTopic:
+        """
+        Gets a string array topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getStringTopic(self, name: str) -> StringTopic:
+        """
+        Gets a string topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    def getStructArrayTopic(self, name: str, type: type) -> StructArrayTopic:
+        """
+        Gets a raw struct serialized array topic.
+        
+        :param name: topic name
+        :param type: optional struct type info
+        
+        :returns: Topic
+        """
+    def getStructTopic(self, name: str, type: type) -> StructTopic:
+        """
+        Gets a raw struct serialized value topic.
+        
+        :param name: topic name
+        :param type: optional struct type info
+        
+        :returns: Topic
+        """
+    def getTable(self, key: str) -> NetworkTable:
+        """
+        Gets the table with the specified key.
+        
+        :param key: the key name
+        
+        :returns: The network table
+        """
+    def getTopic(self, name: str) -> Topic:
+        """
+        Gets a "generic" (untyped) topic.
+        
+        :param name: topic name
+        
+        :returns: Topic
+        """
+    @typing.overload
+    def getTopicInfo(self) -> list[TopicInfo]:
+        """
+        Get Topic Information about multiple topics.
+        
+        Returns an array of topic information (handle, name, type, and properties).
+        
+        :returns: Array of topic information.
+        """
+    @typing.overload
+    def getTopicInfo(self, prefix: str) -> list[TopicInfo]:
+        """
+        Get Topic Information about multiple topics.
+        
+        Returns an array of topic information (handle, name, type, and properties).
+        The results are filtered by string prefix to only
+        return a subset of all topics.
+        
+        :param prefix: name required prefix; only topics whose name
+                       starts with this string are returned
+        
+        :returns: Array of topic information.
+        """
+    @typing.overload
+    def getTopicInfo(self, prefix: str, types: int) -> list[TopicInfo]:
+        """
+        Get Topic Information about multiple topics.
+        
+        Returns an array of topic information (handle, name, type, and properties).
+        The results are filtered by string prefix and type to only
+        return a subset of all topics.
+        
+        :param prefix: name required prefix; only topics whose name
+                       starts with this string are returned
+        :param types:  bitmask of NT_Type values; 0 is treated specially
+                       as a "don't care"
+        
+        :returns: Array of topic information.
+        """
+    @typing.overload
+    def getTopicInfo(self, prefix: str, types: list[str]) -> list[TopicInfo]:
+        """
+        Get Topic Information about multiple topics.
+        
+        Returns an array of topic information (handle, name, type, and properties).
+        The results are filtered by string prefix and type to only
+        return a subset of all topics.
+        
+        :param prefix: name required prefix; only topics whose name
+                       starts with this string are returned
+        :param types:  array of type strings
+        
+        :returns: Array of topic information.
+        """
+    @typing.overload
+    def getTopics(self) -> list[Topic]:
+        """
+        Get Published Topics.
+        
+        Returns an array of topics.
+        
+        :returns: Array of topics.
+        """
+    @typing.overload
+    def getTopics(self, prefix: str) -> list[Topic]:
+        """
+        Get Published Topics.
+        
+        Returns an array of topics.  The results are filtered by
+        string prefix to only return a subset of all topics.
+        
+        :param prefix: name required prefix; only topics whose name
+                       starts with this string are returned
+        
+        :returns: Array of topics.
+        """
+    @typing.overload
+    def getTopics(self, prefix: str, types: int) -> list[Topic]:
+        """
+        Get Published Topics.
+        
+        Returns an array of topics.  The results are filtered by
+        string prefix and type to only return a subset of all topics.
+        
+        :param prefix: name required prefix; only topics whose name
+                       starts with this string are returned
+        :param types:  bitmask of NT_Type values; 0 is treated specially
+                       as a "don't care"
+        
+        :returns: Array of topics.
+        """
+    @typing.overload
+    def getTopics(self, prefix: str, types: list[str]) -> list[Topic]:
+        """
+        Get Published Topics.
+        
+        Returns an array of topics.  The results are filtered by
+        string prefix and type to only return a subset of all topics.
+        
+        :param prefix: name required prefix; only topics whose name
+                       starts with this string are returned
+        :param types:  array of type strings
+        
+        :returns: Array of topic handles.
+        """
+    def hasSchema(self, name: str) -> bool:
+        """
+        Returns whether there is a data schema already registered with the given
+        name. This does NOT perform a check as to whether the schema has already
+        been published by another node on the network.
+        
+        :param name: Name (the string passed as the data type for topics using this
+                     schema)
+        
+        :returns: True if schema already registered
+        """
+    def isConnected(self) -> bool:
+        """
+        Return whether or not the instance is connected to another node.
+        
+        :returns: True if connected.
+        """
+    @typing.overload
+    def setServer(self, server_name: str, port: int = 0) -> None:
+        """
+        Sets server address and port for client (without restarting client).
+        
+        :param server_name: server name (UTF-8 string, null terminated)
+        :param port:        port to communicate over (0 = default)
+        """
+    @typing.overload
+    def setServer(self, servers: list[tuple[str, int]]) -> None:
+        """
+        Sets server addresses and ports for client (without restarting client).
+        The client will attempt to connect to each server in round robin fashion.
+        
+        :param servers: array of server address and port pairs
+        """
+    @typing.overload
+    def setServer(self, servers: list[str], port: int = 0) -> None:
+        """
+        Sets server addresses and port for client (without restarting client).
+        The client will attempt to connect to each server in round robin fashion.
+        
+        :param servers: array of server names
+        :param port:    port to communicate over (0 = default)
+        """
+    def setServerTeam(self, team: int, port: int = 0) -> None:
+        """
+        Sets server addresses and port for client (without restarting client).
+        Connects using commonly known robot addresses for the specified team.
+        
+        :param team: team number
+        :param port: port to communicate over (0 = default)
+        """
+    def startClient3(self, identity: str) -> None:
+        """
+        Starts a NT3 client.  Use SetServer or SetServerTeam to set the server name
+        and port.
+        
+        :param identity: network identity to advertise (cannot be empty string)
+        """
+    def startClient4(self, identity: str) -> None:
+        """
+        Starts a NT4 client.  Use SetServer or SetServerTeam to set the server name
+        and port.
+        
+        :param identity: network identity to advertise (cannot be empty string)
+        """
+    def startConnectionDataLog(self, log: wpiutil._wpiutil.log.DataLog, name: str) -> int:
+        """
+        Starts logging connection changes to a DataLog.
+        
+        :param log:  data log object; lifetime must extend until
+                     StopConnectionDataLog is called or the instance is destroyed
+        :param name: data log entry name
+        
+        :returns: Data logger handle
+        """
+    def startDSClient(self, port: int = 0) -> None:
+        """
+        Starts requesting server address from Driver Station.
+        This connects to the Driver Station running on localhost to obtain the
+        server IP address.
+        
+        :param port: server port to use in combination with IP from DS (0 = default)
+        """
+    def startEntryDataLog(self, log: wpiutil._wpiutil.log.DataLog, prefix: str, logPrefix: str) -> int:
+        """
+        Starts logging entry changes to a DataLog.
+        
+        :param log:       data log object; lifetime must extend until StopEntryDataLog is
+                          called or the instance is destroyed
+        :param prefix:    only store entries with names that start with this prefix;
+                          the prefix is not included in the data log entry name
+        :param logPrefix: prefix to add to data log entry names
+        
+        :returns: Data logger handle
+        """
+    def startLocal(self) -> None:
+        """
+        Starts local-only operation.  Prevents calls to StartServer or StartClient
+        from taking effect.  Has no effect if StartServer or StartClient
+        has already been called.
+        """
+    def startServer(self, persist_filename: str = 'networktables.json', listen_address: str = '', port3: int = 1735, port4: int = 5810) -> None:
+        """
+        Starts a server using the specified filename, listening address, and port.
+        
+        :param persist_filename: the name of the persist file to use (UTF-8 string,
+                                 null terminated)
+        :param listen_address:   the address to listen on, or null to listen on any
+                                 address (UTF-8 string, null terminated)
+        :param port3:            port to communicate over (NT3)
+        :param port4:            port to communicate over (NT4)
+        """
+    def stopClient(self) -> None:
+        """
+        Stops the client if it is running.
+        """
+    def stopDSClient(self) -> None:
+        """
+        Stops requesting server address from Driver Station.
+        """
+    def stopLocal(self) -> None:
+        """
+        Stops local-only operation.  StartServer or StartClient can be called after
+        this call to start a server or client.
+        """
+    def stopServer(self) -> None:
+        """
+        Stops the server if it is running.
+        """
+    def waitForListenerQueue(self, timeout: float) -> bool:
+        """
+        Wait for the listener queue to be empty. This is primarily
+        useful for deterministic testing. This blocks until either the
+        listener queue is empty (e.g. there are no more events that need to be
+        passed along to callbacks or poll queues) or the timeout expires.
+        
+        :param timeout: timeout, in seconds. Set to 0 for non-blocking behavior, or
+                        a negative value to block indefinitely
+        
+        :returns: False if timed out, otherwise true.
+        """
+class NetworkTableListener:
+    """
+    Event listener. This calls back to a callback function when an event
+    matching the specified mask occurs. The callback function is called
+    asynchronously on a separate thread, so it's important to use synchronization
+    or atomics when accessing any shared state from the callback function.
+    """
+    @staticmethod
+    def createConnectionListener(inst: NetworkTableInstance, immediate_notify: bool, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
+        """
+        Create a connection listener.
+        
+        :param inst:             instance
+        :param immediate_notify: notify listener of all existing connections
+        :param listener:         listener function
+        
+        :returns: Listener
+        """
+    @staticmethod
+    @typing.overload
+    def createListener(inst: NetworkTableInstance, prefixes: list[str], mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
+        """
+        Create a listener for changes to topics with names that start with any of
+        the given prefixes. This creates a corresponding internal subscriber with
+        the lifetime of the listener.
+        
+        :param inst:     Instance
+        :param prefixes: Topic name string prefixes
+        :param mask:     Bitmask of EventFlags values
+        :param listener: Listener function
+        
+        :returns: Listener
+        """
+    @staticmethod
+    @typing.overload
+    def createListener(topic: Topic, mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
+        """
+        Create a listener for changes on a particular topic. This creates a
+        corresponding internal subscriber with the lifetime of the listener.
+        
+        :param topic:    Topic
+        :param mask:     Bitmask of EventFlags values
+        :param listener: Listener function
+        
+        :returns: Listener
+        """
+    @staticmethod
+    @typing.overload
+    def createListener(subscriber: Subscriber, mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
+        """
+        Create a listener for topic changes on a subscriber. This does NOT keep the
+        subscriber active.
+        
+        :param subscriber: Subscriber
+        :param mask:       Bitmask of EventFlags values
+        :param listener:   Listener function
+        
+        :returns: Listener
+        """
+    @staticmethod
+    @typing.overload
+    def createListener(subscriber: MultiSubscriber, mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
+        """
+        Create a listener for topic changes on a subscriber. This does NOT keep the
+        subscriber active.
+        
+        :param subscriber: Subscriber
+        :param mask:       Bitmask of EventFlags values
+        :param listener:   Listener function
+        
+        :returns: Listener
+        """
+    @staticmethod
+    @typing.overload
+    def createListener(entry: NetworkTableEntry, mask: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
+        """
+        Create a listener for topic changes on an entry.
+        
+        :param entry:    Entry
+        :param mask:     Bitmask of EventFlags values
+        :param listener: Listener function
+        
+        :returns: Listener
+        """
+    @staticmethod
+    def createLogger(inst: NetworkTableInstance, minLevel: int, maxLevel: int, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
+        """
+        Create a listener for log messages.  By default, log messages are sent to
+        stderr; this function sends log messages with the specified levels to the
+        provided callback function instead.  The callback function will only be
+        called for log messages with level greater than or equal to minLevel and
+        less than or equal to maxLevel; messages outside this range will be
+        silently ignored.
+        
+        :param inst:     instance
+        :param minLevel: minimum log level
+        :param maxLevel: maximum log level
+        :param listener: listener function
+        
+        :returns: Listener
+        """
+    @staticmethod
+    def createTimeSyncListener(inst: NetworkTableInstance, immediate_notify: bool, listener: typing.Callable[[Event], None]) -> NetworkTableListener:
+        """
+        Create a time synchronization listener.
+        
+        :param inst:             instance
+        :param immediate_notify: notify listener of current time synchronization
+                                 value
+        :param listener:         listener function
+        
+        :returns: Listener
+        """
+    def __enter__(self) -> NetworkTableListener:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the listener
+        """
+    def getHandle(self) -> int:
+        """
+        Gets the native handle.
+        
+        :returns: Handle
+        """
+    def waitForQueue(self, timeout: float) -> bool:
+        """
+        Wait for the listener queue to be empty. This is primarily useful for
+        deterministic testing. This blocks until either the listener queue is
+        empty (e.g. there are no more events that need to be passed along to
+        callbacks or poll queues) or the timeout expires.
+        
+        :param timeout: timeout, in seconds. Set to 0 for non-blocking behavior, or
+                        a negative value to block indefinitely
+        
+        :returns: False if timed out, otherwise true.
+        """
+class NetworkTableListenerPoller:
+    """
+    Event polled listener. This queues events matching the specified mask. Code
+    using the listener must periodically call ReadQueue() to read the
+    events.
+    """
+    def __enter__(self) -> NetworkTableListenerPoller:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, inst: NetworkTableInstance) -> None:
+        """
+        Construct a listener poller.
+        
+        :param inst: Instance
+        """
+    def addConnectionListener(self, immediate_notify: bool) -> int:
+        """
+        Add a connection listener. The callback function is called asynchronously
+        on a separate thread, so it's important to use synchronization or atomics
+        when accessing any shared state from the callback function.
+        
+        :param immediate_notify: notify listener of all existing connections
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, prefixes: list[str], mask: int) -> int:
+        """
+        Start listening to topic changes for topics with names that start with any
+        of the given prefixes. This creates a corresponding internal subscriber
+        with the lifetime of the listener.
+        
+        :param prefixes: Topic name string prefixes
+        :param mask:     Bitmask of EventFlags values
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, topic: Topic, mask: int) -> int:
+        """
+        Start listening to changes to a particular topic. This creates a
+        corresponding internal subscriber with the lifetime of the listener.
+        
+        :param topic: Topic
+        :param mask:  Bitmask of EventFlags values
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, subscriber: Subscriber, mask: int) -> int:
+        """
+        Start listening to topic changes on a subscriber. This does NOT keep the
+        subscriber active.
+        
+        :param subscriber: Subscriber
+        :param mask:       Bitmask of EventFlags values
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, subscriber: MultiSubscriber, mask: int) -> int:
+        """
+        Start listening to topic changes on a subscriber. This does NOT keep the
+        subscriber active.
+        
+        :param subscriber: Subscriber
+        :param mask:       Bitmask of EventFlags values
+        
+        :returns: Listener handle
+        """
+    @typing.overload
+    def addListener(self, entry: NetworkTableEntry, mask: int) -> int:
+        """
+        Start listening to topic changes on an entry.
+        
+        :param entry: Entry
+        :param mask:  Bitmask of EventFlags values
+        
+        :returns: Listener handle
+        """
+    def addLogger(self, minLevel: int, maxLevel: int) -> int:
+        """
+        Add logger callback function.  By default, log messages are sent to stderr;
+        this function sends log messages with the specified levels to the provided
+        callback function instead.  The callback function will only be called for
+        log messages with level greater than or equal to minLevel and less than or
+        equal to maxLevel; messages outside this range will be silently ignored.
+        
+        :param minLevel: minimum log level
+        :param maxLevel: maximum log level
+        
+        :returns: Listener handle
+        """
+    def addTimeSyncListener(self, immediate_notify: bool) -> int:
+        """
+        Add a time synchronization listener. The callback function is called
+        asynchronously on a separate thread, so it's important to use
+        synchronization or atomics when accessing any shared state from the
+        callback function.
+        
+        :param immediate_notify: notify listener of current time synchronization
+                                 value
+        
+        :returns: Listener handle
+        """
+    def close(self) -> None:
+        """
+        Destroys the poller
+        """
+    def getHandle(self) -> int:
+        """
+        Gets the native handle.
+        
+        :returns: Handle
+        """
+    def readQueue(self) -> list[Event]:
+        """
+        Read events.
+        
+        :returns: Events since the previous call to ReadQueue()
+        """
+    def removeListener(self, listener: int) -> None:
+        """
+        Remove a listener.
+        
+        :param listener: Listener handle
+        """
+class NetworkTableType:
+    """
+    NetworkTable entry type.
+    @ingroup ntcore_cpp_api
+    
+    Members:
+    
+      kUnassigned : Unassigned data type.
+    
+      kBoolean : Boolean data type.
+    
+      kDouble : Double precision floating-point data type.
+    
+      kString : String data type.
+    
+      kRaw : Raw data type.
+    
+      kBooleanArray : Boolean array data type.
+    
+      kDoubleArray : Double precision floating-point array data type.
+    
+      kStringArray : String array data type.
+    
+      kInteger : Integer data type.
+    
+      kFloat : Single precision floating-point data type.
+    
+      kIntegerArray : Integer array data type.
+    
+      kFloatArray : Single precision floating-point array data type.
+    """
+    __members__: typing.ClassVar[dict[str, NetworkTableType]]  # value = {'kUnassigned': <NetworkTableType.kUnassigned: 0>, 'kBoolean': <NetworkTableType.kBoolean: 1>, 'kDouble': <NetworkTableType.kDouble: 2>, 'kString': <NetworkTableType.kString: 4>, 'kRaw': <NetworkTableType.kRaw: 8>, 'kBooleanArray': <NetworkTableType.kBooleanArray: 16>, 'kDoubleArray': <NetworkTableType.kDoubleArray: 32>, 'kStringArray': <NetworkTableType.kStringArray: 64>, 'kInteger': <NetworkTableType.kInteger: 256>, 'kFloat': <NetworkTableType.kFloat: 512>, 'kIntegerArray': <NetworkTableType.kIntegerArray: 1024>, 'kFloatArray': <NetworkTableType.kFloatArray: 2048>}
+    kBoolean: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kBoolean: 1>
+    kBooleanArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kBooleanArray: 16>
+    kDouble: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kDouble: 2>
+    kDoubleArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kDoubleArray: 32>
+    kFloat: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kFloat: 512>
+    kFloatArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kFloatArray: 2048>
+    kInteger: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kInteger: 256>
+    kIntegerArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kIntegerArray: 1024>
+    kRaw: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kRaw: 8>
+    kString: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kString: 4>
+    kStringArray: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kStringArray: 64>
+    kUnassigned: typing.ClassVar[NetworkTableType]  # value = <NetworkTableType.kUnassigned: 0>
+    def __eq__(self, other: typing.Any) -> bool:
+        ...
+    def __getstate__(self) -> int:
+        ...
+    def __hash__(self) -> int:
+        ...
+    def __index__(self) -> int:
+        ...
+    def __init__(self, value: int) -> None:
+        ...
+    def __int__(self) -> int:
+        ...
+    def __ne__(self, other: typing.Any) -> bool:
+        ...
+    def __repr__(self) -> str:
+        ...
+    def __setstate__(self, state: int) -> None:
+        ...
+    def __str__(self) -> str:
+        ...
+    @property
+    def name(self) -> str:
+        ...
+    @property
+    def value(self) -> int:
+        ...
+class PubSubOptions:
+    """
+    NetworkTables publish/subscribe options.
+    """
+    kDefaultPeriodic: typing.ClassVar[float] = 0.1
+    def __init__(self, *, pollStorage: int = 0, periodic: float = 0.1, excludePublisher: Publisher | None = None, sendAll: bool = False, topicsOnly: bool = False, keepDuplicates: bool = False, prefixMatch: bool = False, disableRemote: bool = False, disableLocal: bool = False, excludeSelf: bool = False, hidden: bool = False) -> None:
+        """
+              :param pollStorage:      Polling storage size for a subscription. Specifies the maximum number of
+                                       updates NetworkTables should store between calls to the subscriber's
+                                       ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if
+                                       sendAll is true.
+              :param periodic:         How frequently changes will be sent over the network, in seconds.
+                                       NetworkTables may send more frequently than this (e.g. use a combined
+                                       minimum period for all values) or apply a restricted range to this value.
+                                       The default is 100 ms.
+              :param excludePublisher: For subscriptions, if non-zero, value updates for ReadQueue() are not
+                                       queued for this publisher.
+              :param sendAll:          Send all value changes over the network.
+              :param topicsOnly:       For subscriptions, don't ask for value changes (only topic announcements).
+              :param keepDuplicates:   Preserve duplicate value changes (rather than ignoring them).
+              :param prefixMatch:      Perform prefix match on subscriber topic names. Is ignored/overridden by
+                                       Subscribe() functions; only present in struct for the purposes of getting
+                                       information about subscriptions.
+              :param disableRemote:    For subscriptions, if remote value updates should not be queued for
+                                       ReadQueue(). See also disableLocal.
+              :param disableLocal:     For subscriptions, if local value updates should not be queued for
+                                       ReadQueue(). See also disableRemote.
+              :param excludeSelf:      For entries, don't queue (for ReadQueue) value updates for the entry's
+                                       internal publisher.
+              :param hidden:           For subscriptions, don't share the existence of the subscription with the
+                                       network. Note this means updates will not be received from the network
+                                       unless another subscription overlaps with this one, and the subscription
+                                       will not appear in metatopics.
+        """
+    @property
+    def disableLocal(self) -> bool:
+        """
+        For subscriptions, if local value updates should not be queued for
+        ReadQueue(). See also disableRemote.
+        """
+    @disableLocal.setter
+    def disableLocal(self, arg0: bool) -> None:
+        ...
+    @property
+    def disableRemote(self) -> bool:
+        """
+        For subscriptions, if remote value updates should not be queued for
+        ReadQueue(). See also disableLocal.
+        """
+    @disableRemote.setter
+    def disableRemote(self, arg0: bool) -> None:
+        ...
+    @property
+    def excludePublisher(self) -> int:
+        """
+        For subscriptions, if non-zero, value updates for ReadQueue() are not
+        queued for this publisher.
+        """
+    @excludePublisher.setter
+    def excludePublisher(self, arg0: int) -> None:
+        ...
+    @property
+    def excludeSelf(self) -> bool:
+        """
+        For entries, don't queue (for ReadQueue) value updates for the entry's
+        internal publisher.
+        """
+    @excludeSelf.setter
+    def excludeSelf(self, arg0: bool) -> None:
+        ...
+    @property
+    def hidden(self) -> bool:
+        """
+        For subscriptions, don't share the existence of the subscription with the
+        network. Note this means updates will not be received from the network
+        unless another subscription overlaps with this one, and the subscription
+        will not appear in metatopics.
+        """
+    @hidden.setter
+    def hidden(self, arg0: bool) -> None:
+        ...
+    @property
+    def keepDuplicates(self) -> bool:
+        """
+        Preserve duplicate value changes (rather than ignoring them).
+        """
+    @keepDuplicates.setter
+    def keepDuplicates(self, arg0: bool) -> None:
+        ...
+    @property
+    def periodic(self) -> float:
+        """
+        How frequently changes will be sent over the network, in seconds.
+        NetworkTables may send more frequently than this (e.g. use a combined
+        minimum period for all values) or apply a restricted range to this value.
+        The default is 100 ms.
+        """
+    @periodic.setter
+    def periodic(self, arg0: float) -> None:
+        ...
+    @property
+    def pollStorage(self) -> int:
+        """
+        Polling storage size for a subscription. Specifies the maximum number of
+        updates NetworkTables should store between calls to the subscriber's
+        ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if
+        sendAll is true.
+        """
+    @pollStorage.setter
+    def pollStorage(self, arg0: int) -> None:
+        ...
+    @property
+    def prefixMatch(self) -> bool:
+        """
+        Perform prefix match on subscriber topic names. Is ignored/overridden by
+        Subscribe() functions; only present in struct for the purposes of getting
+        information about subscriptions.
+        """
+    @prefixMatch.setter
+    def prefixMatch(self, arg0: bool) -> None:
+        ...
+    @property
+    def sendAll(self) -> bool:
+        """
+        Send all value changes over the network.
+        """
+    @sendAll.setter
+    def sendAll(self, arg0: bool) -> None:
+        ...
+    @property
+    def topicsOnly(self) -> bool:
+        """
+        For subscriptions, don't ask for value changes (only topic announcements).
+        """
+    @topicsOnly.setter
+    def topicsOnly(self, arg0: bool) -> None:
+        ...
+class Publisher:
+    """
+    NetworkTables publisher.
+    """
+    def getTopic(self) -> Topic:
+        """
+        Gets the published-to topic.
+        
+        :returns: Topic
+        """
+    @property
+    def _m_pubHandle(self) -> int:
+        """
+        NetworkTables handle.
+        """
+class RawEntry(RawSubscriber, RawPublisher):
+    """
+    NetworkTables Raw entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> RawEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> RawTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class RawPublisher(Publisher):
+    """
+    NetworkTables Raw publisher.
+    """
+    def __enter__(self) -> RawPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> RawTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: typing_extensions.Buffer, time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: typing_extensions.Buffer) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class RawSubscriber(Subscriber):
+    """
+    NetworkTables Raw subscriber.
+    """
+    def __enter__(self) -> RawSubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> bytes:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: typing_extensions.Buffer) -> bytes:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedRaw:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: typing_extensions.Buffer) -> TimestampedRaw:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> RawTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedRaw]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class RawTopic(Topic):
+    """
+    NetworkTables Raw topic.
+    """
+    def __enter__(self) -> RawTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, typeString: str, defaultValue: typing_extensions.Buffer, options: PubSubOptions = ...) -> RawEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, typeString: str, options: PubSubOptions = ...) -> RawPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> RawPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, typeString: str, defaultValue: typing_extensions.Buffer, options: PubSubOptions = ...) -> RawSubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class StringArrayEntry(StringArraySubscriber, StringArrayPublisher):
+    """
+    NetworkTables StringArray entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> StringArrayEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> StringArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class StringArrayPublisher(Publisher):
+    """
+    NetworkTables StringArray publisher.
+    """
+    def __enter__(self) -> StringArrayPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> StringArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: list[str], time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: list[str]) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class StringArraySubscriber(Subscriber):
+    """
+    NetworkTables StringArray subscriber.
+    """
+    def __enter__(self) -> StringArraySubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> list[str]:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: list[str]) -> list[str]:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedStringArray:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: list[str]) -> TimestampedStringArray:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> StringArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedStringArray]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class StringArrayTopic(Topic):
+    """
+    NetworkTables StringArray topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'string[]'
+    def __enter__(self) -> StringArrayTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: list[str], options: PubSubOptions = ...) -> StringArrayEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: list[str], options: PubSubOptions = ...) -> StringArrayEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> StringArrayPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> StringArrayPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: list[str], options: PubSubOptions = ...) -> StringArraySubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: list[str], options: PubSubOptions = ...) -> StringArraySubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class StringEntry(StringSubscriber, StringPublisher):
+    """
+    NetworkTables String entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> StringEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> StringTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class StringPublisher(Publisher):
+    """
+    NetworkTables String publisher.
+    """
+    def __enter__(self) -> StringPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> StringTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: str, time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: str) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class StringSubscriber(Subscriber):
+    """
+    NetworkTables String subscriber.
+    """
+    def __enter__(self) -> StringSubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> str:
+        """
+        Get the last published value.
+        If no value has been published, returns the stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: str) -> str:
+        """
+        Get the last published value.
+        If no value has been published, returns the passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedString:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published, returns the stored default value and a
+        timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: str) -> TimestampedString:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published, returns the passed defaultValue and a
+        timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> StringTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedString]:
+        """
+        Get an array of all value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no new changes have
+                  been published since the previous call.
+        """
+class StringTopic(Topic):
+    """
+    NetworkTables String topic.
+    """
+    kTypeString: typing.ClassVar[str] = 'string'
+    def __enter__(self) -> StringTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: str, options: PubSubOptions = ...) -> StringEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getEntryEx(self, typeString: str, defaultValue: str, options: PubSubOptions = ...) -> StringEntry:
+        """
+        Create a new entry for the topic, with specific type string.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> StringPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> StringPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: str, options: PubSubOptions = ...) -> StringSubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+    def subscribeEx(self, typeString: str, defaultValue: str, options: PubSubOptions = ...) -> StringSubscriber:
+        """
+        Create a new subscriber to the topic, with specific type string.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString:   type string
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class StructArrayEntry(StructArraySubscriber, StructArrayPublisher):
+    """
+    NetworkTables struct-encoded value array entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> StructArrayEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> StructArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class StructArrayPublisher(Publisher):
+    """
+    NetworkTables struct-encoded value array publisher.
+    """
+    def __enter__(self) -> StructArrayPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> StructArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: list[typing.Any], time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: list[typing.Any]) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class StructArraySubscriber(Subscriber):
+    """
+    NetworkTables struct-encoded value array subscriber.
+    """
+    def __enter__(self) -> StructArraySubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> list[typing.Any]:
+        """
+        Get the last published value.
+        If no value has been published or the value cannot be unpacked, returns the
+        stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: list[typing.Any]) -> list[typing.Any]:
+        """
+        Get the last published value.
+        If no value has been published or the value cannot be unpacked, returns the
+        passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedStructArray:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published or the value cannot be unpacked, returns the
+        stored default value and a timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: list[typing.Any]) -> TimestampedStructArray:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published or the value cannot be unpacked, returns the
+        passed defaultValue and a timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> StructArrayTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedStructArray]:
+        """
+        Get an array of all valid value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value. Values that cannot be unpacked
+        are dropped.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no valid new changes
+                  have been published since the previous call.
+        """
+class StructArrayTopic(Topic):
+    """
+    NetworkTables struct-encoded value array topic.
+    """
+    def __enter__(self) -> StructArrayTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic, type: type) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        :param type:  optional struct type info
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: list[typing.Any], options: PubSubOptions = ...) -> StructArrayEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> StructArrayPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, properties: wpiutil.json, options: PubSubOptions = ...) -> StructArrayPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: list[typing.Any], options: PubSubOptions = ...) -> StructArraySubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class StructEntry(StructSubscriber, StructPublisher):
+    """
+    NetworkTables struct-encoded value entry.
+    
+    .. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.
+    """
+    def __enter__(self) -> StructEntry:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the entry
+        """
+    def getTopic(self) -> StructTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def unpublish(self) -> None:
+        """
+        Stops publishing the entry if it's published.
+        """
+class StructPublisher(Publisher):
+    """
+    NetworkTables struct-encoded value publisher.
+    """
+    def __enter__(self) -> StructPublisher:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the publisher
+        """
+    def getTopic(self) -> StructTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def set(self, value: typing.Any, time: int = 0) -> None:
+        """
+        Publish a new value.
+        
+        :param value: value to publish
+        :param time:  timestamp; 0 indicates current NT time should be used
+        """
+    def setDefault(self, value: typing.Any) -> None:
+        """
+        Publish a default value.
+        On reconnect, a default value will never be used in preference to a
+        published value.
+        
+        :param value: value
+        """
+class StructSubscriber(Subscriber):
+    """
+    NetworkTables struct-encoded value subscriber.
+    """
+    def __enter__(self) -> StructSubscriber:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def close(self) -> None:
+        """
+        Destroys the subscriber
+        """
+    @typing.overload
+    def get(self) -> typing.Any:
+        """
+        Get the last published value.
+        If no value has been published or the value cannot be unpacked, returns the
+        stored default value.
+        
+        :returns: value
+        """
+    @typing.overload
+    def get(self, defaultValue: typing.Any) -> typing.Any:
+        """
+        Get the last published value.
+        If no value has been published or the value cannot be unpacked, returns the
+        passed defaultValue.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: value
+        """
+    @typing.overload
+    def getAtomic(self) -> TimestampedStruct:
+        """
+        Get the last published value along with its timestamp
+        If no value has been published or the value cannot be unpacked, returns the
+        stored default value and a timestamp of 0.
+        
+        :returns: timestamped value
+        """
+    @typing.overload
+    def getAtomic(self, defaultValue: typing.Any) -> TimestampedStruct:
+        """
+        Get the last published value along with its timestamp.
+        If no value has been published or the value cannot be unpacked, returns the
+        passed defaultValue and a timestamp of 0.
+        
+        :param defaultValue: default value to return if no value has been published
+        
+        :returns: timestamped value
+        """
+    def getTopic(self) -> StructTopic:
+        """
+        Get the corresponding topic.
+        
+        :returns: Topic
+        """
+    def readQueue(self) -> list[TimestampedStruct]:
+        """
+        Get an array of all valid value changes since the last call to ReadQueue.
+        Also provides a timestamp for each value. Values that cannot be unpacked
+        are dropped.
+        
+        .. note:: The "poll storage" subscribe option can be used to set the queue
+           depth.
+        
+        :returns: Array of timestamped values; empty array if no valid new changes
+                  have been published since the previous call.
+        """
+class StructTopic(Topic):
+    """
+    NetworkTables struct-encoded value topic.
+    """
+    def __enter__(self) -> StructTopic:
+        ...
+    def __exit__(self, *args) -> None:
+        ...
+    def __init__(self, topic: Topic, type: type) -> None:
+        """
+        Construct from a generic topic.
+        
+        :param topic: Topic
+        :param type:  optional struct type info
+        """
+    def close(self) -> None:
+        """
+        Destroys the topic
+        """
+    def getEntry(self, defaultValue: typing.Any, options: PubSubOptions = ...) -> StructEntry:
+        """
+        Create a new entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def publish(self, options: PubSubOptions = ...) -> StructPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish options
+        
+        :returns: publisher
+        """
+    def publishEx(self, properties: wpiutil.json, options: PubSubOptions = ...) -> StructPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def subscribe(self, defaultValue: typing.Any, options: PubSubOptions = ...) -> StructSubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param defaultValue: default value used when a default is not provided to a
+                             getter function
+        :param options:      subscribe options
+        
+        :returns: subscriber
+        """
+class Subscriber:
+    """
+    NetworkTables subscriber.
+    """
+    def exists(self) -> bool:
+        """
+        Determines if the topic is currently being published.
+        
+        :returns: True if the topic exists, false otherwise.
+        """
+    def getLastChange(self) -> int:
+        """
+        Gets the last time the value was changed.
+        Note: this is not atomic with Get(); use GetAtomic() to get
+        both the value and last change as an atomic operation.
+        
+        :returns: Topic last change time
+        """
+    def getTopic(self) -> Topic:
+        """
+        Gets the subscribed-to topic.
+        
+        :returns: Topic
+        """
+    @property
+    def _m_subHandle(self) -> int:
+        ...
+class TimeSyncEventData:
+    """
+    NetworkTables time sync event data.
+    """
+    def __init__(self, serverTimeOffset: int, rtt2: int, valid: bool) -> None:
+        ...
+    @property
+    def rtt2(self) -> int:
+        """
+        Measured round trip time divided by 2, in microseconds.
+        """
+    @rtt2.setter
+    def rtt2(self, arg0: int) -> None:
+        ...
+    @property
+    def serverTimeOffset(self) -> int:
+        """
+        Offset between local time and server time, in microseconds. Add this value
+        to local time to get the estimated equivalent server time.
+        """
+    @serverTimeOffset.setter
+    def serverTimeOffset(self, arg0: int) -> None:
+        ...
+    @property
+    def valid(self) -> bool:
+        """
+        If serverTimeOffset and RTT are valid. An event with this set to false is
+        sent when the client disconnects.
+        """
+    @valid.setter
+    def valid(self, arg0: bool) -> None:
+        ...
+class TimestampedBoolean:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: bool) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> bool:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: bool) -> None:
+        ...
+class TimestampedBooleanArray:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: list[int]) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> list[int]:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: list[int]) -> None:
+        ...
+class TimestampedDouble:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: float) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> float:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: float) -> None:
+        ...
+class TimestampedDoubleArray:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: list[float]) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> list[float]:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: list[float]) -> None:
+        ...
+class TimestampedFloat:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: float) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> float:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: float) -> None:
+        ...
+class TimestampedFloatArray:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: list[float]) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> list[float]:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: list[float]) -> None:
+        ...
+class TimestampedInteger:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: int) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> int:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: int) -> None:
+        ...
+class TimestampedIntegerArray:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: list[int]) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> list[int]:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: list[int]) -> None:
+        ...
+class TimestampedRaw:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: bytes) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> bytes:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: bytes) -> None:
+        ...
+class TimestampedString:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: str) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> str:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: str) -> None:
+        ...
+class TimestampedStringArray:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: list[str]) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> list[str]:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: list[str]) -> None:
+        ...
+class TimestampedStruct:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: typing.Any) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> typing.Any:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: typing.Any) -> None:
+        ...
+class TimestampedStructArray:
+    """
+    Timestamped value.
+    @ingroup ntcore_cpp_handle_api
+    """
+    @typing.overload
+    def __init__(self) -> None:
+        ...
+    @typing.overload
+    def __init__(self, time: int, serverTime: int, value: list[typing.Any]) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    @property
+    def serverTime(self) -> int:
+        """
+        Time in server time base.  May be 0 or 1 for locally set values.
+        """
+    @serverTime.setter
+    def serverTime(self, arg0: int) -> None:
+        ...
+    @property
+    def time(self) -> int:
+        """
+        Time in local time base.
+        """
+    @time.setter
+    def time(self, arg0: int) -> None:
+        ...
+    @property
+    def value(self) -> list[typing.Any]:
+        """
+        Value.
+        """
+    @value.setter
+    def value(self, arg0: list[typing.Any]) -> None:
+        ...
+class Topic:
+    """
+    NetworkTables Topic.
+    """
+    __hash__: typing.ClassVar[None] = None
+    def __eq__(self, arg0: Topic) -> bool:
+        """
+        Equality operator.  Returns true if both instances refer to the same
+        native handle.
+        """
+    def deleteProperty(self, name: str) -> None:
+        """
+        Deletes a property.  Has no effect if the property does not exist.
+        
+        :param name: property name
+        """
+    def exists(self) -> bool:
+        """
+        Determines if the topic is currently being published.
+        
+        :returns: True if the topic exists, false otherwise.
+        """
+    def genericPublish(self, typeString: str, options: PubSubOptions = ...) -> GenericPublisher:
+        """
+        Create a new publisher to the topic.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    def genericPublishEx(self, typeString: str, properties: wpiutil.json, options: PubSubOptions = ...) -> GenericPublisher:
+        """
+        Create a new publisher to the topic, with type string and initial
+        properties.
+        
+        The publisher is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: It is not possible to publish two different data types to the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored). To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param properties: JSON properties
+        :param options:    publish options
+        
+        :returns: publisher
+        """
+    @typing.overload
+    def genericSubscribe(self, options: PubSubOptions = ...) -> GenericSubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        :param options: subscribe options
+        
+        :returns: subscriber
+        """
+    @typing.overload
+    def genericSubscribe(self, typeString: str, options: PubSubOptions = ...) -> GenericSubscriber:
+        """
+        Create a new subscriber to the topic.
+        
+        The subscriber is only active as long as the returned object
+        is not destroyed.
+        
+        .. note:: Subscribers that do not match the published data type do not return
+           any values. To determine if the data type matches, use the appropriate
+           Topic functions.
+        
+        :param typeString: type string
+        :param options:    subscribe options
+        
+        :returns: subscriber
+        """
+    @typing.overload
+    def getGenericEntry(self, options: PubSubOptions = ...) -> GenericEntry:
+        """
+        Create a new generic entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param options: publish and/or subscribe options
+        
+        :returns: entry
+        """
+    @typing.overload
+    def getGenericEntry(self, typeString: str, options: PubSubOptions = ...) -> GenericEntry:
+        """
+        Create a new generic entry for the topic.
+        
+        Entries act as a combination of a subscriber and a weak publisher. The
+        subscriber is active as long as the entry is not destroyed. The publisher
+        is created when the entry is first written to, and remains active until
+        either Unpublish() is called or the entry is destroyed.
+        
+        .. note:: It is not possible to use two different data types with the same
+           topic. Conflicts between publishers are typically resolved by the
+           server on a first-come, first-served basis. Any published values that
+           do not match the topic's data type are dropped (ignored), and the entry
+           will show no new values if the data type does not match. To determine
+           if the data type matches, use the appropriate Topic functions.
+        
+        :param typeString: type string
+        :param options:    publish and/or subscribe options
+        
+        :returns: entry
+        """
+    def getInfo(self) -> TopicInfo:
+        """
+        Gets combined information about the topic.
+        
+        :returns: Topic information
+        """
+    def getInstance(self) -> NetworkTableInstance:
+        """
+        Gets the instance for the topic.
+        
+        :returns: Instance
+        """
+    def getName(self) -> str:
+        """
+        Gets the name of the topic.
+        
+        :returns: the topic's name
+        """
+    def getProperties(self) -> wpiutil.json:
+        """
+        Gets all topic properties as a JSON object.  Each key in the object
+        is the property name, and the corresponding value is the property value.
+        
+        :returns: JSON object
+        """
+    def getProperty(self, name: str) -> wpiutil.json:
+        """
+        Gets the current value of a property (as a JSON object).
+        
+        :param name: property name
+        
+        :returns: JSON object; null object if the property does not exist.
+        """
+    def getType(self) -> NetworkTableType:
+        """
+        Gets the type of the topic.
+        
+        :returns: the topic's type
+        """
+    def getTypeString(self) -> str:
+        """
+        Gets the type string of the topic. This may have more information
+        than the numeric type (especially for raw values).
+        
+        :returns: the topic's type
+        """
+    def isCached(self) -> bool:
+        """
+        Returns whether the topic's last value is stored.
+        
+        :returns: True if the topic is cached.
+        """
+    def isPersistent(self) -> bool:
+        """
+        Returns whether the value is persistent through server restarts.
+        
+        :returns: True if the value is persistent.
+        """
+    def isRetained(self) -> bool:
+        """
+        Returns whether the topic is retained by server when there are no
+        publishers.
+        
+        :returns: True if the topic is retained.
+        """
+    def setCached(self, cached: bool) -> None:
+        """
+        Allow storage of the topic's last value, allowing the value to be read (and
+        not just accessed through event queues and listeners).
+        
+        :param cached: True for cached, false for not cached.
+        """
+    def setPersistent(self, persistent: bool) -> None:
+        """
+        Make value persistent through server restarts.
+        
+        :param persistent: True for persistent, false for not persistent.
+        """
+    def setProperties(self, properties: wpiutil.json) -> bool:
+        """
+        Updates multiple topic properties.  Each key in the passed-in object is
+        the name of the property to add/update, and the corresponding value is the
+        property value to set for that property.  Null values result in deletion
+        of the corresponding property.
+        
+        :param properties: JSON object with keys to add/update/delete
+        
+        :returns: False if properties is not an object
+        """
+    def setProperty(self, name: str, value: wpiutil.json) -> None:
+        """
+        Sets a property value.
+        
+        :param name:  property name
+        :param value: property value
+        """
+    def setRetained(self, retained: bool) -> None:
+        """
+        Make the server retain the topic even when there are no publishers.
+        
+        :param retained: True for retained, false for not retained.
+        """
+class TopicInfo:
+    """
+    NetworkTables Topic Information
+    """
+    def __init__(self) -> None:
+        ...
+    def __repr__(self) -> str:
+        ...
+    def getProperties(self) -> wpiutil.json:
+        """
+        Get topic properties as a JSON object.
+        """
+    @property
+    def name(self) -> str:
+        """
+        Topic name
+        """
+    @name.setter
+    def name(self, arg0: str) -> None:
+        ...
+    @property
+    def properties(self) -> str:
+        """
+        Topic properties JSON string
+        """
+    @properties.setter
+    def properties(self, arg0: str) -> None:
+        ...
+    @property
+    def topic(self) -> Topic:
+        ...
+    @property
+    def type(self) -> NetworkTableType:
+        ...
+    @property
+    def type_str(self) -> str:
+        """
+        Topic type string
+        """
+    @type_str.setter
+    def type_str(self, arg0: str) -> None:
+        ...
+class Value:
+    """
+    A network table entry value.
+    @ingroup ntcore_cpp_api
+    """
+    @staticmethod
+    def getFactoryByType(type: NetworkTableType) -> typing.Callable:
+        ...
+    @staticmethod
+    def makeBoolean(value: bool, time: int = 0) -> Value:
+        """
+        Creates a boolean entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+        """
+    @staticmethod
+    def makeBooleanArray(value: list[bool], time: int = 0) -> Value:
+        """
+        Creates a boolean array entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+        """
+    @staticmethod
+    def makeDouble(value: float, time: int = 0) -> Value:
+        """
+        Creates a double entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+        """
+    @staticmethod
+    def makeDoubleArray(value: list[float], time: int = 0) -> Value:
+        """
+        Creates a double array entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+                  
+                  .. note:: This function moves the values out of the vector.
+        """
+    @staticmethod
+    def makeFloat(value: float, time: int = 0) -> Value:
+        """
+        Creates a float entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+        """
+    @staticmethod
+    def makeFloatArray(value: list[float], time: int = 0) -> Value:
+        """
+        Creates a float array entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+                  
+                  .. note:: This function moves the values out of the vector.
+        """
+    @staticmethod
+    def makeInteger(value: int, time: int = 0) -> Value:
+        """
+        Creates an integer entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+        """
+    @staticmethod
+    def makeIntegerArray(value: list[int], time: int = 0) -> Value:
+        """
+        Creates an integer array entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+                  
+                  .. note:: This function moves the values out of the vector.
+        """
+    @staticmethod
+    def makeRaw(value: typing_extensions.Buffer, time: int = 0) -> Value:
+        """
+        Creates a raw entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+        """
+    @staticmethod
+    def makeString(value: str, time: int = 0) -> Value:
+        """
+        Creates a string entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+        """
+    @staticmethod
+    def makeStringArray(value: list[str], time: int = 0) -> Value:
+        """
+        Creates a string array entry value.
+        
+        :param value: the value
+        :param time:  if nonzero, the creation time to use (instead of the current
+                      time)
+        
+        :returns: The entry value
+                  
+                  .. note:: This function moves the values out of the vector.
+        """
+    @staticmethod
+    def makeValue(value: typing.Any) -> Value:
+        ...
+    def __repr__(self) -> str:
+        ...
+    def getBoolean(self) -> bool:
+        """
+        Get the entry's boolean value.
+        
+        :returns: The boolean value.
+        """
+    def getBooleanArray(self) -> typing.Any:
+        """
+        Get the entry's boolean array value.
+        
+        :returns: The boolean array value.
+        """
+    def getDouble(self) -> float:
+        """
+        Get the entry's double value.
+        
+        :returns: The double value.
+        """
+    def getDoubleArray(self) -> list[float]:
+        """
+        Get the entry's double array value.
+        
+        :returns: The double array value.
+        """
+    def getFloat(self) -> float:
+        """
+        Get the entry's float value.
+        
+        :returns: The float value.
+        """
+    def getFloatArray(self) -> list[float]:
+        """
+        Get the entry's float array value.
+        
+        :returns: The float array value.
+        """
+    def getInteger(self) -> int:
+        """
+        Get the entry's integer value.
+        
+        :returns: The integer value.
+        """
+    def getIntegerArray(self) -> list[int]:
+        """
+        Get the entry's integer array value.
+        
+        :returns: The integer array value.
+        """
+    def getRaw(self) -> typing_extensions.Buffer:
+        """
+        Get the entry's raw value.
+        
+        :returns: The raw value.
+        """
+    def getString(self) -> str:
+        """
+        Get the entry's string value.
+        
+        :returns: The string value.
+        """
+    def getStringArray(self) -> list[str]:
+        """
+        Get the entry's string array value.
+        
+        :returns: The string array value.
+        """
+    def isBoolean(self) -> bool:
+        """
+        Determine if entry value contains a boolean.
+        
+        :returns: True if the entry value is of boolean type.
+        """
+    def isBooleanArray(self) -> bool:
+        """
+        Determine if entry value contains a boolean array.
+        
+        :returns: True if the entry value is of boolean array type.
+        """
+    def isDouble(self) -> bool:
+        """
+        Determine if entry value contains a double.
+        
+        :returns: True if the entry value is of double type.
+        """
+    def isDoubleArray(self) -> bool:
+        """
+        Determine if entry value contains a double array.
+        
+        :returns: True if the entry value is of double array type.
+        """
+    def isFloat(self) -> bool:
+        """
+        Determine if entry value contains a float.
+        
+        :returns: True if the entry value is of float type.
+        """
+    def isFloatArray(self) -> bool:
+        """
+        Determine if entry value contains a float array.
+        
+        :returns: True if the entry value is of float array type.
+        """
+    def isInteger(self) -> bool:
+        """
+        Determine if entry value contains an integer.
+        
+        :returns: True if the entry value is of integer type.
+        """
+    def isIntegerArray(self) -> bool:
+        """
+        Determine if entry value contains an integer array.
+        
+        :returns: True if the entry value is of integer array type.
+        """
+    def isRaw(self) -> bool:
+        """
+        Determine if entry value contains a raw.
+        
+        :returns: True if the entry value is of raw type.
+        """
+    def isString(self) -> bool:
+        """
+        Determine if entry value contains a string.
+        
+        :returns: True if the entry value is of string type.
+        """
+    def isStringArray(self) -> bool:
+        """
+        Determine if entry value contains a string array.
+        
+        :returns: True if the entry value is of string array type.
+        """
+    def isValid(self) -> bool:
+        """
+        Determine if entry value contains a value or is unassigned.
+        
+        :returns: True if the entry value contains a value.
+        """
+    def last_change(self) -> int:
+        """
+        Get the creation time of the value, in local time.
+        
+        :returns: The time, in the units returned by nt::Now().
+        """
+    def server_time(self) -> int:
+        """
+        Get the creation time of the value, in server time.
+        
+        :returns: The server time.
+        """
+    def setServerTime(self, time: int) -> None:
+        """
+        Set the creation time of the value, in server time.
+        
+        :param time: The server time.
+        """
+    def setTime(self, time: int) -> None:
+        """
+        Set the local creation time of the value.
+        
+        :param time: The time.
+        """
+    def size(self) -> int:
+        """
+        Get the approximate in-memory size of the value in bytes. This is zero for
+        values that do not require additional memory beyond the memory of the Value
+        itself.
+        
+        :returns: The size in bytes.
+        """
+    def time(self) -> int:
+        """
+        Get the creation time of the value, in local time.
+        
+        :returns: The time, in the units returned by nt::Now().
+        """
+    def type(self) -> NetworkTableType:
+        """
+        Get the data type.
+        
+        :returns: The type.
+        """
+    def value(self) -> typing.Any:
+        """
+        Get the data value stored.
+        
+        :returns: The type.
+        """
+class ValueEventData:
+    """
+    NetworkTables Value Event Data
+    """
+    def __repr__(self) -> str:
+        ...
+    @property
+    def topic(self) -> Topic:
+        ...
+    @property
+    def value(self) -> Value:
+        """
+        The new value.
+        """
+def _addPolledLogger(poller: int, min_level: int, max_level: int) -> int:
+    """
+    Set the log level for a log poller.  Events will only be generated for
+    log messages with level greater than or equal to min_level and less than or
+    equal to max_level; messages outside this range will be silently ignored.
+    
+    :param poller:    poller handle
+    :param min_level: minimum log level
+    :param max_level: maximum log level
+    
+    :returns: Logger handle
+    """
+def _now() -> int:
+    """
+    Returns monotonic current time in 1 us increments.
+    This is the same time base used for value and connection timestamps.
+    This function by default simply wraps wpi::Now(), but if SetNow() is
+    called, this function instead returns the value passed to SetNow();
+    this can be used to reduce overhead.
+    
+    :returns: Timestamp
+    """
+def _removeListener(listener: int) -> None:
+    """
+    Removes a listener.
+    
+    :param listener: Listener handle to remove
+    """
+def _setNow(timestamp: int) -> None:
+    """
+    Sets the current timestamp used for timestamping values that do not
+    provide a timestamp (e.g. a value of 0 is passed).  For consistency,
+    it also results in Now() returning the set value.  This should generally
+    be used only if the overhead of calling wpi::Now() is a concern.
+    If used, it should be called periodically with the value of wpi::Now().
+    
+    :param timestamp: timestamp (1 us increments)
+    """
+_st_cleanup: typing.Any  # value = <capsule object>
```

## ntcore/_ntcore/meta.pyi

 * *Ordering differences only*

```diff
@@ -1,98 +1,98 @@
-from __future__ import annotations
-import typing
-import typing_extensions
-__all__ = ['Client', 'ClientPublisher', 'ClientSubscriber', 'SubscriberOptions', 'TopicPublisher', 'TopicSubscriber', 'decodeClientPublishers', 'decodeClientSubscribers', 'decodeClients', 'decodeTopicPublishers', 'decodeTopicSubscribers']
-class Client:
-    """
-    Client (as published via `$clients`).
-    """
-    conn: str
-    id: str
-    version: int
-    def __init__(self) -> None:
-        ...
-class ClientPublisher:
-    """
-    Client publisher (as published via `$clientpub$<client>` or `$serverpub`).
-    """
-    topic: str
-    uid: int
-    def __init__(self) -> None:
-        ...
-class ClientSubscriber:
-    """
-    Client subscriber (as published via `$clientsub$<client>` or `$serversub`).
-    """
-    options: SubscriberOptions
-    topics: list[str]
-    uid: int
-    def __init__(self) -> None:
-        ...
-class SubscriberOptions:
-    """
-    Subscriber options. Different from PubSubOptions in this reflects only
-    options that are sent over the network.
-    """
-    periodic: float
-    prefixMatch: bool
-    sendAll: bool
-    topicsOnly: bool
-    def __init__(self) -> None:
-        ...
-class TopicPublisher:
-    """
-    Topic publisher (as published via `$pub$<topic>`).
-    """
-    client: str
-    pubuid: int
-    def __init__(self) -> None:
-        ...
-class TopicSubscriber:
-    """
-    Topic subscriber (as published via `$sub$<topic>`).
-    """
-    client: str
-    options: SubscriberOptions
-    subuid: int
-    def __init__(self) -> None:
-        ...
-def decodeClientPublishers(data: typing_extensions.Buffer) -> list[ClientPublisher] | None:
-    """
-    Decodes `$clientpub$<topic>` meta-topic data.
-    
-    :param data: data contents
-    
-    :returns: Vector of ClientPublishers, or empty optional on decoding error.
-    """
-def decodeClientSubscribers(data: typing_extensions.Buffer) -> list[ClientSubscriber] | None:
-    """
-    Decodes `$clientsub$<topic>` meta-topic data.
-    
-    :param data: data contents
-    
-    :returns: Vector of ClientSubscribers, or empty optional on decoding error.
-    """
-def decodeClients(data: typing_extensions.Buffer) -> list[Client] | None:
-    """
-    Decodes `$clients` meta-topic data.
-    
-    :param data: data contents
-    
-    :returns: Vector of Clients, or empty optional on decoding error.
-    """
-def decodeTopicPublishers(data: typing_extensions.Buffer) -> list[TopicPublisher] | None:
-    """
-    Decodes `$pub$<topic>` meta-topic data.
-    
-    :param data: data contents
-    
-    :returns: Vector of TopicPublishers, or empty optional on decoding error.
-    """
-def decodeTopicSubscribers(data: typing_extensions.Buffer) -> list[TopicSubscriber] | None:
-    """
-    Decodes `$sub$<topic>` meta-topic data.
-    
-    :param data: data contents
-    
-    :returns: Vector of TopicSubscribers, or empty optional on decoding error.
-    """
+from __future__ import annotations
+import typing
+import typing_extensions
+__all__ = ['Client', 'ClientPublisher', 'ClientSubscriber', 'SubscriberOptions', 'TopicPublisher', 'TopicSubscriber', 'decodeClientPublishers', 'decodeClientSubscribers', 'decodeClients', 'decodeTopicPublishers', 'decodeTopicSubscribers']
+class Client:
+    """
+    Client (as published via `$clients`).
+    """
+    conn: str
+    id: str
+    version: int
+    def __init__(self) -> None:
+        ...
+class ClientPublisher:
+    """
+    Client publisher (as published via `$clientpub$<client>` or `$serverpub`).
+    """
+    topic: str
+    uid: int
+    def __init__(self) -> None:
+        ...
+class ClientSubscriber:
+    """
+    Client subscriber (as published via `$clientsub$<client>` or `$serversub`).
+    """
+    options: SubscriberOptions
+    topics: list[str]
+    uid: int
+    def __init__(self) -> None:
+        ...
+class SubscriberOptions:
+    """
+    Subscriber options. Different from PubSubOptions in this reflects only
+    options that are sent over the network.
+    """
+    periodic: float
+    prefixMatch: bool
+    sendAll: bool
+    topicsOnly: bool
+    def __init__(self) -> None:
+        ...
+class TopicPublisher:
+    """
+    Topic publisher (as published via `$pub$<topic>`).
+    """
+    client: str
+    pubuid: int
+    def __init__(self) -> None:
+        ...
+class TopicSubscriber:
+    """
+    Topic subscriber (as published via `$sub$<topic>`).
+    """
+    client: str
+    options: SubscriberOptions
+    subuid: int
+    def __init__(self) -> None:
+        ...
+def decodeClientPublishers(data: typing_extensions.Buffer) -> list[ClientPublisher] | None:
+    """
+    Decodes `$clientpub$<topic>` meta-topic data.
+    
+    :param data: data contents
+    
+    :returns: Vector of ClientPublishers, or empty optional on decoding error.
+    """
+def decodeClientSubscribers(data: typing_extensions.Buffer) -> list[ClientSubscriber] | None:
+    """
+    Decodes `$clientsub$<topic>` meta-topic data.
+    
+    :param data: data contents
+    
+    :returns: Vector of ClientSubscribers, or empty optional on decoding error.
+    """
+def decodeClients(data: typing_extensions.Buffer) -> list[Client] | None:
+    """
+    Decodes `$clients` meta-topic data.
+    
+    :param data: data contents
+    
+    :returns: Vector of Clients, or empty optional on decoding error.
+    """
+def decodeTopicPublishers(data: typing_extensions.Buffer) -> list[TopicPublisher] | None:
+    """
+    Decodes `$pub$<topic>` meta-topic data.
+    
+    :param data: data contents
+    
+    :returns: Vector of TopicPublishers, or empty optional on decoding error.
+    """
+def decodeTopicSubscribers(data: typing_extensions.Buffer) -> list[TopicSubscriber] | None:
+    """
+    Decodes `$sub$<topic>` meta-topic data.
+    
+    :param data: data contents
+    
+    :returns: Vector of TopicSubscribers, or empty optional on decoding error.
+    """
```

## ntcore/meta/__init__.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-# autogenerated by 'robotpy-build create-imports ntcore.meta ntcore._ntcore.meta'
-from .._ntcore.meta import (
-    Client,
-    ClientPublisher,
-    ClientSubscriber,
-    SubscriberOptions,
-    TopicPublisher,
-    TopicSubscriber,
-    decodeClientPublishers,
-    decodeClientSubscribers,
-    decodeClients,
-    decodeTopicPublishers,
-    decodeTopicSubscribers,
-)
-
-__all__ = [
-    "Client",
-    "ClientPublisher",
-    "ClientSubscriber",
-    "SubscriberOptions",
-    "TopicPublisher",
-    "TopicSubscriber",
-    "decodeClientPublishers",
-    "decodeClientSubscribers",
-    "decodeClients",
-    "decodeTopicPublishers",
-    "decodeTopicSubscribers",
-]
+# autogenerated by 'robotpy-build create-imports ntcore.meta ntcore._ntcore.meta'
+from .._ntcore.meta import (
+    Client,
+    ClientPublisher,
+    ClientSubscriber,
+    SubscriberOptions,
+    TopicPublisher,
+    TopicSubscriber,
+    decodeClientPublishers,
+    decodeClientSubscribers,
+    decodeClients,
+    decodeTopicPublishers,
+    decodeTopicSubscribers,
+)
+
+__all__ = [
+    "Client",
+    "ClientPublisher",
+    "ClientSubscriber",
+    "SubscriberOptions",
+    "TopicPublisher",
+    "TopicSubscriber",
+    "decodeClientPublishers",
+    "decodeClientSubscribers",
+    "decodeClients",
+    "decodeTopicPublishers",
+    "decodeTopicSubscribers",
+]
```

## ntcore/rpy-include/rpygen/StructArrayTopic_tmpl1.cpp

```diff
@@ -1,50 +1,50 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <networktables\StructArrayTopic.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-#define RPYGEN_ENABLE_nt__StructArraySubscriber_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructArraySubscriber.hpp>
-
-#define RPYGEN_ENABLE_nt__StructArrayPublisher_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructArrayPublisher.hpp>
-
-
-#include <rpygen/nt__StructArraySubscriber.hpp>
-#include "StructArrayTopic_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__StructArraySubscriber<WPyStruct, WPyStructInfo>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__StructArraySubscriber_0::bind_nt__StructArraySubscriber_0(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__StructArraySubscriber_0::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <networktables/StructArrayTopic.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+#define RPYGEN_ENABLE_nt__StructArraySubscriber_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructArraySubscriber.hpp>
+
+#define RPYGEN_ENABLE_nt__StructArrayPublisher_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructArrayPublisher.hpp>
+
+
+#include <rpygen/nt__StructArraySubscriber.hpp>
+#include "StructArrayTopic_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__StructArraySubscriber<WPyStruct, WPyStructInfo>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__StructArraySubscriber_0::bind_nt__StructArraySubscriber_0(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__StructArraySubscriber_0::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/StructArrayTopic_tmpl2.cpp

```diff
@@ -1,50 +1,50 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <networktables\StructArrayTopic.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-#define RPYGEN_ENABLE_nt__StructArraySubscriber_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructArraySubscriber.hpp>
-
-#define RPYGEN_ENABLE_nt__StructArrayPublisher_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructArrayPublisher.hpp>
-
-
-#include <rpygen/nt__StructArrayPublisher.hpp>
-#include "StructArrayTopic_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__StructArrayPublisher<WPyStruct, WPyStructInfo>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__StructArrayPublisher_1::bind_nt__StructArrayPublisher_1(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__StructArrayPublisher_1::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <networktables/StructArrayTopic.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+#define RPYGEN_ENABLE_nt__StructArraySubscriber_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructArraySubscriber.hpp>
+
+#define RPYGEN_ENABLE_nt__StructArrayPublisher_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructArrayPublisher.hpp>
+
+
+#include <rpygen/nt__StructArrayPublisher.hpp>
+#include "StructArrayTopic_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__StructArrayPublisher<WPyStruct, WPyStructInfo>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__StructArrayPublisher_1::bind_nt__StructArrayPublisher_1(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__StructArrayPublisher_1::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/StructArrayTopic_tmpl3.cpp

```diff
@@ -1,50 +1,50 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <networktables\StructArrayTopic.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-#define RPYGEN_ENABLE_nt__StructArraySubscriber_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructArraySubscriber.hpp>
-
-#define RPYGEN_ENABLE_nt__StructArrayPublisher_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructArrayPublisher.hpp>
-
-
-#include <rpygen/nt__StructArrayEntry.hpp>
-#include "StructArrayTopic_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__StructArrayEntry<WPyStruct, WPyStructInfo>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__StructArrayEntry_2::bind_nt__StructArrayEntry_2(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__StructArrayEntry_2::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <networktables/StructArrayTopic.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+#define RPYGEN_ENABLE_nt__StructArraySubscriber_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructArraySubscriber.hpp>
+
+#define RPYGEN_ENABLE_nt__StructArrayPublisher_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructArrayPublisher.hpp>
+
+
+#include <rpygen/nt__StructArrayEntry.hpp>
+#include "StructArrayTopic_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__StructArrayEntry<WPyStruct, WPyStructInfo>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__StructArrayEntry_2::bind_nt__StructArrayEntry_2(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__StructArrayEntry_2::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/StructArrayTopic_tmpl4.cpp

```diff
@@ -1,50 +1,50 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <networktables\StructArrayTopic.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-#define RPYGEN_ENABLE_nt__StructArraySubscriber_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructArraySubscriber.hpp>
-
-#define RPYGEN_ENABLE_nt__StructArrayPublisher_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructArrayPublisher.hpp>
-
-
-#include <rpygen/nt__StructArrayTopic.hpp>
-#include "StructArrayTopic_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__StructArrayTopic<WPyStruct, WPyStructInfo>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__StructArrayTopic_3::bind_nt__StructArrayTopic_3(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__StructArrayTopic_3::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <networktables/StructArrayTopic.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+#define RPYGEN_ENABLE_nt__StructArraySubscriber_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructArraySubscriber.hpp>
+
+#define RPYGEN_ENABLE_nt__StructArrayPublisher_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructArrayPublisher.hpp>
+
+
+#include <rpygen/nt__StructArrayTopic.hpp>
+#include "StructArrayTopic_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__StructArrayTopic<WPyStruct, WPyStructInfo>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__StructArrayTopic_3::bind_nt__StructArrayTopic_3(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__StructArrayTopic_3::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/StructTopic_tmpl1.cpp

```diff
@@ -1,48 +1,48 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <networktables\StructTopic.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-#define RPYGEN_ENABLE_nt__StructSubscriber_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructSubscriber.hpp>
-
-#define RPYGEN_ENABLE_nt__StructPublisher_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructPublisher.hpp>
-
-
-#include <rpygen/nt__StructSubscriber.hpp>
-#include "StructTopic_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__StructSubscriber<WPyStruct, WPyStructInfo>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__StructSubscriber_0::bind_nt__StructSubscriber_0(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__StructSubscriber_0::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <networktables/StructTopic.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+#define RPYGEN_ENABLE_nt__StructSubscriber_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructSubscriber.hpp>
+
+#define RPYGEN_ENABLE_nt__StructPublisher_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructPublisher.hpp>
+
+
+#include <rpygen/nt__StructSubscriber.hpp>
+#include "StructTopic_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__StructSubscriber<WPyStruct, WPyStructInfo>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__StructSubscriber_0::bind_nt__StructSubscriber_0(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__StructSubscriber_0::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/StructTopic_tmpl2.cpp

```diff
@@ -1,48 +1,48 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <networktables\StructTopic.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-#define RPYGEN_ENABLE_nt__StructSubscriber_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructSubscriber.hpp>
-
-#define RPYGEN_ENABLE_nt__StructPublisher_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructPublisher.hpp>
-
-
-#include <rpygen/nt__StructPublisher.hpp>
-#include "StructTopic_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__StructPublisher<WPyStruct, WPyStructInfo>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__StructPublisher_1::bind_nt__StructPublisher_1(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__StructPublisher_1::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <networktables/StructTopic.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+#define RPYGEN_ENABLE_nt__StructSubscriber_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructSubscriber.hpp>
+
+#define RPYGEN_ENABLE_nt__StructPublisher_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructPublisher.hpp>
+
+
+#include <rpygen/nt__StructPublisher.hpp>
+#include "StructTopic_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__StructPublisher<WPyStruct, WPyStructInfo>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__StructPublisher_1::bind_nt__StructPublisher_1(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__StructPublisher_1::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/StructTopic_tmpl3.cpp

```diff
@@ -1,48 +1,48 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <networktables\StructTopic.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-#define RPYGEN_ENABLE_nt__StructSubscriber_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructSubscriber.hpp>
-
-#define RPYGEN_ENABLE_nt__StructPublisher_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructPublisher.hpp>
-
-
-#include <rpygen/nt__StructEntry.hpp>
-#include "StructTopic_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__StructEntry<WPyStruct, WPyStructInfo>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__StructEntry_2::bind_nt__StructEntry_2(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__StructEntry_2::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <networktables/StructTopic.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+#define RPYGEN_ENABLE_nt__StructSubscriber_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructSubscriber.hpp>
+
+#define RPYGEN_ENABLE_nt__StructPublisher_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructPublisher.hpp>
+
+
+#include <rpygen/nt__StructEntry.hpp>
+#include "StructTopic_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__StructEntry<WPyStruct, WPyStructInfo>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__StructEntry_2::bind_nt__StructEntry_2(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__StructEntry_2::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/StructTopic_tmpl4.cpp

```diff
@@ -1,48 +1,48 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <networktables\StructTopic.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-#define RPYGEN_ENABLE_nt__StructSubscriber_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructSubscriber.hpp>
-
-#define RPYGEN_ENABLE_nt__StructPublisher_PROTECTED_CONSTRUCTORS
-#include <rpygen/nt__StructPublisher.hpp>
-
-
-#include <rpygen/nt__StructTopic.hpp>
-#include "StructTopic_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__StructTopic<WPyStruct, WPyStructInfo>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__StructTopic_3::bind_nt__StructTopic_3(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__StructTopic_3::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <networktables/StructTopic.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+#define RPYGEN_ENABLE_nt__StructSubscriber_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructSubscriber.hpp>
+
+#define RPYGEN_ENABLE_nt__StructPublisher_PROTECTED_CONSTRUCTORS
+#include <rpygen/nt__StructPublisher.hpp>
+
+
+#include <rpygen/nt__StructTopic.hpp>
+#include "StructTopic_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__StructTopic<WPyStruct, WPyStructInfo>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__StructTopic_3::bind_nt__StructTopic_3(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__StructTopic_3::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/nt__BooleanArrayPublisher.hpp

```diff
@@ -1,105 +1,105 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\BooleanArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__BooleanArrayPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::BooleanArrayPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__BooleanArrayPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__BooleanArrayPublisher : PyTrampolineBase_nt__BooleanArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__BooleanArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__BooleanArrayPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::BooleanArrayPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::BooleanArrayPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::BooleanArrayPublisher::ParamType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::BooleanArrayPublisher::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::BooleanArrayPublisher::SmallElemType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::BooleanArrayPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/BooleanArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__BooleanArrayPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::BooleanArrayPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__BooleanArrayPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__BooleanArrayPublisher : PyTrampolineBase_nt__BooleanArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__BooleanArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__BooleanArrayPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::BooleanArrayPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::BooleanArrayPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::BooleanArrayPublisher::ParamType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::BooleanArrayPublisher::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::BooleanArrayPublisher::SmallElemType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::BooleanArrayPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__BooleanArraySubscriber.hpp

```diff
@@ -1,107 +1,107 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\BooleanArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__BooleanArraySubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::BooleanArraySubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__BooleanArraySubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__BooleanArraySubscriber : PyTrampolineBase_nt__BooleanArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__BooleanArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__BooleanArraySubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::BooleanArraySubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::BooleanArraySubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::BooleanArraySubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::BooleanArraySubscriber::TimestampedValueType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::BooleanArraySubscriber::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::BooleanArraySubscriber::SmallElemType;
-
-    using TimestampedValueViewType [[maybe_unused]] = typename nt::BooleanArraySubscriber::TimestampedValueViewType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/BooleanArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__BooleanArraySubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::BooleanArraySubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__BooleanArraySubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__BooleanArraySubscriber : PyTrampolineBase_nt__BooleanArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__BooleanArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__BooleanArraySubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::BooleanArraySubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::BooleanArraySubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::BooleanArraySubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::BooleanArraySubscriber::TimestampedValueType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::BooleanArraySubscriber::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::BooleanArraySubscriber::SmallElemType;
+
+    using TimestampedValueViewType [[maybe_unused]] = typename nt::BooleanArraySubscriber::TimestampedValueViewType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__BooleanPublisher.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\BooleanTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__BooleanPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::BooleanPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__BooleanPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__BooleanPublisher : PyTrampolineBase_nt__BooleanPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__BooleanPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__BooleanPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::BooleanPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::BooleanPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::BooleanPublisher::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::BooleanPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/BooleanTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__BooleanPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::BooleanPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__BooleanPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__BooleanPublisher : PyTrampolineBase_nt__BooleanPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__BooleanPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__BooleanPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::BooleanPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::BooleanPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::BooleanPublisher::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::BooleanPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__BooleanSubscriber.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\BooleanTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__BooleanSubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::BooleanSubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__BooleanSubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__BooleanSubscriber : PyTrampolineBase_nt__BooleanSubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__BooleanSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__BooleanSubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::BooleanSubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::BooleanSubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::BooleanSubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::BooleanSubscriber::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/BooleanTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__BooleanSubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::BooleanSubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__BooleanSubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__BooleanSubscriber : PyTrampolineBase_nt__BooleanSubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__BooleanSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__BooleanSubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::BooleanSubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::BooleanSubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::BooleanSubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::BooleanSubscriber::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__DoubleArrayPublisher.hpp

```diff
@@ -1,105 +1,105 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\DoubleArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__DoubleArrayPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::DoubleArrayPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__DoubleArrayPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__DoubleArrayPublisher : PyTrampolineBase_nt__DoubleArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__DoubleArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__DoubleArrayPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::DoubleArrayPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::DoubleArrayPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::DoubleArrayPublisher::ParamType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::DoubleArrayPublisher::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::DoubleArrayPublisher::SmallElemType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::DoubleArrayPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/DoubleArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__DoubleArrayPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::DoubleArrayPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__DoubleArrayPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__DoubleArrayPublisher : PyTrampolineBase_nt__DoubleArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__DoubleArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__DoubleArrayPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::DoubleArrayPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::DoubleArrayPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::DoubleArrayPublisher::ParamType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::DoubleArrayPublisher::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::DoubleArrayPublisher::SmallElemType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::DoubleArrayPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__DoubleArraySubscriber.hpp

```diff
@@ -1,107 +1,107 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\DoubleArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__DoubleArraySubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::DoubleArraySubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__DoubleArraySubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__DoubleArraySubscriber : PyTrampolineBase_nt__DoubleArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__DoubleArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__DoubleArraySubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::DoubleArraySubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::DoubleArraySubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::DoubleArraySubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::DoubleArraySubscriber::TimestampedValueType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::DoubleArraySubscriber::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::DoubleArraySubscriber::SmallElemType;
-
-    using TimestampedValueViewType [[maybe_unused]] = typename nt::DoubleArraySubscriber::TimestampedValueViewType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/DoubleArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__DoubleArraySubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::DoubleArraySubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__DoubleArraySubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__DoubleArraySubscriber : PyTrampolineBase_nt__DoubleArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__DoubleArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__DoubleArraySubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::DoubleArraySubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::DoubleArraySubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::DoubleArraySubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::DoubleArraySubscriber::TimestampedValueType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::DoubleArraySubscriber::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::DoubleArraySubscriber::SmallElemType;
+
+    using TimestampedValueViewType [[maybe_unused]] = typename nt::DoubleArraySubscriber::TimestampedValueViewType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__DoublePublisher.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\DoubleTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__DoublePublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::DoublePublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__DoublePublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__DoublePublisher : PyTrampolineBase_nt__DoublePublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__DoublePublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__DoublePublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::DoublePublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::DoublePublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::DoublePublisher::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::DoublePublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/DoubleTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__DoublePublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::DoublePublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__DoublePublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__DoublePublisher : PyTrampolineBase_nt__DoublePublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__DoublePublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__DoublePublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::DoublePublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::DoublePublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::DoublePublisher::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::DoublePublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__DoubleSubscriber.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\DoubleTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__DoubleSubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::DoubleSubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__DoubleSubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__DoubleSubscriber : PyTrampolineBase_nt__DoubleSubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__DoubleSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__DoubleSubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::DoubleSubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::DoubleSubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::DoubleSubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::DoubleSubscriber::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/DoubleTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__DoubleSubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::DoubleSubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__DoubleSubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__DoubleSubscriber : PyTrampolineBase_nt__DoubleSubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__DoubleSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__DoubleSubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::DoubleSubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::DoubleSubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::DoubleSubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::DoubleSubscriber::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__FloatArrayPublisher.hpp

```diff
@@ -1,105 +1,105 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\FloatArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__FloatArrayPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::FloatArrayPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__FloatArrayPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__FloatArrayPublisher : PyTrampolineBase_nt__FloatArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__FloatArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__FloatArrayPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::FloatArrayPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::FloatArrayPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::FloatArrayPublisher::ParamType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::FloatArrayPublisher::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::FloatArrayPublisher::SmallElemType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::FloatArrayPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/FloatArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__FloatArrayPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::FloatArrayPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__FloatArrayPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__FloatArrayPublisher : PyTrampolineBase_nt__FloatArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__FloatArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__FloatArrayPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::FloatArrayPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::FloatArrayPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::FloatArrayPublisher::ParamType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::FloatArrayPublisher::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::FloatArrayPublisher::SmallElemType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::FloatArrayPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__FloatArraySubscriber.hpp

```diff
@@ -1,107 +1,107 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\FloatArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__FloatArraySubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::FloatArraySubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__FloatArraySubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__FloatArraySubscriber : PyTrampolineBase_nt__FloatArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__FloatArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__FloatArraySubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::FloatArraySubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::FloatArraySubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::FloatArraySubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::FloatArraySubscriber::TimestampedValueType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::FloatArraySubscriber::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::FloatArraySubscriber::SmallElemType;
-
-    using TimestampedValueViewType [[maybe_unused]] = typename nt::FloatArraySubscriber::TimestampedValueViewType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/FloatArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__FloatArraySubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::FloatArraySubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__FloatArraySubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__FloatArraySubscriber : PyTrampolineBase_nt__FloatArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__FloatArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__FloatArraySubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::FloatArraySubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::FloatArraySubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::FloatArraySubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::FloatArraySubscriber::TimestampedValueType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::FloatArraySubscriber::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::FloatArraySubscriber::SmallElemType;
+
+    using TimestampedValueViewType [[maybe_unused]] = typename nt::FloatArraySubscriber::TimestampedValueViewType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__FloatPublisher.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\FloatTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__FloatPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::FloatPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__FloatPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__FloatPublisher : PyTrampolineBase_nt__FloatPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__FloatPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__FloatPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::FloatPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::FloatPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::FloatPublisher::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::FloatPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/FloatTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__FloatPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::FloatPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__FloatPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__FloatPublisher : PyTrampolineBase_nt__FloatPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__FloatPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__FloatPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::FloatPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::FloatPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::FloatPublisher::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::FloatPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__FloatSubscriber.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\FloatTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__FloatSubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::FloatSubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__FloatSubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__FloatSubscriber : PyTrampolineBase_nt__FloatSubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__FloatSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__FloatSubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::FloatSubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::FloatSubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::FloatSubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::FloatSubscriber::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/FloatTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__FloatSubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::FloatSubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__FloatSubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__FloatSubscriber : PyTrampolineBase_nt__FloatSubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__FloatSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__FloatSubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::FloatSubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::FloatSubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::FloatSubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::FloatSubscriber::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__GenericPublisher.hpp

```diff
@@ -1,103 +1,103 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\GenericEntry.h>
-
-
-#include <src/nt_type_caster.h>
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__GenericPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::GenericPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__GenericPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__GenericPublisher : PyTrampolineBase_nt__GenericPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__GenericPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__GenericPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::GenericPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::GenericPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::GenericPublisher::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::GenericPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/GenericEntry.h>
+
+
+#include <src/nt_type_caster.h>
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__GenericPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::GenericPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__GenericPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__GenericPublisher : PyTrampolineBase_nt__GenericPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__GenericPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__GenericPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::GenericPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::GenericPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::GenericPublisher::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::GenericPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__GenericSubscriber.hpp

```diff
@@ -1,103 +1,103 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\GenericEntry.h>
-
-
-#include <src/nt_type_caster.h>
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__GenericSubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::GenericSubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__GenericSubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__GenericSubscriber : PyTrampolineBase_nt__GenericSubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__GenericSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__GenericSubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::GenericSubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::GenericSubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::GenericSubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::GenericSubscriber::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/GenericEntry.h>
+
+
+#include <src/nt_type_caster.h>
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__GenericSubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::GenericSubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__GenericSubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__GenericSubscriber : PyTrampolineBase_nt__GenericSubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__GenericSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__GenericSubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::GenericSubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::GenericSubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::GenericSubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::GenericSubscriber::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__IntegerArrayPublisher.hpp

```diff
@@ -1,105 +1,105 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\IntegerArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__IntegerArrayPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::IntegerArrayPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__IntegerArrayPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__IntegerArrayPublisher : PyTrampolineBase_nt__IntegerArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__IntegerArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__IntegerArrayPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::IntegerArrayPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::IntegerArrayPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::IntegerArrayPublisher::ParamType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::IntegerArrayPublisher::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::IntegerArrayPublisher::SmallElemType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::IntegerArrayPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/IntegerArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__IntegerArrayPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::IntegerArrayPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__IntegerArrayPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__IntegerArrayPublisher : PyTrampolineBase_nt__IntegerArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__IntegerArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__IntegerArrayPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::IntegerArrayPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::IntegerArrayPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::IntegerArrayPublisher::ParamType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::IntegerArrayPublisher::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::IntegerArrayPublisher::SmallElemType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::IntegerArrayPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__IntegerArraySubscriber.hpp

```diff
@@ -1,107 +1,107 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\IntegerArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__IntegerArraySubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::IntegerArraySubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__IntegerArraySubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__IntegerArraySubscriber : PyTrampolineBase_nt__IntegerArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__IntegerArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__IntegerArraySubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::IntegerArraySubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::IntegerArraySubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::IntegerArraySubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::IntegerArraySubscriber::TimestampedValueType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::IntegerArraySubscriber::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::IntegerArraySubscriber::SmallElemType;
-
-    using TimestampedValueViewType [[maybe_unused]] = typename nt::IntegerArraySubscriber::TimestampedValueViewType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/IntegerArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__IntegerArraySubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::IntegerArraySubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__IntegerArraySubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__IntegerArraySubscriber : PyTrampolineBase_nt__IntegerArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__IntegerArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__IntegerArraySubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::IntegerArraySubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::IntegerArraySubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::IntegerArraySubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::IntegerArraySubscriber::TimestampedValueType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::IntegerArraySubscriber::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::IntegerArraySubscriber::SmallElemType;
+
+    using TimestampedValueViewType [[maybe_unused]] = typename nt::IntegerArraySubscriber::TimestampedValueViewType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__IntegerPublisher.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\IntegerTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__IntegerPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::IntegerPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__IntegerPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__IntegerPublisher : PyTrampolineBase_nt__IntegerPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__IntegerPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__IntegerPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::IntegerPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::IntegerPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::IntegerPublisher::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::IntegerPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/IntegerTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__IntegerPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::IntegerPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__IntegerPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__IntegerPublisher : PyTrampolineBase_nt__IntegerPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__IntegerPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__IntegerPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::IntegerPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::IntegerPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::IntegerPublisher::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::IntegerPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__IntegerSubscriber.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\IntegerTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__IntegerSubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::IntegerSubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__IntegerSubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__IntegerSubscriber : PyTrampolineBase_nt__IntegerSubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__IntegerSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__IntegerSubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::IntegerSubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::IntegerSubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::IntegerSubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::IntegerSubscriber::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/IntegerTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__IntegerSubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::IntegerSubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__IntegerSubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__IntegerSubscriber : PyTrampolineBase_nt__IntegerSubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__IntegerSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__IntegerSubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::IntegerSubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::IntegerSubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::IntegerSubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::IntegerSubscriber::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__NTSendable.hpp

```diff
@@ -1,149 +1,149 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\NTSendable.h>
-
-
-#include <networktables/NTSendableBuilder.h>
-
-
-
-
-
-
-
-
-
-#include <rpygen/wpi__Sendable.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__NTSendable :
-
-
-    PyTrampolineCfg_wpi__Sendable<
-
-CfgBase
->
-
-{
-    using Base = nt::NTSendable;
-
-    
-    
-    using override_base_InitSendable_RTNTSendableBuilder = nt::NTSendable;
-    
-    using override_base_InitSendable_RTSendableBuilder = nt::NTSendable;
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__NTSendable =
-
-    PyTrampoline_wpi__Sendable<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__NTSendable : PyTrampolineBase_nt__NTSendable<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__NTSendable<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__NTSendable;
-
-
-
-
-
-
-
-
-
-
-
-    
-    
-#ifndef RPYGEN_DISABLE_InitSendable_RTNTSendableBuilder
-    void InitSendable(NTSendableBuilder& builder) override {
-    
-    
-    
-    
-        auto custom_fn = [&](py::function fn) {
-  auto builderHandle = py::cast(builder, py::return_value_policy::reference);
-  fn(builderHandle);
-}
-;
-    
-        using LookupBase = typename PyTrampolineCfg::Base;
-    
-    
-        RPYBUILD_OVERRIDE_PURE_CUSTOM_NAME(NTSendable, PYBIND11_TYPE(void), LookupBase,
-            "initSendable", InitSendable, builder);
-    
-    
-    
-    }
-#endif
-
-    
-#ifndef RPYGEN_DISABLE_InitSendable_RTSendableBuilder
-    void InitSendable(wpi::SendableBuilder& builder) override {
-    
-    
-    
-    
-        auto custom_fn = [&](py::function fn) {
-  auto builderHandle = py::cast(builder, py::return_value_policy::reference);
-  fn(builderHandle);
-}
-;
-    
-        using LookupBase = typename PyTrampolineCfg::Base;
-    
-    
-        using CxxCallBase = typename PyTrampolineCfg::override_base_InitSendable_RTSendableBuilder;
-        RPYBUILD_OVERRIDE_CUSTOM_IMPL(PYBIND11_TYPE(void), LookupBase,
-            "initSendable", InitSendable, builder);
-        return CxxCallBase::InitSendable(std::forward<decltype(builder)>(builder));
-    
-    
-    
-    }
-#endif
-
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/NTSendable.h>
+
+
+#include <networktables/NTSendableBuilder.h>
+
+
+
+
+
+
+
+
+
+#include <rpygen/wpi__Sendable.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__NTSendable :
+
+
+    PyTrampolineCfg_wpi__Sendable<
+
+CfgBase
+>
+
+{
+    using Base = nt::NTSendable;
+
+    
+    
+    using override_base_InitSendable_RTNTSendableBuilder = nt::NTSendable;
+    
+    using override_base_InitSendable_RTSendableBuilder = nt::NTSendable;
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__NTSendable =
+
+    PyTrampoline_wpi__Sendable<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__NTSendable : PyTrampolineBase_nt__NTSendable<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__NTSendable<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__NTSendable;
+
+
+
+
+
+
+
+
+
+
+
+    
+    
+#ifndef RPYGEN_DISABLE_InitSendable_RTNTSendableBuilder
+    void InitSendable(NTSendableBuilder& builder) override {
+    
+    
+    
+    
+        auto custom_fn = [&](py::function fn) {
+  auto builderHandle = py::cast(builder, py::return_value_policy::reference);
+  fn(builderHandle);
+}
+;
+    
+        using LookupBase = typename PyTrampolineCfg::Base;
+    
+    
+        RPYBUILD_OVERRIDE_PURE_CUSTOM_NAME(NTSendable, PYBIND11_TYPE(void), LookupBase,
+            "initSendable", InitSendable, builder);
+    
+    
+    
+    }
+#endif
+
+    
+#ifndef RPYGEN_DISABLE_InitSendable_RTSendableBuilder
+    void InitSendable(wpi::SendableBuilder& builder) override {
+    
+    
+    
+    
+        auto custom_fn = [&](py::function fn) {
+  auto builderHandle = py::cast(builder, py::return_value_policy::reference);
+  fn(builderHandle);
+}
+;
+    
+        using LookupBase = typename PyTrampolineCfg::Base;
+    
+    
+        using CxxCallBase = typename PyTrampolineCfg::override_base_InitSendable_RTSendableBuilder;
+        RPYBUILD_OVERRIDE_CUSTOM_IMPL(PYBIND11_TYPE(void), LookupBase,
+            "initSendable", InitSendable, builder);
+        return CxxCallBase::InitSendable(std::forward<decltype(builder)>(builder));
+    
+    
+    
+    }
+#endif
+
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__NTSendableBuilder.hpp

```diff
@@ -1,177 +1,177 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\NTSendableBuilder.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/wpi__SendableBuilder.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__NTSendableBuilder :
-
-
-    PyTrampolineCfg_wpi__SendableBuilder<
-
-CfgBase
->
-
-{
-    using Base = nt::NTSendableBuilder;
-
-    
-    
-    using override_base_SetUpdateTable_Tunique_function = nt::NTSendableBuilder;
-    
-    using override_base_GetTopic_Tstring_view = nt::NTSendableBuilder;
-    
-    using override_base_GetTable_v = nt::NTSendableBuilder;
-    
-    using override_base_KGetBackendKind_v = nt::NTSendableBuilder;
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__NTSendableBuilder =
-
-    PyTrampoline_wpi__SendableBuilder<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__NTSendableBuilder : PyTrampolineBase_nt__NTSendableBuilder<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__NTSendableBuilder<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__NTSendableBuilder;
-
-
-
-
-
-    using BackendKind = wpi::SendableBuilder::BackendKind;
-
-
-
-
-
-
-
-    
-    
-#ifndef RPYGEN_DISABLE_SetUpdateTable_Tunique_function
-    void SetUpdateTable(wpi::unique_function<void ()> func) override {
-    
-    
-    
-    
-        using LookupBase = typename PyTrampolineCfg::Base;
-    
-    
-        RPYBUILD_OVERRIDE_PURE_NAME(NTSendableBuilder, PYBIND11_TYPE(void), LookupBase,
-            "setUpdateTable", SetUpdateTable, func);
-    
-    
-    
-    }
-#endif
-
-    
-#ifndef RPYGEN_DISABLE_GetTopic_Tstring_view
-    Topic GetTopic(std::string_view key) override {
-    
-    
-    
-    
-        using LookupBase = typename PyTrampolineCfg::Base;
-    
-    
-        RPYBUILD_OVERRIDE_PURE_NAME(NTSendableBuilder, PYBIND11_TYPE(Topic), LookupBase,
-            "getTopic", GetTopic, key);
-    
-    
-    
-    }
-#endif
-
-    
-#ifndef RPYGEN_DISABLE_GetTable_v
-    std::shared_ptr<NetworkTable> GetTable() override {
-    
-    
-    
-    
-        using LookupBase = typename PyTrampolineCfg::Base;
-    
-    
-        RPYBUILD_OVERRIDE_PURE_NAME(NTSendableBuilder, PYBIND11_TYPE(std::shared_ptr<NetworkTable>), LookupBase,
-            "getTable", GetTable, );
-    
-    
-    
-    }
-#endif
-
-    
-#ifndef RPYGEN_DISABLE_KGetBackendKind_v
-    BackendKind GetBackendKind() const override {
-    
-    
-    
-    
-        using LookupBase = typename PyTrampolineCfg::Base;
-    
-    
-        using CxxCallBase = typename PyTrampolineCfg::override_base_KGetBackendKind_v;
-        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(BackendKind), LookupBase,
-            "getBackendKind", );
-        return CxxCallBase::GetBackendKind();
-    
-    
-    
-    }
-#endif
-
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/NTSendableBuilder.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/wpi__SendableBuilder.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__NTSendableBuilder :
+
+
+    PyTrampolineCfg_wpi__SendableBuilder<
+
+CfgBase
+>
+
+{
+    using Base = nt::NTSendableBuilder;
+
+    
+    
+    using override_base_SetUpdateTable_Tunique_function = nt::NTSendableBuilder;
+    
+    using override_base_GetTopic_Tstring_view = nt::NTSendableBuilder;
+    
+    using override_base_GetTable_v = nt::NTSendableBuilder;
+    
+    using override_base_KGetBackendKind_v = nt::NTSendableBuilder;
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__NTSendableBuilder =
+
+    PyTrampoline_wpi__SendableBuilder<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__NTSendableBuilder : PyTrampolineBase_nt__NTSendableBuilder<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__NTSendableBuilder<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__NTSendableBuilder;
+
+
+
+
+
+    using BackendKind = wpi::SendableBuilder::BackendKind;
+
+
+
+
+
+
+
+    
+    
+#ifndef RPYGEN_DISABLE_SetUpdateTable_Tunique_function
+    void SetUpdateTable(wpi::unique_function<void ()> func) override {
+    
+    
+    
+    
+        using LookupBase = typename PyTrampolineCfg::Base;
+    
+    
+        RPYBUILD_OVERRIDE_PURE_NAME(NTSendableBuilder, PYBIND11_TYPE(void), LookupBase,
+            "setUpdateTable", SetUpdateTable, func);
+    
+    
+    
+    }
+#endif
+
+    
+#ifndef RPYGEN_DISABLE_GetTopic_Tstring_view
+    Topic GetTopic(std::string_view key) override {
+    
+    
+    
+    
+        using LookupBase = typename PyTrampolineCfg::Base;
+    
+    
+        RPYBUILD_OVERRIDE_PURE_NAME(NTSendableBuilder, PYBIND11_TYPE(Topic), LookupBase,
+            "getTopic", GetTopic, key);
+    
+    
+    
+    }
+#endif
+
+    
+#ifndef RPYGEN_DISABLE_GetTable_v
+    std::shared_ptr<NetworkTable> GetTable() override {
+    
+    
+    
+    
+        using LookupBase = typename PyTrampolineCfg::Base;
+    
+    
+        RPYBUILD_OVERRIDE_PURE_NAME(NTSendableBuilder, PYBIND11_TYPE(std::shared_ptr<NetworkTable>), LookupBase,
+            "getTable", GetTable, );
+    
+    
+    
+    }
+#endif
+
+    
+#ifndef RPYGEN_DISABLE_KGetBackendKind_v
+    BackendKind GetBackendKind() const override {
+    
+    
+    
+    
+        using LookupBase = typename PyTrampolineCfg::Base;
+    
+    
+        using CxxCallBase = typename PyTrampolineCfg::override_base_KGetBackendKind_v;
+        PYBIND11_OVERRIDE_IMPL(PYBIND11_TYPE(BackendKind), LookupBase,
+            "getBackendKind", );
+        return CxxCallBase::GetBackendKind();
+    
+    
+    
+    }
+#endif
+
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__Publisher.hpp

```diff
@@ -1,77 +1,77 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\Topic.h>
-
-
-#include <networktables/GenericEntry.h>
-
-#include <networktables/NetworkTableInstance.h>
-
-
-
-
-
-
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__Publisher :
-
-    CfgBase
-
-{
-    using Base = nt::Publisher;
-
-    
-    
-};
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__Publisher : PyTrampolineBase, virtual py::trampoline_self_life_support {
-    using PyTrampolineBase::PyTrampolineBase;
-
-
-
-
-
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-    using nt::Publisher::m_pubHandle;
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/Topic.h>
+
+
+#include <networktables/GenericEntry.h>
+
+#include <networktables/NetworkTableInstance.h>
+
+
+
+
+
+
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__Publisher :
+
+    CfgBase
+
+{
+    using Base = nt::Publisher;
+
+    
+    
+};
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__Publisher : PyTrampolineBase, virtual py::trampoline_self_life_support {
+    using PyTrampolineBase::PyTrampolineBase;
+
+
+
+
+
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+    using nt::Publisher::m_pubHandle;
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__RawPublisher.hpp

```diff
@@ -1,107 +1,107 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\RawTopic.h>
-
-
-#include <src/nt_type_caster.h>
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__RawPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::RawPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__RawPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__RawPublisher : PyTrampolineBase_nt__RawPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__RawPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__RawPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::RawPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::RawPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::RawPublisher::ParamType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::RawPublisher::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::RawPublisher::SmallElemType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::RawPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/RawTopic.h>
+
+
+#include <src/nt_type_caster.h>
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__RawPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::RawPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__RawPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__RawPublisher : PyTrampolineBase_nt__RawPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__RawPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__RawPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::RawPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::RawPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::RawPublisher::ParamType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::RawPublisher::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::RawPublisher::SmallElemType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::RawPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__RawSubscriber.hpp

```diff
@@ -1,109 +1,109 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\RawTopic.h>
-
-
-#include <src/nt_type_caster.h>
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__RawSubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::RawSubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__RawSubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__RawSubscriber : PyTrampolineBase_nt__RawSubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__RawSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__RawSubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::RawSubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::RawSubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::RawSubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::RawSubscriber::TimestampedValueType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::RawSubscriber::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::RawSubscriber::SmallElemType;
-
-    using TimestampedValueViewType [[maybe_unused]] = typename nt::RawSubscriber::TimestampedValueViewType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/RawTopic.h>
+
+
+#include <src/nt_type_caster.h>
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__RawSubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::RawSubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__RawSubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__RawSubscriber : PyTrampolineBase_nt__RawSubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__RawSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__RawSubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::RawSubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::RawSubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::RawSubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::RawSubscriber::TimestampedValueType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::RawSubscriber::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::RawSubscriber::SmallElemType;
+
+    using TimestampedValueViewType [[maybe_unused]] = typename nt::RawSubscriber::TimestampedValueViewType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__StringArrayPublisher.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StringArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__StringArrayPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::StringArrayPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__StringArrayPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__StringArrayPublisher : PyTrampolineBase_nt__StringArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__StringArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__StringArrayPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::StringArrayPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::StringArrayPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::StringArrayPublisher::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::StringArrayPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StringArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__StringArrayPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::StringArrayPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__StringArrayPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__StringArrayPublisher : PyTrampolineBase_nt__StringArrayPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__StringArrayPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__StringArrayPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::StringArrayPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::StringArrayPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::StringArrayPublisher::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::StringArrayPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__StringArraySubscriber.hpp

```diff
@@ -1,101 +1,101 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StringArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__StringArraySubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::StringArraySubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__StringArraySubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__StringArraySubscriber : PyTrampolineBase_nt__StringArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__StringArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__StringArraySubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::StringArraySubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::StringArraySubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::StringArraySubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::StringArraySubscriber::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StringArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__StringArraySubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::StringArraySubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__StringArraySubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__StringArraySubscriber : PyTrampolineBase_nt__StringArraySubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__StringArraySubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__StringArraySubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::StringArraySubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::StringArraySubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::StringArraySubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::StringArraySubscriber::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__StringPublisher.hpp

```diff
@@ -1,105 +1,105 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StringTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__StringPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::StringPublisher;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__StringPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__StringPublisher : PyTrampolineBase_nt__StringPublisher<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__StringPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__StringPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::StringPublisher::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::StringPublisher::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::StringPublisher::ParamType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::StringPublisher::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::StringPublisher::SmallElemType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::StringPublisher::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StringTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__StringPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::StringPublisher;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__StringPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__StringPublisher : PyTrampolineBase_nt__StringPublisher<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__StringPublisher<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__StringPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::StringPublisher::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::StringPublisher::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::StringPublisher::ParamType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::StringPublisher::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::StringPublisher::SmallElemType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::StringPublisher::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__StringSubscriber.hpp

```diff
@@ -1,107 +1,107 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StringTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__StringSubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::StringSubscriber;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__StringSubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__StringSubscriber : PyTrampolineBase_nt__StringSubscriber<PyTrampolineBase, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__StringSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__StringSubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::StringSubscriber::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::StringSubscriber::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::StringSubscriber::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::StringSubscriber::TimestampedValueType;
-
-    using SmallRetType [[maybe_unused]] = typename nt::StringSubscriber::SmallRetType;
-
-    using SmallElemType [[maybe_unused]] = typename nt::StringSubscriber::SmallElemType;
-
-    using TimestampedValueViewType [[maybe_unused]] = typename nt::StringSubscriber::TimestampedValueViewType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StringTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__StringSubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::StringSubscriber;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__StringSubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__StringSubscriber : PyTrampolineBase_nt__StringSubscriber<PyTrampolineBase, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__StringSubscriber<PyTrampolineBase, PyTrampolineCfg>::PyTrampolineBase_nt__StringSubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::StringSubscriber::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::StringSubscriber::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::StringSubscriber::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::StringSubscriber::TimestampedValueType;
+
+    using SmallRetType [[maybe_unused]] = typename nt::StringSubscriber::SmallRetType;
+
+    using SmallElemType [[maybe_unused]] = typename nt::StringSubscriber::SmallElemType;
+
+    using TimestampedValueViewType [[maybe_unused]] = typename nt::StringSubscriber::TimestampedValueViewType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__StructArrayEntry.hpp

```diff
@@ -1,146 +1,146 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StructArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-template <typename T, typename I>
-struct bind_nt__StructArrayEntry {
-
-    
-
-    
-  
-  
-    using SubscriberType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::SubscriberType;
-  
-    using PublisherType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::PublisherType;
-  
-    using TopicType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::TopicType;
-  
-    using ValueType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::ValueType;
-  
-    using ParamType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::ParamType;
-  
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::TimestampedValueType;
-  
-
-    
-
-    py::class_<typename nt::StructArrayEntry<T, I>, nt::StructArraySubscriber<T, I>, nt::StructArrayPublisher<T, I>> cls_StructArrayEntry;
-
-    
-
-    
-    
-
-    py::module &m;
-    std::string clsName;
-
-bind_nt__StructArrayEntry(py::module &m, const char * clsName) :
-    
-    cls_StructArrayEntry(m, clsName, py::is_final()),
-
-  
-
-  
-  
-    m(m),
-    clsName(clsName)
-{
-    
-  
-
-}
-
-void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
-
-    
-
-  cls_StructArrayEntry.doc() =
-    "NetworkTables struct-encoded value array entry.\n"
-"\n"
-".. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.";
-
-  cls_StructArrayEntry
-  
-    
-  .
-def
-("getTopic", &nt::StructArrayEntry<T, I>::GetTopic, release_gil(), py::doc(
-    "Get the corresponding topic.\n"
-"\n"
-":returns: Topic")
-  )
-  
-  
-  
-    
-  .
-def
-("unpublish", &nt::StructArrayEntry<T, I>::Unpublish, release_gil(), py::doc(
-    "Stops publishing the entry if it's published.")
-  )
-  
-  
-  .def("close", [](nt::StructArrayEntry<T, I> *self) {
-  py::gil_scoped_release release;
-  *self = nt::StructArrayEntry<T, I>();
-}, py::doc("Destroys the entry"))
-.def("__enter__", [](nt::StructArrayEntry<T, I> *self) {
-  return self;
-})
-.def("__exit__", [](nt::StructArrayEntry<T, I> *self, py::args args) {
-  py::gil_scoped_release release;
-  *self = nt::StructArrayEntry<T, I>();
-})
-;
-
-  
-
-
-
-    if (set_doc) {
-        cls_StructArrayEntry.doc() = set_doc;
-    }
-    if (add_doc) {
-        cls_StructArrayEntry.doc() = py::cast<std::string>(cls_StructArrayEntry.doc()) + add_doc;
-    }
-
-    
-}
-
-}; // struct bind_nt__StructArrayEntry
-
-}; // namespace rpygen
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StructArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+template <typename T, typename I>
+struct bind_nt__StructArrayEntry {
+
+    
+
+    
+  
+  
+    using SubscriberType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::SubscriberType;
+  
+    using PublisherType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::PublisherType;
+  
+    using TopicType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::TopicType;
+  
+    using ValueType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::ValueType;
+  
+    using ParamType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::ParamType;
+  
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructArrayEntry<T, I>::TimestampedValueType;
+  
+
+    
+
+    py::class_<typename nt::StructArrayEntry<T, I>, nt::StructArraySubscriber<T, I>, nt::StructArrayPublisher<T, I>> cls_StructArrayEntry;
+
+    
+
+    
+    
+
+    py::module &m;
+    std::string clsName;
+
+bind_nt__StructArrayEntry(py::module &m, const char * clsName) :
+    
+    cls_StructArrayEntry(m, clsName, py::is_final()),
+
+  
+
+  
+  
+    m(m),
+    clsName(clsName)
+{
+    
+  
+
+}
+
+void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
+
+    
+
+  cls_StructArrayEntry.doc() =
+    "NetworkTables struct-encoded value array entry.\n"
+"\n"
+".. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.";
+
+  cls_StructArrayEntry
+  
+    
+  .
+def
+("getTopic", &nt::StructArrayEntry<T, I>::GetTopic, release_gil(), py::doc(
+    "Get the corresponding topic.\n"
+"\n"
+":returns: Topic")
+  )
+  
+  
+  
+    
+  .
+def
+("unpublish", &nt::StructArrayEntry<T, I>::Unpublish, release_gil(), py::doc(
+    "Stops publishing the entry if it's published.")
+  )
+  
+  
+  .def("close", [](nt::StructArrayEntry<T, I> *self) {
+  py::gil_scoped_release release;
+  *self = nt::StructArrayEntry<T, I>();
+}, py::doc("Destroys the entry"))
+.def("__enter__", [](nt::StructArrayEntry<T, I> *self) {
+  return self;
+})
+.def("__exit__", [](nt::StructArrayEntry<T, I> *self, py::args args) {
+  py::gil_scoped_release release;
+  *self = nt::StructArrayEntry<T, I>();
+})
+;
+
+  
+
+
+
+    if (set_doc) {
+        cls_StructArrayEntry.doc() = set_doc;
+    }
+    if (add_doc) {
+        cls_StructArrayEntry.doc() = py::cast<std::string>(cls_StructArrayEntry.doc()) + add_doc;
+    }
+
+    
+}
+
+}; // struct bind_nt__StructArrayEntry
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/nt__StructArrayPublisher.hpp

```diff
@@ -1,249 +1,249 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StructArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__StructArrayPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::StructArrayPublisher<T, I>;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__StructArrayPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
-struct PyTrampoline_nt__StructArrayPublisher : PyTrampolineBase_nt__StructArrayPublisher<PyTrampolineBase, T, I, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__StructArrayPublisher<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructArrayPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
-
-
-
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-template <typename T, typename I>
-struct bind_nt__StructArrayPublisher {
-
-    
-
-    
-  
-  
-    using TopicType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::TopicType;
-  
-    using ValueType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::ValueType;
-  
-    using ParamType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::ParamType;
-  
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::TimestampedValueType;
-  
-
-    
-
-    
-  using StructArrayPublisher_Trampoline = rpygen::PyTrampoline_nt__StructArrayPublisher<typename nt::StructArrayPublisher<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructArrayPublisher<T, I>>;
-    static_assert(std::is_abstract<StructArrayPublisher_Trampoline>::value == false, "nt::StructArrayPublisher<T, I> " RPYBUILD_BAD_TRAMPOLINE);
-  py::class_<typename nt::StructArrayPublisher<T, I>, StructArrayPublisher_Trampoline, nt::Publisher> cls_StructArrayPublisher;
-
-    
-
-    
-    
-
-    py::module &m;
-    std::string clsName;
-
-bind_nt__StructArrayPublisher(py::module &m, const char * clsName) :
-    
-    cls_StructArrayPublisher(m, clsName),
-
-  
-
-  
-  
-    m(m),
-    clsName(clsName)
-{
-    
-  
-
-}
-
-void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
-
-    
-
-  cls_StructArrayPublisher.doc() =
-    "NetworkTables struct-encoded value array publisher.";
-
-  cls_StructArrayPublisher
-  
-    
-  .
-def
-("set", static_cast<void(nt::StructArrayPublisher<T, I>::*)(std::span<const T>, int64_t)>(
-        &nt::StructArrayPublisher<T, I>::Set),
-      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
-    "Publish a new value.\n"
-"\n"
-":param value: value to publish\n"
-":param time:  timestamp; 0 indicates current NT time should be used")
-  )
-  
-  
-  
-    
-  .
-def
-("setDefault", static_cast<void(nt::StructArrayPublisher<T, I>::*)(std::span<const T>)>(
-        &nt::StructArrayPublisher<T, I>::SetDefault),
-      py::arg("value"), release_gil(), py::doc(
-    "Publish a default value.\n"
-"On reconnect, a default value will never be used in preference to a\n"
-"published value.\n"
-"\n"
-":param value: value")
-  )
-  
-  
-  
-    
-  .
-def
-("getTopic", &nt::StructArrayPublisher<T, I>::GetTopic, release_gil(), py::doc(
-    "Get the corresponding topic.\n"
-"\n"
-":returns: Topic")
-  )
-  
-  
-  .def("close", [](nt::StructArrayPublisher<T, I> *self) {
-  py::gil_scoped_release release;
-  *self = nt::StructArrayPublisher<T, I>();
-}, py::doc("Destroys the publisher"))
-.def("__enter__", [](nt::StructArrayPublisher<T, I> *self) {
-  return self;
-})
-.def("__exit__", [](nt::StructArrayPublisher<T, I> *self, py::args args) {
-  py::gil_scoped_release release;
-  *self = nt::StructArrayPublisher<T, I>();
-})
-;
-
-  
-
-
-
-    if (set_doc) {
-        cls_StructArrayPublisher.doc() = set_doc;
-    }
-    if (add_doc) {
-        cls_StructArrayPublisher.doc() = py::cast<std::string>(cls_StructArrayPublisher.doc()) + add_doc;
-    }
-
-    
-}
-
-}; // struct bind_nt__StructArrayPublisher
-
-}; // namespace rpygen
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StructArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__StructArrayPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::StructArrayPublisher<T, I>;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__StructArrayPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
+struct PyTrampoline_nt__StructArrayPublisher : PyTrampolineBase_nt__StructArrayPublisher<PyTrampolineBase, T, I, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__StructArrayPublisher<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructArrayPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
+
+
+
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+template <typename T, typename I>
+struct bind_nt__StructArrayPublisher {
+
+    
+
+    
+  
+  
+    using TopicType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::TopicType;
+  
+    using ValueType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::ValueType;
+  
+    using ParamType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::ParamType;
+  
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructArrayPublisher<T, I>::TimestampedValueType;
+  
+
+    
+
+    
+  using StructArrayPublisher_Trampoline = rpygen::PyTrampoline_nt__StructArrayPublisher<typename nt::StructArrayPublisher<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructArrayPublisher<T, I>>;
+    static_assert(std::is_abstract<StructArrayPublisher_Trampoline>::value == false, "nt::StructArrayPublisher<T, I> " RPYBUILD_BAD_TRAMPOLINE);
+  py::class_<typename nt::StructArrayPublisher<T, I>, StructArrayPublisher_Trampoline, nt::Publisher> cls_StructArrayPublisher;
+
+    
+
+    
+    
+
+    py::module &m;
+    std::string clsName;
+
+bind_nt__StructArrayPublisher(py::module &m, const char * clsName) :
+    
+    cls_StructArrayPublisher(m, clsName),
+
+  
+
+  
+  
+    m(m),
+    clsName(clsName)
+{
+    
+  
+
+}
+
+void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
+
+    
+
+  cls_StructArrayPublisher.doc() =
+    "NetworkTables struct-encoded value array publisher.";
+
+  cls_StructArrayPublisher
+  
+    
+  .
+def
+("set", static_cast<void(nt::StructArrayPublisher<T, I>::*)(std::span<const T>, int64_t)>(
+        &nt::StructArrayPublisher<T, I>::Set),
+      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
+    "Publish a new value.\n"
+"\n"
+":param value: value to publish\n"
+":param time:  timestamp; 0 indicates current NT time should be used")
+  )
+  
+  
+  
+    
+  .
+def
+("setDefault", static_cast<void(nt::StructArrayPublisher<T, I>::*)(std::span<const T>)>(
+        &nt::StructArrayPublisher<T, I>::SetDefault),
+      py::arg("value"), release_gil(), py::doc(
+    "Publish a default value.\n"
+"On reconnect, a default value will never be used in preference to a\n"
+"published value.\n"
+"\n"
+":param value: value")
+  )
+  
+  
+  
+    
+  .
+def
+("getTopic", &nt::StructArrayPublisher<T, I>::GetTopic, release_gil(), py::doc(
+    "Get the corresponding topic.\n"
+"\n"
+":returns: Topic")
+  )
+  
+  
+  .def("close", [](nt::StructArrayPublisher<T, I> *self) {
+  py::gil_scoped_release release;
+  *self = nt::StructArrayPublisher<T, I>();
+}, py::doc("Destroys the publisher"))
+.def("__enter__", [](nt::StructArrayPublisher<T, I> *self) {
+  return self;
+})
+.def("__exit__", [](nt::StructArrayPublisher<T, I> *self, py::args args) {
+  py::gil_scoped_release release;
+  *self = nt::StructArrayPublisher<T, I>();
+})
+;
+
+  
+
+
+
+    if (set_doc) {
+        cls_StructArrayPublisher.doc() = set_doc;
+    }
+    if (add_doc) {
+        cls_StructArrayPublisher.doc() = py::cast<std::string>(cls_StructArrayPublisher.doc()) + add_doc;
+    }
+
+    
+}
+
+}; // struct bind_nt__StructArrayPublisher
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/nt__StructArraySubscriber.hpp

```diff
@@ -1,299 +1,299 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StructArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__StructArraySubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::StructArraySubscriber<T, I>;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__StructArraySubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
-struct PyTrampoline_nt__StructArraySubscriber : PyTrampolineBase_nt__StructArraySubscriber<PyTrampolineBase, T, I, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__StructArraySubscriber<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructArraySubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
-
-
-
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-template <typename T, typename I>
-struct bind_nt__StructArraySubscriber {
-
-    
-
-    
-  
-  
-    using TopicType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TopicType;
-  
-    using ValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ValueType;
-  
-    using ParamType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ParamType;
-  
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TimestampedValueType;
-  
-
-    
-
-    
-  using StructArraySubscriber_Trampoline = rpygen::PyTrampoline_nt__StructArraySubscriber<typename nt::StructArraySubscriber<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructArraySubscriber<T, I>>;
-    static_assert(std::is_abstract<StructArraySubscriber_Trampoline>::value == false, "nt::StructArraySubscriber<T, I> " RPYBUILD_BAD_TRAMPOLINE);
-  py::class_<typename nt::StructArraySubscriber<T, I>, StructArraySubscriber_Trampoline, nt::Subscriber> cls_StructArraySubscriber;
-
-    
-
-    
-    
-
-    py::module &m;
-    std::string clsName;
-
-bind_nt__StructArraySubscriber(py::module &m, const char * clsName) :
-    
-    cls_StructArraySubscriber(m, clsName),
-
-  
-
-  
-  
-    m(m),
-    clsName(clsName)
-{
-    
-  
-
-}
-
-void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
-
-    
-
-  cls_StructArraySubscriber.doc() =
-    "NetworkTables struct-encoded value array subscriber.";
-
-  cls_StructArraySubscriber
-  
-    
-  .
-def
-("get", static_cast<ValueType(nt::StructArraySubscriber<T, I>::*)() const>(
-        &nt::StructArraySubscriber<T, I>::Get), release_gil(), py::doc(
-    "Get the last published value.\n"
-"If no value has been published or the value cannot be unpacked, returns the\n"
-"stored default value.\n"
-"\n"
-":returns: value")
-  )
-  
-  
-  
-    
-  .
-def
-("get", static_cast<ValueType(nt::StructArraySubscriber<T, I>::*)(std::span<const T>) const>(
-        &nt::StructArraySubscriber<T, I>::Get),
-      py::arg("defaultValue"), release_gil(), py::doc(
-    "Get the last published value.\n"
-"If no value has been published or the value cannot be unpacked, returns the\n"
-"passed defaultValue.\n"
-"\n"
-":param defaultValue: default value to return if no value has been published\n"
-"\n"
-":returns: value")
-  )
-  
-  
-  
-    
-  .
-def
-("getAtomic", static_cast<TimestampedValueType(nt::StructArraySubscriber<T, I>::*)() const>(
-        &nt::StructArraySubscriber<T, I>::GetAtomic), release_gil(), py::doc(
-    "Get the last published value along with its timestamp\n"
-"If no value has been published or the value cannot be unpacked, returns the\n"
-"stored default value and a timestamp of 0.\n"
-"\n"
-":returns: timestamped value")
-  )
-  
-  
-  
-    
-  .
-def
-("getAtomic", static_cast<TimestampedValueType(nt::StructArraySubscriber<T, I>::*)(std::span<const T>) const>(
-        &nt::StructArraySubscriber<T, I>::GetAtomic),
-      py::arg("defaultValue"), release_gil(), py::doc(
-    "Get the last published value along with its timestamp.\n"
-"If no value has been published or the value cannot be unpacked, returns the\n"
-"passed defaultValue and a timestamp of 0.\n"
-"\n"
-":param defaultValue: default value to return if no value has been published\n"
-"\n"
-":returns: timestamped value")
-  )
-  
-  
-  
-    
-  .
-def
-("readQueue", &nt::StructArraySubscriber<T, I>::ReadQueue, release_gil(), py::doc(
-    "Get an array of all valid value changes since the last call to ReadQueue.\n"
-"Also provides a timestamp for each value. Values that cannot be unpacked\n"
-"are dropped.\n"
-"\n"
-".. note:: The \"poll storage\" subscribe option can be used to set the queue\n"
-"   depth.\n"
-"\n"
-":returns: Array of timestamped values; empty array if no valid new changes\n"
-"          have been published since the previous call.")
-  )
-  
-  
-  
-    
-  .
-def
-("getTopic", &nt::StructArraySubscriber<T, I>::GetTopic, release_gil(), py::doc(
-    "Get the corresponding topic.\n"
-"\n"
-":returns: Topic")
-  )
-  
-  
-  .def("close", [](nt::StructArraySubscriber<T, I> *self) {
-  py::gil_scoped_release release;
-  *self = nt::StructArraySubscriber<T, I>();
-}, py::doc("Destroys the subscriber"))
-.def("__enter__", [](nt::StructArraySubscriber<T, I> *self) {
-  return self;
-})
-.def("__exit__", [](nt::StructArraySubscriber<T, I> *self, py::args args) {
-  py::gil_scoped_release release;
-  *self = nt::StructArraySubscriber<T, I>();
-})
-;
-
-  
-
-
-
-    if (set_doc) {
-        cls_StructArraySubscriber.doc() = set_doc;
-    }
-    if (add_doc) {
-        cls_StructArraySubscriber.doc() = py::cast<std::string>(cls_StructArraySubscriber.doc()) + add_doc;
-    }
-
-    
-}
-
-}; // struct bind_nt__StructArraySubscriber
-
-}; // namespace rpygen
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StructArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__StructArraySubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::StructArraySubscriber<T, I>;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__StructArraySubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
+struct PyTrampoline_nt__StructArraySubscriber : PyTrampolineBase_nt__StructArraySubscriber<PyTrampolineBase, T, I, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__StructArraySubscriber<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructArraySubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
+
+
+
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+template <typename T, typename I>
+struct bind_nt__StructArraySubscriber {
+
+    
+
+    
+  
+  
+    using TopicType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TopicType;
+  
+    using ValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ValueType;
+  
+    using ParamType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::ParamType;
+  
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructArraySubscriber<T, I>::TimestampedValueType;
+  
+
+    
+
+    
+  using StructArraySubscriber_Trampoline = rpygen::PyTrampoline_nt__StructArraySubscriber<typename nt::StructArraySubscriber<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructArraySubscriber<T, I>>;
+    static_assert(std::is_abstract<StructArraySubscriber_Trampoline>::value == false, "nt::StructArraySubscriber<T, I> " RPYBUILD_BAD_TRAMPOLINE);
+  py::class_<typename nt::StructArraySubscriber<T, I>, StructArraySubscriber_Trampoline, nt::Subscriber> cls_StructArraySubscriber;
+
+    
+
+    
+    
+
+    py::module &m;
+    std::string clsName;
+
+bind_nt__StructArraySubscriber(py::module &m, const char * clsName) :
+    
+    cls_StructArraySubscriber(m, clsName),
+
+  
+
+  
+  
+    m(m),
+    clsName(clsName)
+{
+    
+  
+
+}
+
+void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
+
+    
+
+  cls_StructArraySubscriber.doc() =
+    "NetworkTables struct-encoded value array subscriber.";
+
+  cls_StructArraySubscriber
+  
+    
+  .
+def
+("get", static_cast<ValueType(nt::StructArraySubscriber<T, I>::*)() const>(
+        &nt::StructArraySubscriber<T, I>::Get), release_gil(), py::doc(
+    "Get the last published value.\n"
+"If no value has been published or the value cannot be unpacked, returns the\n"
+"stored default value.\n"
+"\n"
+":returns: value")
+  )
+  
+  
+  
+    
+  .
+def
+("get", static_cast<ValueType(nt::StructArraySubscriber<T, I>::*)(std::span<const T>) const>(
+        &nt::StructArraySubscriber<T, I>::Get),
+      py::arg("defaultValue"), release_gil(), py::doc(
+    "Get the last published value.\n"
+"If no value has been published or the value cannot be unpacked, returns the\n"
+"passed defaultValue.\n"
+"\n"
+":param defaultValue: default value to return if no value has been published\n"
+"\n"
+":returns: value")
+  )
+  
+  
+  
+    
+  .
+def
+("getAtomic", static_cast<TimestampedValueType(nt::StructArraySubscriber<T, I>::*)() const>(
+        &nt::StructArraySubscriber<T, I>::GetAtomic), release_gil(), py::doc(
+    "Get the last published value along with its timestamp\n"
+"If no value has been published or the value cannot be unpacked, returns the\n"
+"stored default value and a timestamp of 0.\n"
+"\n"
+":returns: timestamped value")
+  )
+  
+  
+  
+    
+  .
+def
+("getAtomic", static_cast<TimestampedValueType(nt::StructArraySubscriber<T, I>::*)(std::span<const T>) const>(
+        &nt::StructArraySubscriber<T, I>::GetAtomic),
+      py::arg("defaultValue"), release_gil(), py::doc(
+    "Get the last published value along with its timestamp.\n"
+"If no value has been published or the value cannot be unpacked, returns the\n"
+"passed defaultValue and a timestamp of 0.\n"
+"\n"
+":param defaultValue: default value to return if no value has been published\n"
+"\n"
+":returns: timestamped value")
+  )
+  
+  
+  
+    
+  .
+def
+("readQueue", &nt::StructArraySubscriber<T, I>::ReadQueue, release_gil(), py::doc(
+    "Get an array of all valid value changes since the last call to ReadQueue.\n"
+"Also provides a timestamp for each value. Values that cannot be unpacked\n"
+"are dropped.\n"
+"\n"
+".. note:: The \"poll storage\" subscribe option can be used to set the queue\n"
+"   depth.\n"
+"\n"
+":returns: Array of timestamped values; empty array if no valid new changes\n"
+"          have been published since the previous call.")
+  )
+  
+  
+  
+    
+  .
+def
+("getTopic", &nt::StructArraySubscriber<T, I>::GetTopic, release_gil(), py::doc(
+    "Get the corresponding topic.\n"
+"\n"
+":returns: Topic")
+  )
+  
+  
+  .def("close", [](nt::StructArraySubscriber<T, I> *self) {
+  py::gil_scoped_release release;
+  *self = nt::StructArraySubscriber<T, I>();
+}, py::doc("Destroys the subscriber"))
+.def("__enter__", [](nt::StructArraySubscriber<T, I> *self) {
+  return self;
+})
+.def("__exit__", [](nt::StructArraySubscriber<T, I> *self, py::args args) {
+  py::gil_scoped_release release;
+  *self = nt::StructArraySubscriber<T, I>();
+})
+;
+
+  
+
+
+
+    if (set_doc) {
+        cls_StructArraySubscriber.doc() = set_doc;
+    }
+    if (add_doc) {
+        cls_StructArraySubscriber.doc() = py::cast<std::string>(cls_StructArraySubscriber.doc()) + add_doc;
+    }
+
+    
+}
+
+}; // struct bind_nt__StructArraySubscriber
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/nt__StructArrayTopic.hpp

```diff
@@ -1,225 +1,240 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StructArrayTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-template <typename T, typename I>
-struct bind_nt__StructArrayTopic {
-
-    
-
-    
-  
-  
-    using SubscriberType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::SubscriberType;
-  
-    using PublisherType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::PublisherType;
-  
-    using EntryType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::EntryType;
-  
-    using ValueType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::ValueType;
-  
-    using ParamType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::ParamType;
-  
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::TimestampedValueType;
-  
-
-    
-
-    py::class_<typename nt::StructArrayTopic<T, I>, nt::Topic> cls_StructArrayTopic;
-
-    
-
-    
-    
-
-    py::module &m;
-    std::string clsName;
-
-bind_nt__StructArrayTopic(py::module &m, const char * clsName) :
-    
-    cls_StructArrayTopic(m, clsName, py::is_final()),
-
-  
-
-  
-  
-    m(m),
-    clsName(clsName)
-{
-    
-  
-
-}
-
-void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
-
-    
-
-  cls_StructArrayTopic.doc() =
-    "NetworkTables struct-encoded value array topic.";
-
-  cls_StructArrayTopic
-  
-    
-  .
-def
-("subscribe", static_cast<SubscriberType(nt::StructArrayTopic<T, I>::*)(std::span<const T>, const PubSubOptions&)>(
-        &nt::StructArrayTopic<T, I>::Subscribe),
-      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
-    "Create a new subscriber to the topic.\n"
-"\n"
-"The subscriber is only active as long as the returned object\n"
-"is not destroyed.\n"
-"\n"
-".. note:: Subscribers that do not match the published data type do not return\n"
-"   any values. To determine if the data type matches, use the appropriate\n"
-"   Topic functions.\n"
-"\n"
-":param defaultValue: default value used when a default is not provided to a\n"
-"                     getter function\n"
-":param options:      subscribe options\n"
-"\n"
-":returns: subscriber")
-  )
-  
-  
-  
-    
-  .
-def
-("publish", &nt::StructArrayTopic<T, I>::Publish,
-      py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
-    "Create a new publisher to the topic.\n"
-"\n"
-"The publisher is only active as long as the returned object\n"
-"is not destroyed.\n"
-"\n"
-".. note:: It is not possible to publish two different data types to the same\n"
-"   topic. Conflicts between publishers are typically resolved by the\n"
-"   server on a first-come, first-served basis. Any published values that\n"
-"   do not match the topic's data type are dropped (ignored). To determine\n"
-"   if the data type matches, use the appropriate Topic functions.\n"
-"\n"
-":param options: publish options\n"
-"\n"
-":returns: publisher")
-  )
-  
-  
-  
-    
-  .
-def
-("publishEx", &nt::StructArrayTopic<T, I>::PublishEx,
-      py::arg("properties"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
-    "Create a new publisher to the topic, with type string and initial\n"
-"properties.\n"
-"\n"
-"The publisher is only active as long as the returned object\n"
-"is not destroyed.\n"
-"\n"
-".. note:: It is not possible to publish two different data types to the same\n"
-"   topic. Conflicts between publishers are typically resolved by the\n"
-"   server on a first-come, first-served basis. Any published values that\n"
-"   do not match the topic's data type are dropped (ignored). To determine\n"
-"   if the data type matches, use the appropriate Topic functions.\n"
-"\n"
-":param properties: JSON properties\n"
-":param options:    publish options\n"
-"\n"
-":returns: publisher")
-  )
-  
-  
-  
-    
-  .
-def
-("getEntry", static_cast<EntryType(nt::StructArrayTopic<T, I>::*)(std::span<const T>, const PubSubOptions&)>(
-        &nt::StructArrayTopic<T, I>::GetEntry),
-      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
-    "Create a new entry for the topic.\n"
-"\n"
-"Entries act as a combination of a subscriber and a weak publisher. The\n"
-"subscriber is active as long as the entry is not destroyed. The publisher\n"
-"is created when the entry is first written to, and remains active until\n"
-"either Unpublish() is called or the entry is destroyed.\n"
-"\n"
-".. note:: It is not possible to use two different data types with the same\n"
-"   topic. Conflicts between publishers are typically resolved by the\n"
-"   server on a first-come, first-served basis. Any published values that\n"
-"   do not match the topic's data type are dropped (ignored), and the entry\n"
-"   will show no new values if the data type does not match. To determine\n"
-"   if the data type matches, use the appropriate Topic functions.\n"
-"\n"
-":param defaultValue: default value used when a default is not provided to a\n"
-"                     getter function\n"
-":param options:      publish and/or subscribe options\n"
-"\n"
-":returns: entry")
-  )
-  
-  
-  .def("close", [](nt::StructArrayTopic<T, I> *self) {
-  py::gil_scoped_release release;
-  *self = nt::StructArrayTopic<T, I>();
-}, py::doc("Destroys the topic"))
-.def("__enter__", [](nt::StructArrayTopic<T, I> *self) {
-  return self;
-})
-.def("__exit__", [](nt::StructArrayTopic<T, I> *self, py::args args) {
-  py::gil_scoped_release release;
-  *self = nt::StructArrayTopic<T, I>();
-})
-;
-
-  
-
-
-
-    if (set_doc) {
-        cls_StructArrayTopic.doc() = set_doc;
-    }
-    if (add_doc) {
-        cls_StructArrayTopic.doc() = py::cast<std::string>(cls_StructArrayTopic.doc()) + add_doc;
-    }
-
-    
-}
-
-}; // struct bind_nt__StructArrayTopic
-
-}; // namespace rpygen
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StructArrayTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+template <typename T, typename I>
+struct bind_nt__StructArrayTopic {
+
+    
+
+    
+  
+  
+    using SubscriberType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::SubscriberType;
+  
+    using PublisherType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::PublisherType;
+  
+    using EntryType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::EntryType;
+  
+    using ValueType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::ValueType;
+  
+    using ParamType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::ParamType;
+  
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructArrayTopic<T, I>::TimestampedValueType;
+  
+
+    
+
+    py::class_<typename nt::StructArrayTopic<T, I>, nt::Topic> cls_StructArrayTopic;
+
+    
+
+    
+    
+
+    py::module &m;
+    std::string clsName;
+
+bind_nt__StructArrayTopic(py::module &m, const char * clsName) :
+    
+    cls_StructArrayTopic(m, clsName, py::is_final()),
+
+  
+
+  
+  
+    m(m),
+    clsName(clsName)
+{
+    
+  
+
+}
+
+void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
+
+    
+
+  cls_StructArrayTopic.doc() =
+    "NetworkTables struct-encoded value array topic.";
+
+  cls_StructArrayTopic
+  
+    
+  .def(py::init([](Topic topic, const py::type &t) {
+  WPyStructInfo info(t);
+  return nt::StructArrayTopic<T, I>(topic, info);
+}
+),
+      py::arg("topic"), py::arg("type"), py::doc(
+    "Construct from a generic topic.\n"
+"\n"
+":param topic: Topic\n"
+":param type:  optional struct type info")
+  )
+  
+  
+  
+    
+  .
+def
+("subscribe", static_cast<SubscriberType(nt::StructArrayTopic<T, I>::*)(std::span<const T>, const PubSubOptions&)>(
+        &nt::StructArrayTopic<T, I>::Subscribe),
+      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
+    "Create a new subscriber to the topic.\n"
+"\n"
+"The subscriber is only active as long as the returned object\n"
+"is not destroyed.\n"
+"\n"
+".. note:: Subscribers that do not match the published data type do not return\n"
+"   any values. To determine if the data type matches, use the appropriate\n"
+"   Topic functions.\n"
+"\n"
+":param defaultValue: default value used when a default is not provided to a\n"
+"                     getter function\n"
+":param options:      subscribe options\n"
+"\n"
+":returns: subscriber")
+  )
+  
+  
+  
+    
+  .
+def
+("publish", &nt::StructArrayTopic<T, I>::Publish,
+      py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
+    "Create a new publisher to the topic.\n"
+"\n"
+"The publisher is only active as long as the returned object\n"
+"is not destroyed.\n"
+"\n"
+".. note:: It is not possible to publish two different data types to the same\n"
+"   topic. Conflicts between publishers are typically resolved by the\n"
+"   server on a first-come, first-served basis. Any published values that\n"
+"   do not match the topic's data type are dropped (ignored). To determine\n"
+"   if the data type matches, use the appropriate Topic functions.\n"
+"\n"
+":param options: publish options\n"
+"\n"
+":returns: publisher")
+  )
+  
+  
+  
+    
+  .
+def
+("publishEx", &nt::StructArrayTopic<T, I>::PublishEx,
+      py::arg("properties"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
+    "Create a new publisher to the topic, with type string and initial\n"
+"properties.\n"
+"\n"
+"The publisher is only active as long as the returned object\n"
+"is not destroyed.\n"
+"\n"
+".. note:: It is not possible to publish two different data types to the same\n"
+"   topic. Conflicts between publishers are typically resolved by the\n"
+"   server on a first-come, first-served basis. Any published values that\n"
+"   do not match the topic's data type are dropped (ignored). To determine\n"
+"   if the data type matches, use the appropriate Topic functions.\n"
+"\n"
+":param properties: JSON properties\n"
+":param options:    publish options\n"
+"\n"
+":returns: publisher")
+  )
+  
+  
+  
+    
+  .
+def
+("getEntry", static_cast<EntryType(nt::StructArrayTopic<T, I>::*)(std::span<const T>, const PubSubOptions&)>(
+        &nt::StructArrayTopic<T, I>::GetEntry),
+      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
+    "Create a new entry for the topic.\n"
+"\n"
+"Entries act as a combination of a subscriber and a weak publisher. The\n"
+"subscriber is active as long as the entry is not destroyed. The publisher\n"
+"is created when the entry is first written to, and remains active until\n"
+"either Unpublish() is called or the entry is destroyed.\n"
+"\n"
+".. note:: It is not possible to use two different data types with the same\n"
+"   topic. Conflicts between publishers are typically resolved by the\n"
+"   server on a first-come, first-served basis. Any published values that\n"
+"   do not match the topic's data type are dropped (ignored), and the entry\n"
+"   will show no new values if the data type does not match. To determine\n"
+"   if the data type matches, use the appropriate Topic functions.\n"
+"\n"
+":param defaultValue: default value used when a default is not provided to a\n"
+"                     getter function\n"
+":param options:      publish and/or subscribe options\n"
+"\n"
+":returns: entry")
+  )
+  
+  
+  .def("close", [](nt::StructArrayTopic<T, I> *self) {
+  py::gil_scoped_release release;
+  *self = nt::StructArrayTopic<T, I>();
+}, py::doc("Destroys the topic"))
+.def("__enter__", [](nt::StructArrayTopic<T, I> *self) {
+  return self;
+})
+.def("__exit__", [](nt::StructArrayTopic<T, I> *self, py::args args) {
+  py::gil_scoped_release release;
+  *self = nt::StructArrayTopic<T, I>();
+})
+;
+
+  
+
+
+
+    if (set_doc) {
+        cls_StructArrayTopic.doc() = set_doc;
+    }
+    if (add_doc) {
+        cls_StructArrayTopic.doc() = py::cast<std::string>(cls_StructArrayTopic.doc()) + add_doc;
+    }
+
+    
+}
+
+}; // struct bind_nt__StructArrayTopic
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/nt__StructEntry.hpp

```diff
@@ -1,144 +1,144 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StructTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpystruct.h>
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-template <typename T, typename I>
-struct bind_nt__StructEntry {
-
-    
-
-    
-  
-  
-    using SubscriberType [[maybe_unused]] = typename nt::StructEntry<T, I>::SubscriberType;
-  
-    using PublisherType [[maybe_unused]] = typename nt::StructEntry<T, I>::PublisherType;
-  
-    using TopicType [[maybe_unused]] = typename nt::StructEntry<T, I>::TopicType;
-  
-    using ValueType [[maybe_unused]] = typename nt::StructEntry<T, I>::ValueType;
-  
-    using ParamType [[maybe_unused]] = typename nt::StructEntry<T, I>::ParamType;
-  
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructEntry<T, I>::TimestampedValueType;
-  
-
-    
-
-    py::class_<typename nt::StructEntry<T, I>, nt::StructSubscriber<T, I>, nt::StructPublisher<T, I>> cls_StructEntry;
-
-    
-
-    
-    
-
-    py::module &m;
-    std::string clsName;
-
-bind_nt__StructEntry(py::module &m, const char * clsName) :
-    
-    cls_StructEntry(m, clsName, py::is_final()),
-
-  
-
-  
-  
-    m(m),
-    clsName(clsName)
-{
-    
-  
-
-}
-
-void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
-
-    
-
-  cls_StructEntry.doc() =
-    "NetworkTables struct-encoded value entry.\n"
-"\n"
-".. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.";
-
-  cls_StructEntry
-  
-    
-  .
-def
-("getTopic", &nt::StructEntry<T, I>::GetTopic, release_gil(), py::doc(
-    "Get the corresponding topic.\n"
-"\n"
-":returns: Topic")
-  )
-  
-  
-  
-    
-  .
-def
-("unpublish", &nt::StructEntry<T, I>::Unpublish, release_gil(), py::doc(
-    "Stops publishing the entry if it's published.")
-  )
-  
-  
-  .def("close", [](nt::StructEntry<T, I> *self) {
-  py::gil_scoped_release release;
-  *self = nt::StructEntry<T, I>();
-}, py::doc("Destroys the entry"))
-.def("__enter__", [](nt::StructEntry<T, I> *self) {
-  return self;
-})
-.def("__exit__", [](nt::StructEntry<T, I> *self, py::args args) {
-  py::gil_scoped_release release;
-  *self = nt::StructEntry<T, I>();
-})
-;
-
-  
-
-
-
-    if (set_doc) {
-        cls_StructEntry.doc() = set_doc;
-    }
-    if (add_doc) {
-        cls_StructEntry.doc() = py::cast<std::string>(cls_StructEntry.doc()) + add_doc;
-    }
-
-    
-}
-
-}; // struct bind_nt__StructEntry
-
-}; // namespace rpygen
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StructTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpystruct.h>
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+template <typename T, typename I>
+struct bind_nt__StructEntry {
+
+    
+
+    
+  
+  
+    using SubscriberType [[maybe_unused]] = typename nt::StructEntry<T, I>::SubscriberType;
+  
+    using PublisherType [[maybe_unused]] = typename nt::StructEntry<T, I>::PublisherType;
+  
+    using TopicType [[maybe_unused]] = typename nt::StructEntry<T, I>::TopicType;
+  
+    using ValueType [[maybe_unused]] = typename nt::StructEntry<T, I>::ValueType;
+  
+    using ParamType [[maybe_unused]] = typename nt::StructEntry<T, I>::ParamType;
+  
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructEntry<T, I>::TimestampedValueType;
+  
+
+    
+
+    py::class_<typename nt::StructEntry<T, I>, nt::StructSubscriber<T, I>, nt::StructPublisher<T, I>> cls_StructEntry;
+
+    
+
+    
+    
+
+    py::module &m;
+    std::string clsName;
+
+bind_nt__StructEntry(py::module &m, const char * clsName) :
+    
+    cls_StructEntry(m, clsName, py::is_final()),
+
+  
+
+  
+  
+    m(m),
+    clsName(clsName)
+{
+    
+  
+
+}
+
+void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
+
+    
+
+  cls_StructEntry.doc() =
+    "NetworkTables struct-encoded value entry.\n"
+"\n"
+".. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.";
+
+  cls_StructEntry
+  
+    
+  .
+def
+("getTopic", &nt::StructEntry<T, I>::GetTopic, release_gil(), py::doc(
+    "Get the corresponding topic.\n"
+"\n"
+":returns: Topic")
+  )
+  
+  
+  
+    
+  .
+def
+("unpublish", &nt::StructEntry<T, I>::Unpublish, release_gil(), py::doc(
+    "Stops publishing the entry if it's published.")
+  )
+  
+  
+  .def("close", [](nt::StructEntry<T, I> *self) {
+  py::gil_scoped_release release;
+  *self = nt::StructEntry<T, I>();
+}, py::doc("Destroys the entry"))
+.def("__enter__", [](nt::StructEntry<T, I> *self) {
+  return self;
+})
+.def("__exit__", [](nt::StructEntry<T, I> *self, py::args args) {
+  py::gil_scoped_release release;
+  *self = nt::StructEntry<T, I>();
+})
+;
+
+  
+
+
+
+    if (set_doc) {
+        cls_StructEntry.doc() = set_doc;
+    }
+    if (add_doc) {
+        cls_StructEntry.doc() = py::cast<std::string>(cls_StructEntry.doc()) + add_doc;
+    }
+
+    
+}
+
+}; // struct bind_nt__StructEntry
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/nt__StructPublisher.hpp

```diff
@@ -1,245 +1,245 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StructTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Publisher.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__StructPublisher :
-
-
-    PyTrampolineCfg_nt__Publisher<
-
-CfgBase
->
-
-{
-    using Base = nt::StructPublisher<T, I>;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__StructPublisher =
-
-    PyTrampoline_nt__Publisher<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
-struct PyTrampoline_nt__StructPublisher : PyTrampolineBase_nt__StructPublisher<PyTrampolineBase, T, I, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__StructPublisher<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructPublisher;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
-
-
-
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpystruct.h>
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-template <typename T, typename I>
-struct bind_nt__StructPublisher {
-
-    
-
-    
-  
-  
-    using TopicType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TopicType;
-  
-    using ValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ValueType;
-  
-    using ParamType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ParamType;
-  
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TimestampedValueType;
-  
-
-    
-
-    
-  using StructPublisher_Trampoline = rpygen::PyTrampoline_nt__StructPublisher<typename nt::StructPublisher<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructPublisher<T, I>>;
-    static_assert(std::is_abstract<StructPublisher_Trampoline>::value == false, "nt::StructPublisher<T, I> " RPYBUILD_BAD_TRAMPOLINE);
-  py::class_<typename nt::StructPublisher<T, I>, StructPublisher_Trampoline, nt::Publisher> cls_StructPublisher;
-
-    
-
-    
-    
-
-    py::module &m;
-    std::string clsName;
-
-bind_nt__StructPublisher(py::module &m, const char * clsName) :
-    
-    cls_StructPublisher(m, clsName),
-
-  
-
-  
-  
-    m(m),
-    clsName(clsName)
-{
-    
-  
-
-}
-
-void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
-
-    
-
-  cls_StructPublisher.doc() =
-    "NetworkTables struct-encoded value publisher.";
-
-  cls_StructPublisher
-  
-    
-  .
-def
-("set", &nt::StructPublisher<T, I>::Set,
-      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
-    "Publish a new value.\n"
-"\n"
-":param value: value to publish\n"
-":param time:  timestamp; 0 indicates current NT time should be used")
-  )
-  
-  
-  
-    
-  .
-def
-("setDefault", &nt::StructPublisher<T, I>::SetDefault,
-      py::arg("value"), release_gil(), py::doc(
-    "Publish a default value.\n"
-"On reconnect, a default value will never be used in preference to a\n"
-"published value.\n"
-"\n"
-":param value: value")
-  )
-  
-  
-  
-    
-  .
-def
-("getTopic", &nt::StructPublisher<T, I>::GetTopic, release_gil(), py::doc(
-    "Get the corresponding topic.\n"
-"\n"
-":returns: Topic")
-  )
-  
-  
-  .def("close", [](nt::StructPublisher<T, I> *self) {
-  py::gil_scoped_release release;
-  *self = nt::StructPublisher<T, I>();
-}, py::doc("Destroys the publisher"))
-.def("__enter__", [](nt::StructPublisher<T, I> *self) {
-  return self;
-})
-.def("__exit__", [](nt::StructPublisher<T, I> *self, py::args args) {
-  py::gil_scoped_release release;
-  *self = nt::StructPublisher<T, I>();
-})
-;
-
-  
-
-
-
-    if (set_doc) {
-        cls_StructPublisher.doc() = set_doc;
-    }
-    if (add_doc) {
-        cls_StructPublisher.doc() = py::cast<std::string>(cls_StructPublisher.doc()) + add_doc;
-    }
-
-    
-}
-
-}; // struct bind_nt__StructPublisher
-
-}; // namespace rpygen
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StructTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Publisher.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__StructPublisher :
+
+
+    PyTrampolineCfg_nt__Publisher<
+
+CfgBase
+>
+
+{
+    using Base = nt::StructPublisher<T, I>;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__StructPublisher =
+
+    PyTrampoline_nt__Publisher<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
+struct PyTrampoline_nt__StructPublisher : PyTrampolineBase_nt__StructPublisher<PyTrampolineBase, T, I, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__StructPublisher<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructPublisher;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
+
+
+
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpystruct.h>
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+template <typename T, typename I>
+struct bind_nt__StructPublisher {
+
+    
+
+    
+  
+  
+    using TopicType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TopicType;
+  
+    using ValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ValueType;
+  
+    using ParamType [[maybe_unused]] = typename nt::StructPublisher<T, I>::ParamType;
+  
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructPublisher<T, I>::TimestampedValueType;
+  
+
+    
+
+    
+  using StructPublisher_Trampoline = rpygen::PyTrampoline_nt__StructPublisher<typename nt::StructPublisher<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructPublisher<T, I>>;
+    static_assert(std::is_abstract<StructPublisher_Trampoline>::value == false, "nt::StructPublisher<T, I> " RPYBUILD_BAD_TRAMPOLINE);
+  py::class_<typename nt::StructPublisher<T, I>, StructPublisher_Trampoline, nt::Publisher> cls_StructPublisher;
+
+    
+
+    
+    
+
+    py::module &m;
+    std::string clsName;
+
+bind_nt__StructPublisher(py::module &m, const char * clsName) :
+    
+    cls_StructPublisher(m, clsName),
+
+  
+
+  
+  
+    m(m),
+    clsName(clsName)
+{
+    
+  
+
+}
+
+void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
+
+    
+
+  cls_StructPublisher.doc() =
+    "NetworkTables struct-encoded value publisher.";
+
+  cls_StructPublisher
+  
+    
+  .
+def
+("set", &nt::StructPublisher<T, I>::Set,
+      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
+    "Publish a new value.\n"
+"\n"
+":param value: value to publish\n"
+":param time:  timestamp; 0 indicates current NT time should be used")
+  )
+  
+  
+  
+    
+  .
+def
+("setDefault", &nt::StructPublisher<T, I>::SetDefault,
+      py::arg("value"), release_gil(), py::doc(
+    "Publish a default value.\n"
+"On reconnect, a default value will never be used in preference to a\n"
+"published value.\n"
+"\n"
+":param value: value")
+  )
+  
+  
+  
+    
+  .
+def
+("getTopic", &nt::StructPublisher<T, I>::GetTopic, release_gil(), py::doc(
+    "Get the corresponding topic.\n"
+"\n"
+":returns: Topic")
+  )
+  
+  
+  .def("close", [](nt::StructPublisher<T, I> *self) {
+  py::gil_scoped_release release;
+  *self = nt::StructPublisher<T, I>();
+}, py::doc("Destroys the publisher"))
+.def("__enter__", [](nt::StructPublisher<T, I> *self) {
+  return self;
+})
+.def("__exit__", [](nt::StructPublisher<T, I> *self, py::args args) {
+  py::gil_scoped_release release;
+  *self = nt::StructPublisher<T, I>();
+})
+;
+
+  
+
+
+
+    if (set_doc) {
+        cls_StructPublisher.doc() = set_doc;
+    }
+    if (add_doc) {
+        cls_StructPublisher.doc() = py::cast<std::string>(cls_StructPublisher.doc()) + add_doc;
+    }
+
+    
+}
+
+}; // struct bind_nt__StructPublisher
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/nt__StructSubscriber.hpp

```diff
@@ -1,297 +1,297 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StructTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Subscriber.hpp>
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__StructSubscriber :
-
-
-    PyTrampolineCfg_nt__Subscriber<
-
-CfgBase
->
-
-{
-    using Base = nt::StructSubscriber<T, I>;
-
-    
-    
-};
-
-
-
-
-template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
-using PyTrampolineBase_nt__StructSubscriber =
-
-    PyTrampoline_nt__Subscriber<
-
-        PyTrampolineBase
-
-        
-        , PyTrampolineCfg
-    >
-
-;
-
-template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
-struct PyTrampoline_nt__StructSubscriber : PyTrampolineBase_nt__StructSubscriber<PyTrampolineBase, T, I, PyTrampolineCfg> {
-    using PyTrampolineBase_nt__StructSubscriber<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructSubscriber;
-
-
-
-
-
-
-    using TopicType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TopicType;
-
-    using ValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ValueType;
-
-    using ParamType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ParamType;
-
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TimestampedValueType;
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
-
-
-
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpystruct.h>
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-template <typename T, typename I>
-struct bind_nt__StructSubscriber {
-
-    
-
-    
-  
-  
-    using TopicType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TopicType;
-  
-    using ValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ValueType;
-  
-    using ParamType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ParamType;
-  
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TimestampedValueType;
-  
-
-    
-
-    
-  using StructSubscriber_Trampoline = rpygen::PyTrampoline_nt__StructSubscriber<typename nt::StructSubscriber<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructSubscriber<T, I>>;
-    static_assert(std::is_abstract<StructSubscriber_Trampoline>::value == false, "nt::StructSubscriber<T, I> " RPYBUILD_BAD_TRAMPOLINE);
-  py::class_<typename nt::StructSubscriber<T, I>, StructSubscriber_Trampoline, nt::Subscriber> cls_StructSubscriber;
-
-    
-
-    
-    
-
-    py::module &m;
-    std::string clsName;
-
-bind_nt__StructSubscriber(py::module &m, const char * clsName) :
-    
-    cls_StructSubscriber(m, clsName),
-
-  
-
-  
-  
-    m(m),
-    clsName(clsName)
-{
-    
-  
-
-}
-
-void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
-
-    
-
-  cls_StructSubscriber.doc() =
-    "NetworkTables struct-encoded value subscriber.";
-
-  cls_StructSubscriber
-  
-    
-  .
-def
-("get", static_cast<ValueType(nt::StructSubscriber<T, I>::*)() const>(
-        &nt::StructSubscriber<T, I>::Get), release_gil(), py::doc(
-    "Get the last published value.\n"
-"If no value has been published or the value cannot be unpacked, returns the\n"
-"stored default value.\n"
-"\n"
-":returns: value")
-  )
-  
-  
-  
-    
-  .
-def
-("get", static_cast<ValueType(nt::StructSubscriber<T, I>::*)(const T&) const>(
-        &nt::StructSubscriber<T, I>::Get),
-      py::arg("defaultValue"), release_gil(), py::doc(
-    "Get the last published value.\n"
-"If no value has been published or the value cannot be unpacked, returns the\n"
-"passed defaultValue.\n"
-"\n"
-":param defaultValue: default value to return if no value has been published\n"
-"\n"
-":returns: value")
-  )
-  
-  
-  
-    
-  .
-def
-("getAtomic", static_cast<TimestampedValueType(nt::StructSubscriber<T, I>::*)() const>(
-        &nt::StructSubscriber<T, I>::GetAtomic), release_gil(), py::doc(
-    "Get the last published value along with its timestamp\n"
-"If no value has been published or the value cannot be unpacked, returns the\n"
-"stored default value and a timestamp of 0.\n"
-"\n"
-":returns: timestamped value")
-  )
-  
-  
-  
-    
-  .
-def
-("getAtomic", static_cast<TimestampedValueType(nt::StructSubscriber<T, I>::*)(const T&) const>(
-        &nt::StructSubscriber<T, I>::GetAtomic),
-      py::arg("defaultValue"), release_gil(), py::doc(
-    "Get the last published value along with its timestamp.\n"
-"If no value has been published or the value cannot be unpacked, returns the\n"
-"passed defaultValue and a timestamp of 0.\n"
-"\n"
-":param defaultValue: default value to return if no value has been published\n"
-"\n"
-":returns: timestamped value")
-  )
-  
-  
-  
-    
-  .
-def
-("readQueue", &nt::StructSubscriber<T, I>::ReadQueue, release_gil(), py::doc(
-    "Get an array of all valid value changes since the last call to ReadQueue.\n"
-"Also provides a timestamp for each value. Values that cannot be unpacked\n"
-"are dropped.\n"
-"\n"
-".. note:: The \"poll storage\" subscribe option can be used to set the queue\n"
-"   depth.\n"
-"\n"
-":returns: Array of timestamped values; empty array if no valid new changes\n"
-"          have been published since the previous call.")
-  )
-  
-  
-  
-    
-  .
-def
-("getTopic", &nt::StructSubscriber<T, I>::GetTopic, release_gil(), py::doc(
-    "Get the corresponding topic.\n"
-"\n"
-":returns: Topic")
-  )
-  
-  
-  .def("close", [](nt::StructSubscriber<T, I> *self) {
-  py::gil_scoped_release release;
-  *self = nt::StructSubscriber<T, I>();
-}, py::doc("Destroys the subscriber"))
-.def("__enter__", [](nt::StructSubscriber<T, I> *self) {
-  return self;
-})
-.def("__exit__", [](nt::StructSubscriber<T, I> *self, py::args args) {
-  py::gil_scoped_release release;
-  *self = nt::StructSubscriber<T, I>();
-})
-;
-
-  
-
-
-
-    if (set_doc) {
-        cls_StructSubscriber.doc() = set_doc;
-    }
-    if (add_doc) {
-        cls_StructSubscriber.doc() = py::cast<std::string>(cls_StructSubscriber.doc()) + add_doc;
-    }
-
-    
-}
-
-}; // struct bind_nt__StructSubscriber
-
-}; // namespace rpygen
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StructTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Subscriber.hpp>
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename T, typename I, typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__StructSubscriber :
+
+
+    PyTrampolineCfg_nt__Subscriber<
+
+CfgBase
+>
+
+{
+    using Base = nt::StructSubscriber<T, I>;
+
+    
+    
+};
+
+
+
+
+template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
+using PyTrampolineBase_nt__StructSubscriber =
+
+    PyTrampoline_nt__Subscriber<
+
+        PyTrampolineBase
+
+        
+        , PyTrampolineCfg
+    >
+
+;
+
+template <typename PyTrampolineBase, typename T, typename I, typename PyTrampolineCfg>
+struct PyTrampoline_nt__StructSubscriber : PyTrampolineBase_nt__StructSubscriber<PyTrampolineBase, T, I, PyTrampolineCfg> {
+    using PyTrampolineBase_nt__StructSubscriber<PyTrampolineBase, T, I, PyTrampolineCfg>::PyTrampolineBase_nt__StructSubscriber;
+
+
+
+
+
+
+    using TopicType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TopicType;
+
+    using ValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ValueType;
+
+    using ParamType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ParamType;
+
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TimestampedValueType;
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
+
+
+
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpystruct.h>
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+template <typename T, typename I>
+struct bind_nt__StructSubscriber {
+
+    
+
+    
+  
+  
+    using TopicType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TopicType;
+  
+    using ValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ValueType;
+  
+    using ParamType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::ParamType;
+  
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructSubscriber<T, I>::TimestampedValueType;
+  
+
+    
+
+    
+  using StructSubscriber_Trampoline = rpygen::PyTrampoline_nt__StructSubscriber<typename nt::StructSubscriber<T, I>, T, I, typename rpygen::PyTrampolineCfg_nt__StructSubscriber<T, I>>;
+    static_assert(std::is_abstract<StructSubscriber_Trampoline>::value == false, "nt::StructSubscriber<T, I> " RPYBUILD_BAD_TRAMPOLINE);
+  py::class_<typename nt::StructSubscriber<T, I>, StructSubscriber_Trampoline, nt::Subscriber> cls_StructSubscriber;
+
+    
+
+    
+    
+
+    py::module &m;
+    std::string clsName;
+
+bind_nt__StructSubscriber(py::module &m, const char * clsName) :
+    
+    cls_StructSubscriber(m, clsName),
+
+  
+
+  
+  
+    m(m),
+    clsName(clsName)
+{
+    
+  
+
+}
+
+void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
+
+    
+
+  cls_StructSubscriber.doc() =
+    "NetworkTables struct-encoded value subscriber.";
+
+  cls_StructSubscriber
+  
+    
+  .
+def
+("get", static_cast<ValueType(nt::StructSubscriber<T, I>::*)() const>(
+        &nt::StructSubscriber<T, I>::Get), release_gil(), py::doc(
+    "Get the last published value.\n"
+"If no value has been published or the value cannot be unpacked, returns the\n"
+"stored default value.\n"
+"\n"
+":returns: value")
+  )
+  
+  
+  
+    
+  .
+def
+("get", static_cast<ValueType(nt::StructSubscriber<T, I>::*)(const T&) const>(
+        &nt::StructSubscriber<T, I>::Get),
+      py::arg("defaultValue"), release_gil(), py::doc(
+    "Get the last published value.\n"
+"If no value has been published or the value cannot be unpacked, returns the\n"
+"passed defaultValue.\n"
+"\n"
+":param defaultValue: default value to return if no value has been published\n"
+"\n"
+":returns: value")
+  )
+  
+  
+  
+    
+  .
+def
+("getAtomic", static_cast<TimestampedValueType(nt::StructSubscriber<T, I>::*)() const>(
+        &nt::StructSubscriber<T, I>::GetAtomic), release_gil(), py::doc(
+    "Get the last published value along with its timestamp\n"
+"If no value has been published or the value cannot be unpacked, returns the\n"
+"stored default value and a timestamp of 0.\n"
+"\n"
+":returns: timestamped value")
+  )
+  
+  
+  
+    
+  .
+def
+("getAtomic", static_cast<TimestampedValueType(nt::StructSubscriber<T, I>::*)(const T&) const>(
+        &nt::StructSubscriber<T, I>::GetAtomic),
+      py::arg("defaultValue"), release_gil(), py::doc(
+    "Get the last published value along with its timestamp.\n"
+"If no value has been published or the value cannot be unpacked, returns the\n"
+"passed defaultValue and a timestamp of 0.\n"
+"\n"
+":param defaultValue: default value to return if no value has been published\n"
+"\n"
+":returns: timestamped value")
+  )
+  
+  
+  
+    
+  .
+def
+("readQueue", &nt::StructSubscriber<T, I>::ReadQueue, release_gil(), py::doc(
+    "Get an array of all valid value changes since the last call to ReadQueue.\n"
+"Also provides a timestamp for each value. Values that cannot be unpacked\n"
+"are dropped.\n"
+"\n"
+".. note:: The \"poll storage\" subscribe option can be used to set the queue\n"
+"   depth.\n"
+"\n"
+":returns: Array of timestamped values; empty array if no valid new changes\n"
+"          have been published since the previous call.")
+  )
+  
+  
+  
+    
+  .
+def
+("getTopic", &nt::StructSubscriber<T, I>::GetTopic, release_gil(), py::doc(
+    "Get the corresponding topic.\n"
+"\n"
+":returns: Topic")
+  )
+  
+  
+  .def("close", [](nt::StructSubscriber<T, I> *self) {
+  py::gil_scoped_release release;
+  *self = nt::StructSubscriber<T, I>();
+}, py::doc("Destroys the subscriber"))
+.def("__enter__", [](nt::StructSubscriber<T, I> *self) {
+  return self;
+})
+.def("__exit__", [](nt::StructSubscriber<T, I> *self, py::args args) {
+  py::gil_scoped_release release;
+  *self = nt::StructSubscriber<T, I>();
+})
+;
+
+  
+
+
+
+    if (set_doc) {
+        cls_StructSubscriber.doc() = set_doc;
+    }
+    if (add_doc) {
+        cls_StructSubscriber.doc() = py::cast<std::string>(cls_StructSubscriber.doc()) + add_doc;
+    }
+
+    
+}
+
+}; // struct bind_nt__StructSubscriber
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/nt__StructTopic.hpp

```diff
@@ -1,221 +1,236 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\StructTopic.h>
-
-
-
-
-
-
-
-
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_json_type_caster.h>
-
-#include <wpystruct.h>
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-template <typename T, typename I>
-struct bind_nt__StructTopic {
-
-    
-
-    
-  
-  
-    using SubscriberType [[maybe_unused]] = typename nt::StructTopic<T, I>::SubscriberType;
-  
-    using PublisherType [[maybe_unused]] = typename nt::StructTopic<T, I>::PublisherType;
-  
-    using EntryType [[maybe_unused]] = typename nt::StructTopic<T, I>::EntryType;
-  
-    using ValueType [[maybe_unused]] = typename nt::StructTopic<T, I>::ValueType;
-  
-    using ParamType [[maybe_unused]] = typename nt::StructTopic<T, I>::ParamType;
-  
-    using TimestampedValueType [[maybe_unused]] = typename nt::StructTopic<T, I>::TimestampedValueType;
-  
-
-    
-
-    py::class_<typename nt::StructTopic<T, I>, nt::Topic> cls_StructTopic;
-
-    
-
-    
-    
-
-    py::module &m;
-    std::string clsName;
-
-bind_nt__StructTopic(py::module &m, const char * clsName) :
-    
-    cls_StructTopic(m, clsName, py::is_final()),
-
-  
-
-  
-  
-    m(m),
-    clsName(clsName)
-{
-    
-  
-
-}
-
-void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
-
-    
-
-  cls_StructTopic.doc() =
-    "NetworkTables struct-encoded value topic.";
-
-  cls_StructTopic
-  
-    
-  .
-def
-("subscribe", &nt::StructTopic<T, I>::Subscribe,
-      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
-    "Create a new subscriber to the topic.\n"
-"\n"
-"The subscriber is only active as long as the returned object\n"
-"is not destroyed.\n"
-"\n"
-".. note:: Subscribers that do not match the published data type do not return\n"
-"   any values. To determine if the data type matches, use the appropriate\n"
-"   Topic functions.\n"
-"\n"
-":param defaultValue: default value used when a default is not provided to a\n"
-"                     getter function\n"
-":param options:      subscribe options\n"
-"\n"
-":returns: subscriber")
-  )
-  
-  
-  
-    
-  .
-def
-("publish", &nt::StructTopic<T, I>::Publish,
-      py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
-    "Create a new publisher to the topic.\n"
-"\n"
-"The publisher is only active as long as the returned object\n"
-"is not destroyed.\n"
-"\n"
-".. note:: It is not possible to publish two different data types to the same\n"
-"   topic. Conflicts between publishers are typically resolved by the\n"
-"   server on a first-come, first-served basis. Any published values that\n"
-"   do not match the topic's data type are dropped (ignored). To determine\n"
-"   if the data type matches, use the appropriate Topic functions.\n"
-"\n"
-":param options: publish options\n"
-"\n"
-":returns: publisher")
-  )
-  
-  
-  
-    
-  .
-def
-("publishEx", &nt::StructTopic<T, I>::PublishEx,
-      py::arg("properties"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
-    "Create a new publisher to the topic, with type string and initial\n"
-"properties.\n"
-"\n"
-"The publisher is only active as long as the returned object\n"
-"is not destroyed.\n"
-"\n"
-".. note:: It is not possible to publish two different data types to the same\n"
-"   topic. Conflicts between publishers are typically resolved by the\n"
-"   server on a first-come, first-served basis. Any published values that\n"
-"   do not match the topic's data type are dropped (ignored). To determine\n"
-"   if the data type matches, use the appropriate Topic functions.\n"
-"\n"
-":param properties: JSON properties\n"
-":param options:    publish options\n"
-"\n"
-":returns: publisher")
-  )
-  
-  
-  
-    
-  .
-def
-("getEntry", &nt::StructTopic<T, I>::GetEntry,
-      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
-    "Create a new entry for the topic.\n"
-"\n"
-"Entries act as a combination of a subscriber and a weak publisher. The\n"
-"subscriber is active as long as the entry is not destroyed. The publisher\n"
-"is created when the entry is first written to, and remains active until\n"
-"either Unpublish() is called or the entry is destroyed.\n"
-"\n"
-".. note:: It is not possible to use two different data types with the same\n"
-"   topic. Conflicts between publishers are typically resolved by the\n"
-"   server on a first-come, first-served basis. Any published values that\n"
-"   do not match the topic's data type are dropped (ignored), and the entry\n"
-"   will show no new values if the data type does not match. To determine\n"
-"   if the data type matches, use the appropriate Topic functions.\n"
-"\n"
-":param defaultValue: default value used when a default is not provided to a\n"
-"                     getter function\n"
-":param options:      publish and/or subscribe options\n"
-"\n"
-":returns: entry")
-  )
-  
-  
-  .def("close", [](nt::StructTopic<T, I> *self) {
-  py::gil_scoped_release release;
-  *self = nt::StructTopic<T, I>();
-}, py::doc("Destroys the topic"))
-.def("__enter__", [](nt::StructTopic<T, I> *self) {
-  return self;
-})
-.def("__exit__", [](nt::StructTopic<T, I> *self, py::args args) {
-  py::gil_scoped_release release;
-  *self = nt::StructTopic<T, I>();
-})
-;
-
-  
-
-
-
-    if (set_doc) {
-        cls_StructTopic.doc() = set_doc;
-    }
-    if (add_doc) {
-        cls_StructTopic.doc() = py::cast<std::string>(cls_StructTopic.doc()) + add_doc;
-    }
-
-    
-}
-
-}; // struct bind_nt__StructTopic
-
-}; // namespace rpygen
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/StructTopic.h>
+
+
+
+
+
+
+
+
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_json_type_caster.h>
+
+#include <wpystruct.h>
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+template <typename T, typename I>
+struct bind_nt__StructTopic {
+
+    
+
+    
+  
+  
+    using SubscriberType [[maybe_unused]] = typename nt::StructTopic<T, I>::SubscriberType;
+  
+    using PublisherType [[maybe_unused]] = typename nt::StructTopic<T, I>::PublisherType;
+  
+    using EntryType [[maybe_unused]] = typename nt::StructTopic<T, I>::EntryType;
+  
+    using ValueType [[maybe_unused]] = typename nt::StructTopic<T, I>::ValueType;
+  
+    using ParamType [[maybe_unused]] = typename nt::StructTopic<T, I>::ParamType;
+  
+    using TimestampedValueType [[maybe_unused]] = typename nt::StructTopic<T, I>::TimestampedValueType;
+  
+
+    
+
+    py::class_<typename nt::StructTopic<T, I>, nt::Topic> cls_StructTopic;
+
+    
+
+    
+    
+
+    py::module &m;
+    std::string clsName;
+
+bind_nt__StructTopic(py::module &m, const char * clsName) :
+    
+    cls_StructTopic(m, clsName, py::is_final()),
+
+  
+
+  
+  
+    m(m),
+    clsName(clsName)
+{
+    
+  
+
+}
+
+void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
+
+    
+
+  cls_StructTopic.doc() =
+    "NetworkTables struct-encoded value topic.";
+
+  cls_StructTopic
+  
+    
+  .def(py::init([](Topic topic, const py::type &t) {
+  WPyStructInfo info(t);
+  return nt::StructTopic<T, I>(topic, info);
+}
+),
+      py::arg("topic"), py::arg("type"), py::doc(
+    "Construct from a generic topic.\n"
+"\n"
+":param topic: Topic\n"
+":param type:  optional struct type info")
+  )
+  
+  
+  
+    
+  .
+def
+("subscribe", &nt::StructTopic<T, I>::Subscribe,
+      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
+    "Create a new subscriber to the topic.\n"
+"\n"
+"The subscriber is only active as long as the returned object\n"
+"is not destroyed.\n"
+"\n"
+".. note:: Subscribers that do not match the published data type do not return\n"
+"   any values. To determine if the data type matches, use the appropriate\n"
+"   Topic functions.\n"
+"\n"
+":param defaultValue: default value used when a default is not provided to a\n"
+"                     getter function\n"
+":param options:      subscribe options\n"
+"\n"
+":returns: subscriber")
+  )
+  
+  
+  
+    
+  .
+def
+("publish", &nt::StructTopic<T, I>::Publish,
+      py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
+    "Create a new publisher to the topic.\n"
+"\n"
+"The publisher is only active as long as the returned object\n"
+"is not destroyed.\n"
+"\n"
+".. note:: It is not possible to publish two different data types to the same\n"
+"   topic. Conflicts between publishers are typically resolved by the\n"
+"   server on a first-come, first-served basis. Any published values that\n"
+"   do not match the topic's data type are dropped (ignored). To determine\n"
+"   if the data type matches, use the appropriate Topic functions.\n"
+"\n"
+":param options: publish options\n"
+"\n"
+":returns: publisher")
+  )
+  
+  
+  
+    
+  .
+def
+("publishEx", &nt::StructTopic<T, I>::PublishEx,
+      py::arg("properties"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
+    "Create a new publisher to the topic, with type string and initial\n"
+"properties.\n"
+"\n"
+"The publisher is only active as long as the returned object\n"
+"is not destroyed.\n"
+"\n"
+".. note:: It is not possible to publish two different data types to the same\n"
+"   topic. Conflicts between publishers are typically resolved by the\n"
+"   server on a first-come, first-served basis. Any published values that\n"
+"   do not match the topic's data type are dropped (ignored). To determine\n"
+"   if the data type matches, use the appropriate Topic functions.\n"
+"\n"
+":param properties: JSON properties\n"
+":param options:    publish options\n"
+"\n"
+":returns: publisher")
+  )
+  
+  
+  
+    
+  .
+def
+("getEntry", &nt::StructTopic<T, I>::GetEntry,
+      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
+    "Create a new entry for the topic.\n"
+"\n"
+"Entries act as a combination of a subscriber and a weak publisher. The\n"
+"subscriber is active as long as the entry is not destroyed. The publisher\n"
+"is created when the entry is first written to, and remains active until\n"
+"either Unpublish() is called or the entry is destroyed.\n"
+"\n"
+".. note:: It is not possible to use two different data types with the same\n"
+"   topic. Conflicts between publishers are typically resolved by the\n"
+"   server on a first-come, first-served basis. Any published values that\n"
+"   do not match the topic's data type are dropped (ignored), and the entry\n"
+"   will show no new values if the data type does not match. To determine\n"
+"   if the data type matches, use the appropriate Topic functions.\n"
+"\n"
+":param defaultValue: default value used when a default is not provided to a\n"
+"                     getter function\n"
+":param options:      publish and/or subscribe options\n"
+"\n"
+":returns: entry")
+  )
+  
+  
+  .def("close", [](nt::StructTopic<T, I> *self) {
+  py::gil_scoped_release release;
+  *self = nt::StructTopic<T, I>();
+}, py::doc("Destroys the topic"))
+.def("__enter__", [](nt::StructTopic<T, I> *self) {
+  return self;
+})
+.def("__exit__", [](nt::StructTopic<T, I> *self, py::args args) {
+  py::gil_scoped_release release;
+  *self = nt::StructTopic<T, I>();
+})
+;
+
+  
+
+
+
+    if (set_doc) {
+        cls_StructTopic.doc() = set_doc;
+    }
+    if (add_doc) {
+        cls_StructTopic.doc() = py::cast<std::string>(cls_StructTopic.doc()) + add_doc;
+    }
+
+    
+}
+
+}; // struct bind_nt__StructTopic
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/nt__Subscriber.hpp

```diff
@@ -1,77 +1,77 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <networktables\Topic.h>
-
-
-#include <networktables/GenericEntry.h>
-
-#include <networktables/NetworkTableInstance.h>
-
-
-
-
-
-
-
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-
-template <typename CfgBase = EmptyTrampolineCfg>
-struct PyTrampolineCfg_nt__Subscriber :
-
-    CfgBase
-
-{
-    using Base = nt::Subscriber;
-
-    
-    
-};
-
-
-
-template <typename PyTrampolineBase, typename PyTrampolineCfg>
-struct PyTrampoline_nt__Subscriber : PyTrampolineBase, virtual py::trampoline_self_life_support {
-    using PyTrampolineBase::PyTrampolineBase;
-
-
-
-
-
-
-
-
-
-
-
-    
-    
-
-    
-    
-
-    
-    using nt::Subscriber::m_subHandle;
-    
-
-    
-};
-
-}; // namespace rpygen
-
-
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <networktables/Topic.h>
+
+
+#include <networktables/GenericEntry.h>
+
+#include <networktables/NetworkTableInstance.h>
+
+
+
+
+
+
+
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+
+template <typename CfgBase = EmptyTrampolineCfg>
+struct PyTrampolineCfg_nt__Subscriber :
+
+    CfgBase
+
+{
+    using Base = nt::Subscriber;
+
+    
+    
+};
+
+
+
+template <typename PyTrampolineBase, typename PyTrampolineCfg>
+struct PyTrampoline_nt__Subscriber : PyTrampolineBase, virtual py::trampoline_self_life_support {
+    using PyTrampolineBase::PyTrampolineBase;
+
+
+
+
+
+
+
+
+
+
+
+    
+    
+
+    
+    
+
+    
+    using nt::Subscriber::m_subHandle;
+    
+
+    
+};
+
+}; // namespace rpygen
+
+
```

## ntcore/rpy-include/rpygen/nt__Timestamped.hpp

 * *Ordering differences only*

```diff
@@ -1,131 +1,131 @@
-
-
-// This file is autogenerated. DO NOT EDIT
-
-#pragma once
-#include <robotpy_build.h>
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <src/nt_type_caster.h>
-
-
-
-
-
-
-
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-namespace rpygen {
-
-
-using namespace nt;
-
-
-
-
-template <typename T>
-struct bind_nt__Timestamped {
-
-    
-
-    
-  
-  
-
-    
-
-    py::class_<typename nt::Timestamped<T>> cls_Timestamped;
-
-    
-
-    
-    
-
-    py::module &m;
-    std::string clsName;
-
-bind_nt__Timestamped(py::module &m, const char * clsName) :
-    
-    cls_Timestamped(m, clsName),
-
-  
-
-  
-  
-    m(m),
-    clsName(clsName)
-{
-    
-  
-
-}
-
-void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
-
-    
-
-  cls_Timestamped.doc() =
-    "Timestamped value.\n"
-"@ingroup ntcore_cpp_handle_api";
-
-  cls_Timestamped
-  
-    
-  .def(py::init<>(), release_gil()
-  )
-  
-  
-  
-    
-  .def(py::init<int64_t, int64_t, T>(),
-      py::arg("time"), py::arg("serverTime"), py::arg("value"), release_gil()
-  )
-  
-  
-  
-    .def_readwrite("time", &nt::Timestamped<T>::time, py::doc(
-    "Time in local time base."))
-  
-    .def_readwrite("serverTime", &nt::Timestamped<T>::serverTime, py::doc(
-    "Time in server time base.  May be 0 or 1 for locally set values."))
-  
-    .def_readwrite("value", &nt::Timestamped<T>::value, py::doc(
-    "Value."))
-  ;
-// capture class name by value
-auto clsname = clsName;
-cls_Timestamped.def("__repr__", [clsname](const Timestamped<T>& self) -> py::str {
-  return py::str("{}(time={}, serverTime={}, value={!r})")
-    .format(clsname, self.time, self.serverTime, self.value);
-})
-;
-
-  
-
-
-
-    if (set_doc) {
-        cls_Timestamped.doc() = set_doc;
-    }
-    if (add_doc) {
-        cls_Timestamped.doc() = py::cast<std::string>(cls_Timestamped.doc()) + add_doc;
-    }
-
-    
-}
-
-}; // struct bind_nt__Timestamped
-
-}; // namespace rpygen
+
+
+// This file is autogenerated. DO NOT EDIT
+
+#pragma once
+#include <robotpy_build.h>
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <src/nt_type_caster.h>
+
+
+
+
+
+
+
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+namespace rpygen {
+
+
+using namespace nt;
+
+
+
+
+template <typename T>
+struct bind_nt__Timestamped {
+
+    
+
+    
+  
+  
+
+    
+
+    py::class_<typename nt::Timestamped<T>> cls_Timestamped;
+
+    
+
+    
+    
+
+    py::module &m;
+    std::string clsName;
+
+bind_nt__Timestamped(py::module &m, const char * clsName) :
+    
+    cls_Timestamped(m, clsName),
+
+  
+
+  
+  
+    m(m),
+    clsName(clsName)
+{
+    
+  
+
+}
+
+void finish(const char * set_doc = NULL, const char * add_doc = NULL) {
+
+    
+
+  cls_Timestamped.doc() =
+    "Timestamped value.\n"
+"@ingroup ntcore_cpp_handle_api";
+
+  cls_Timestamped
+  
+    
+  .def(py::init<>(), release_gil()
+  )
+  
+  
+  
+    
+  .def(py::init<int64_t, int64_t, T>(),
+      py::arg("time"), py::arg("serverTime"), py::arg("value"), release_gil()
+  )
+  
+  
+  
+    .def_readwrite("time", &nt::Timestamped<T>::time, py::doc(
+    "Time in local time base."))
+  
+    .def_readwrite("serverTime", &nt::Timestamped<T>::serverTime, py::doc(
+    "Time in server time base.  May be 0 or 1 for locally set values."))
+  
+    .def_readwrite("value", &nt::Timestamped<T>::value, py::doc(
+    "Value."))
+  ;
+// capture class name by value
+auto clsname = clsName;
+cls_Timestamped.def("__repr__", [clsname](const Timestamped<T>& self) -> py::str {
+  return py::str("{}(time={}, serverTime={}, value={!r})")
+    .format(clsname, self.time, self.serverTime, self.value);
+})
+;
+
+  
+
+
+
+    if (set_doc) {
+        cls_Timestamped.doc() = set_doc;
+    }
+    if (add_doc) {
+        cls_Timestamped.doc() = py::cast<std::string>(cls_Timestamped.doc()) + add_doc;
+    }
+
+    
+}
+
+}; // struct bind_nt__Timestamped
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl1.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<bool>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_0::bind_nt__Timestamped_0(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_0::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<bool>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_0::bind_nt__Timestamped_0(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_0::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl10.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<std::vector<double>>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_9::bind_nt__Timestamped_9(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_9::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<std::vector<double>>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_9::bind_nt__Timestamped_9(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_9::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl11.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<std::vector<std::string>>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_10::bind_nt__Timestamped_10(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_10::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<std::vector<std::string>>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_10::bind_nt__Timestamped_10(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_10::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl12.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<WPyStruct>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_11::bind_nt__Timestamped_11(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_11::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<WPyStruct>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_11::bind_nt__Timestamped_11(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_11::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl13.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<std::vector<WPyStruct>>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_12::bind_nt__Timestamped_12(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_12::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<std::vector<WPyStruct>>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_12::bind_nt__Timestamped_12(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_12::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl2.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<int64_t>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_1::bind_nt__Timestamped_1(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_1::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<int64_t>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_1::bind_nt__Timestamped_1(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_1::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl3.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<float>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_2::bind_nt__Timestamped_2(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_2::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<float>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_2::bind_nt__Timestamped_2(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_2::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl4.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<double>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_3::bind_nt__Timestamped_3(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_3::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<double>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_3::bind_nt__Timestamped_3(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_3::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl5.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<std::string>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_4::bind_nt__Timestamped_4(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_4::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<std::string>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_4::bind_nt__Timestamped_4(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_4::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl6.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<std::vector<uint8_t>>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_5::bind_nt__Timestamped_5(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_5::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<std::vector<uint8_t>>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_5::bind_nt__Timestamped_5(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_5::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl7.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<std::vector<int>>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_6::bind_nt__Timestamped_6(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_6::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<std::vector<int>>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_6::bind_nt__Timestamped_6(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_6::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl8.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<std::vector<int64_t>>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_7::bind_nt__Timestamped_7(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_7::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<std::vector<int64_t>>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_7::bind_nt__Timestamped_7(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_7::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl9.cpp

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-// This file is autogenerated. DO NOT EDIT
-#include <robotpy_build.h>
-
-
-
-
-#include <ntcore_cpp_types.h>
-
-
-#include <pybind11/stl.h>
-
-#include <wpi_span_type_caster.h>
-
-#include <wpystruct.h>
-
-
-
-
-
-
-
-
-#include <rpygen/nt__Timestamped.hpp>
-#include "ntcore_cpp_types_tmpl.hpp"
-
-namespace rpygen {
-
-using BindType = rpygen::bind_nt__Timestamped<std::vector<float>>;
-static std::unique_ptr<BindType> inst;
-
-bind_nt__Timestamped_8::bind_nt__Timestamped_8(py::module &m, const char * clsName)
-{
-    inst = std::make_unique<BindType>(m, clsName);
-}
-
-void bind_nt__Timestamped_8::finish(const char *set_doc, const char *add_doc)
-{
-    inst->finish(set_doc, add_doc);
-    inst.reset();
-}
-
-}; // namespace rpygen
+// This file is autogenerated. DO NOT EDIT
+#include <robotpy_build.h>
+
+
+
+
+#include <ntcore_cpp_types.h>
+
+
+#include <pybind11/stl.h>
+
+#include <wpi_span_type_caster.h>
+
+#include <wpystruct.h>
+
+
+
+
+
+
+
+
+#include <rpygen/nt__Timestamped.hpp>
+#include "ntcore_cpp_types_tmpl.hpp"
+
+namespace rpygen {
+
+using BindType = rpygen::bind_nt__Timestamped<std::vector<float>>;
+static std::unique_ptr<BindType> inst;
+
+bind_nt__Timestamped_8::bind_nt__Timestamped_8(py::module &m, const char * clsName)
+{
+    inst = std::make_unique<BindType>(m, clsName);
+}
+
+void bind_nt__Timestamped_8::finish(const char *set_doc, const char *add_doc)
+{
+    inst->finish(set_doc, add_doc);
+    inst.reset();
+}
+
+}; // namespace rpygen
```

## ntcore/src/NetworkTable.cpp.inl

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-cls_NetworkTable
-    .def("getValue", [](const NetworkTable &self, std::string_view key, py::object defaultValue) -> py::object {
-        nt::NetworkTableEntry entry;
-        {
-            py::gil_scoped_release release;
-            entry = self.GetEntry(key);
-        }
-        return pyntcore::GetValueEntry(entry, defaultValue);
-    }, py::arg("key"), py::arg("value"))
-
-    // double overload must come before boolean version
-    .def("putValue", [](nt::NetworkTable *self, std::string_view key, double value) {
-        return self->PutValue(key, nt::Value::MakeDouble(value));
-    }, py::arg("key"), py::arg("value"), release_gil())
-    .def("putValue", [](nt::NetworkTable *self, std::string_view key, bool value) {
-        return self->PutValue(key, nt::Value::MakeBoolean(value));
-    }, py::arg("key"), py::arg("value"), release_gil())
-    .def("putValue", [](nt::NetworkTable *self, std::string_view key, py::bytes value) {
-        auto v = nt::Value::MakeRaw(value.cast<std::span<const uint8_t>>());
-        py::gil_scoped_release release;
-        return self->PutValue(key, v);
-    }, py::arg("key"), py::arg("value"))
-    .def("putValue", [](nt::NetworkTable *self, std::string_view key, std::string value) {
-        return self->PutValue(key, nt::Value::MakeString(std::move(value)));
-    }, py::arg("key"), py::arg("value"), release_gil())
-    .def("putValue", [](nt::NetworkTable *self, std::string_view key, py::sequence value) {
-        auto v = pyntcore::py2ntvalue(value);
-        py::gil_scoped_release release;
-        return self->PutValue(key, v);
-    }, py::arg("key"), py::arg("value"))
-
-    // double overload must come before boolean version
-    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, double value) {
-        return self->SetDefaultValue(key, nt::Value::MakeDouble(value));
-    }, py::arg("key"), py::arg("value"), release_gil())
-    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, bool value) {
-        return self->SetDefaultValue(key, nt::Value::MakeBoolean(value));
-    }, py::arg("key"), py::arg("value"), release_gil())
-    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, py::bytes value) {
-        auto v = nt::Value::MakeRaw(value.cast<std::span<const uint8_t>>());
-        py::gil_scoped_release release;
-        return self->SetDefaultValue(key, v);
-    }, py::arg("key"), py::arg("value"))
-    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, std::string value) {
-        return self->SetDefaultValue(key, nt::Value::MakeString(std::move(value)));
-    }, py::arg("key"), py::arg("value"), release_gil())
-    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, py::sequence value) {
-        auto v = pyntcore::py2ntvalue(value);
-        py::gil_scoped_release release;
-        return self->SetDefaultValue(key, v);
-    }, py::arg("key"), py::arg("value"))
-
-    .def("__contains__", [](const nt::NetworkTable &self, std::string_view key) -> bool {
-        return self.ContainsKey(key);
-    }, release_gil())
-;
+cls_NetworkTable
+    .def("getValue", [](const NetworkTable &self, std::string_view key, py::object defaultValue) -> py::object {
+        nt::NetworkTableEntry entry;
+        {
+            py::gil_scoped_release release;
+            entry = self.GetEntry(key);
+        }
+        return pyntcore::GetValueEntry(entry, defaultValue);
+    }, py::arg("key"), py::arg("value"))
+
+    // double overload must come before boolean version
+    .def("putValue", [](nt::NetworkTable *self, std::string_view key, double value) {
+        return self->PutValue(key, nt::Value::MakeDouble(value));
+    }, py::arg("key"), py::arg("value"), release_gil())
+    .def("putValue", [](nt::NetworkTable *self, std::string_view key, bool value) {
+        return self->PutValue(key, nt::Value::MakeBoolean(value));
+    }, py::arg("key"), py::arg("value"), release_gil())
+    .def("putValue", [](nt::NetworkTable *self, std::string_view key, py::bytes value) {
+        auto v = nt::Value::MakeRaw(value.cast<std::span<const uint8_t>>());
+        py::gil_scoped_release release;
+        return self->PutValue(key, v);
+    }, py::arg("key"), py::arg("value"))
+    .def("putValue", [](nt::NetworkTable *self, std::string_view key, std::string value) {
+        return self->PutValue(key, nt::Value::MakeString(std::move(value)));
+    }, py::arg("key"), py::arg("value"), release_gil())
+    .def("putValue", [](nt::NetworkTable *self, std::string_view key, py::sequence value) {
+        auto v = pyntcore::py2ntvalue(value);
+        py::gil_scoped_release release;
+        return self->PutValue(key, v);
+    }, py::arg("key"), py::arg("value"))
+
+    // double overload must come before boolean version
+    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, double value) {
+        return self->SetDefaultValue(key, nt::Value::MakeDouble(value));
+    }, py::arg("key"), py::arg("value"), release_gil())
+    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, bool value) {
+        return self->SetDefaultValue(key, nt::Value::MakeBoolean(value));
+    }, py::arg("key"), py::arg("value"), release_gil())
+    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, py::bytes value) {
+        auto v = nt::Value::MakeRaw(value.cast<std::span<const uint8_t>>());
+        py::gil_scoped_release release;
+        return self->SetDefaultValue(key, v);
+    }, py::arg("key"), py::arg("value"))
+    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, std::string value) {
+        return self->SetDefaultValue(key, nt::Value::MakeString(std::move(value)));
+    }, py::arg("key"), py::arg("value"), release_gil())
+    .def("setDefaultValue", [](nt::NetworkTable *self, std::string_view key, py::sequence value) {
+        auto v = pyntcore::py2ntvalue(value);
+        py::gil_scoped_release release;
+        return self->SetDefaultValue(key, v);
+    }, py::arg("key"), py::arg("value"))
+
+    .def("__contains__", [](const nt::NetworkTable &self, std::string_view key) -> bool {
+        return self.ContainsKey(key);
+    }, release_gil())
+;
```

## ntcore/src/NetworkTableEntry.cpp.inl

 * *Ordering differences only*

```diff
@@ -1,48 +1,48 @@
-cls_NetworkTableEntry
-    .def_property_readonly("value", [](const nt::NetworkTableEntry &self) {
-        nt::Value v;
-        {
-            py::gil_scoped_release release;
-            v = self.GetValue();
-        }
-        return pyntcore::ntvalue2py(v);
-    })
-
-    // double overload must come before boolean version
-    .def("setValue", [](nt::NetworkTableEntry *self, double value) {
-        return self->SetValue(nt::Value::MakeDouble(value));
-    }, py::arg("value"), release_gil())
-    .def("setValue", [](nt::NetworkTableEntry *self, bool value) {
-        return self->SetValue(nt::Value::MakeBoolean(value));
-    }, py::arg("value"), release_gil())
-    .def("setValue", [](nt::NetworkTableEntry *self, py::bytes value) {
-        auto v = nt::Value::MakeRaw(value.cast<std::span<const uint8_t>>());
-        py::gil_scoped_release release;
-        return self->SetValue(v);
-    }, py::arg("value"))
-    .def("setValue", [](nt::NetworkTableEntry *self, std::string value) {
-        return self->SetValue(nt::Value::MakeString(value));
-    }, py::arg("value"), release_gil())
-    .def("setValue", [](nt::NetworkTableEntry *self, py::sequence value) {
-        return self->SetValue(pyntcore::py2ntvalue(value));
-    }, py::arg("value"))
-
-    // double overload must come before boolean version
-    .def("setDefaultValue", [](nt::NetworkTableEntry *self, double value) {
-        return self->SetDefaultValue(nt::Value::MakeDouble(value));
-    }, py::arg("value"), release_gil())
-    .def("setDefaultValue", [](nt::NetworkTableEntry *self, bool value) {
-        return self->SetDefaultValue(nt::Value::MakeBoolean(value));
-    }, py::arg("value"), release_gil())
-    .def("setDefaultValue", [](nt::NetworkTableEntry *self, py::bytes value) {
-        auto v = nt::Value::MakeRaw(value.cast<std::span<const uint8_t>>());
-        py::gil_scoped_release release;
-        return self->SetDefaultValue(v);
-    }, py::arg("value"))
-    .def("setDefaultValue", [](nt::NetworkTableEntry *self, std::string value) {
-        return self->SetDefaultValue(nt::Value::MakeString(value));
-    }, py::arg("value"), release_gil())
-    .def("setDefaultValue", [](nt::NetworkTableEntry *self, py::sequence value) {
-        return self->SetDefaultValue(pyntcore::py2ntvalue(value));
-    }, py::arg("value"))
-;
+cls_NetworkTableEntry
+    .def_property_readonly("value", [](const nt::NetworkTableEntry &self) {
+        nt::Value v;
+        {
+            py::gil_scoped_release release;
+            v = self.GetValue();
+        }
+        return pyntcore::ntvalue2py(v);
+    })
+
+    // double overload must come before boolean version
+    .def("setValue", [](nt::NetworkTableEntry *self, double value) {
+        return self->SetValue(nt::Value::MakeDouble(value));
+    }, py::arg("value"), release_gil())
+    .def("setValue", [](nt::NetworkTableEntry *self, bool value) {
+        return self->SetValue(nt::Value::MakeBoolean(value));
+    }, py::arg("value"), release_gil())
+    .def("setValue", [](nt::NetworkTableEntry *self, py::bytes value) {
+        auto v = nt::Value::MakeRaw(value.cast<std::span<const uint8_t>>());
+        py::gil_scoped_release release;
+        return self->SetValue(v);
+    }, py::arg("value"))
+    .def("setValue", [](nt::NetworkTableEntry *self, std::string value) {
+        return self->SetValue(nt::Value::MakeString(value));
+    }, py::arg("value"), release_gil())
+    .def("setValue", [](nt::NetworkTableEntry *self, py::sequence value) {
+        return self->SetValue(pyntcore::py2ntvalue(value));
+    }, py::arg("value"))
+
+    // double overload must come before boolean version
+    .def("setDefaultValue", [](nt::NetworkTableEntry *self, double value) {
+        return self->SetDefaultValue(nt::Value::MakeDouble(value));
+    }, py::arg("value"), release_gil())
+    .def("setDefaultValue", [](nt::NetworkTableEntry *self, bool value) {
+        return self->SetDefaultValue(nt::Value::MakeBoolean(value));
+    }, py::arg("value"), release_gil())
+    .def("setDefaultValue", [](nt::NetworkTableEntry *self, py::bytes value) {
+        auto v = nt::Value::MakeRaw(value.cast<std::span<const uint8_t>>());
+        py::gil_scoped_release release;
+        return self->SetDefaultValue(v);
+    }, py::arg("value"))
+    .def("setDefaultValue", [](nt::NetworkTableEntry *self, std::string value) {
+        return self->SetDefaultValue(nt::Value::MakeString(value));
+    }, py::arg("value"), release_gil())
+    .def("setDefaultValue", [](nt::NetworkTableEntry *self, py::sequence value) {
+        return self->SetDefaultValue(pyntcore::py2ntvalue(value));
+    }, py::arg("value"))
+;
```

## ntcore/src/nt_instance.cpp

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-#include <robotpy_build.h>
-#include "nt_instance.h"
-#include "ntcore_cpp.h"
-
-#include <set>
-
-// only accessed under GIL
-static std::set<NT_Inst> g_known_instances;
-
-namespace pyntcore {
-
-void onInstanceStart(nt::NetworkTableInstance *instance) {
-    g_known_instances.emplace(instance->GetHandle());
-
-    py::module::import("ntcore._logutil")
-        .attr("NtLogForwarder").attr("onInstanceStart")(instance);
-}
-
-void onInstancePreReset(nt::NetworkTableInstance *instance) {
-    py::module::import("ntcore._logutil")
-        .attr("NtLogForwarder").attr("onInstanceDestroy")(instance);
-}
-
-void onInstancePostReset(nt::NetworkTableInstance *instance) {
-    py::module::import("ntcore.util")
-        .attr("_NtProperty").attr("onInstancePostReset")(instance);
-}
-
-void onInstanceDestroy(nt::NetworkTableInstance *instance) {
-    py::module::import("ntcore._logutil")
-        .attr("NtLogForwarder").attr("onInstanceDestroy")(instance);
-    py::module::import("ntcore.util")
-        .attr("_NtProperty").attr("onInstanceDestroy")(instance);
-
-    g_known_instances.erase(instance->GetHandle());
-}
-
-// reset all instances to clear out any potential python references that
-// might be hanging around in a callback or something
-void resetAllInstances()
-{
-    std::set<NT_Inst> known_instances;
-    known_instances.swap(g_known_instances);
-
-    // always reset the default instance
-    known_instances.emplace(nt::GetDefaultInstance());
-
-    py::gil_scoped_release unlock;
-
-    for (auto &inst: known_instances) {
-        nt::ResetInstance(inst);
-    }
-}
-
-
+#include <robotpy_build.h>
+#include "nt_instance.h"
+#include "ntcore_cpp.h"
+
+#include <set>
+
+// only accessed under GIL
+static std::set<NT_Inst> g_known_instances;
+
+namespace pyntcore {
+
+void onInstanceStart(nt::NetworkTableInstance *instance) {
+    g_known_instances.emplace(instance->GetHandle());
+
+    py::module::import("ntcore._logutil")
+        .attr("NtLogForwarder").attr("onInstanceStart")(instance);
+}
+
+void onInstancePreReset(nt::NetworkTableInstance *instance) {
+    py::module::import("ntcore._logutil")
+        .attr("NtLogForwarder").attr("onInstanceDestroy")(instance);
+}
+
+void onInstancePostReset(nt::NetworkTableInstance *instance) {
+    py::module::import("ntcore.util")
+        .attr("_NtProperty").attr("onInstancePostReset")(instance);
+}
+
+void onInstanceDestroy(nt::NetworkTableInstance *instance) {
+    py::module::import("ntcore._logutil")
+        .attr("NtLogForwarder").attr("onInstanceDestroy")(instance);
+    py::module::import("ntcore.util")
+        .attr("_NtProperty").attr("onInstanceDestroy")(instance);
+
+    g_known_instances.erase(instance->GetHandle());
+}
+
+// reset all instances to clear out any potential python references that
+// might be hanging around in a callback or something
+void resetAllInstances()
+{
+    std::set<NT_Inst> known_instances;
+    known_instances.swap(g_known_instances);
+
+    // always reset the default instance
+    known_instances.emplace(nt::GetDefaultInstance());
+
+    py::gil_scoped_release unlock;
+
+    for (auto &inst: known_instances) {
+        nt::ResetInstance(inst);
+    }
+}
+
+
 }; // namespace pyntcore
```

## ntcore/src/nt_instance.h

 * *Ordering differences only*

```diff
@@ -1,16 +1,16 @@
-
-#pragma once
-
-#include <ntcore.h>
-#include <networktables/NetworkTableInstance.h>
-
-namespace pyntcore {
-
-void onInstanceStart(nt::NetworkTableInstance *instance);
-void onInstancePreReset(nt::NetworkTableInstance *instance);
-void onInstancePostReset(nt::NetworkTableInstance *instance);
-void onInstanceDestroy(nt::NetworkTableInstance *instance);
-
-void resetAllInstances();
-
-}; // namespace pyntcore
+
+#pragma once
+
+#include <ntcore.h>
+#include <networktables/NetworkTableInstance.h>
+
+namespace pyntcore {
+
+void onInstanceStart(nt::NetworkTableInstance *instance);
+void onInstancePreReset(nt::NetworkTableInstance *instance);
+void onInstancePostReset(nt::NetworkTableInstance *instance);
+void onInstanceDestroy(nt::NetworkTableInstance *instance);
+
+void resetAllInstances();
+
+}; // namespace pyntcore
```

## ntcore/src/nt_type_caster.h

 * *Ordering differences only*

```diff
@@ -1,39 +1,39 @@
-#pragma once
-
-#include <pybind11/pybind11.h>
-
-namespace pybind11 {
-namespace detail {
-
-// ntcore uses std::vector<uint8_t> anytime there is a raw value, so
-// add this specialization to convert to/from bytes directly
-
-template<>
-struct type_caster<std::vector<uint8_t>> {
-    using vector_type = std::vector<uint8_t>;
-    PYBIND11_TYPE_CASTER(vector_type, const_name("bytes"));
-
-    bool load(handle src, bool convert) {
-        if (!isinstance<buffer>(src)) {
-            return false;
-        }
-        auto buf = reinterpret_borrow<buffer>(src);
-        auto req = buf.request();
-        if (req.ndim != 1) {
-            return false;
-        }
-
-        auto begin = (const uint8_t*)req.ptr;
-        auto end = begin + req.size*req.itemsize;
-
-        value = std::vector<uint8_t>(begin, end);
-        return true;
-    }
-
-    static handle cast(const std::vector<uint8_t> &src, return_value_policy policy, handle parent) {
-        return py::bytes((char*)src.data(), src.size()).release();
-    }
-};
-
-}
+#pragma once
+
+#include <pybind11/pybind11.h>
+
+namespace pybind11 {
+namespace detail {
+
+// ntcore uses std::vector<uint8_t> anytime there is a raw value, so
+// add this specialization to convert to/from bytes directly
+
+template<>
+struct type_caster<std::vector<uint8_t>> {
+    using vector_type = std::vector<uint8_t>;
+    PYBIND11_TYPE_CASTER(vector_type, const_name("bytes"));
+
+    bool load(handle src, bool convert) {
+        if (!isinstance<buffer>(src)) {
+            return false;
+        }
+        auto buf = reinterpret_borrow<buffer>(src);
+        auto req = buf.request();
+        if (req.ndim != 1) {
+            return false;
+        }
+
+        auto begin = (const uint8_t*)req.ptr;
+        auto end = begin + req.size*req.itemsize;
+
+        value = std::vector<uint8_t>(begin, end);
+        return true;
+    }
+
+    static handle cast(const std::vector<uint8_t> &src, return_value_policy policy, handle parent) {
+        return py::bytes((char*)src.data(), src.size()).release();
+    }
+};
+
+}
 }
```

## ntcore/src/ntcore.cpp

 * *Ordering differences only*

```diff
@@ -1,14 +1,14 @@
-
-#include <rpygen_wrapper.hpp>
-#include "nt_instance.h"
-
-RPYBUILD_PYBIND11_MODULE(m) {
-  initWrapper(m);
-
-  static int unused;
-  py::capsule cleanup(&unused, [](void *) {
-    pyntcore::resetAllInstances();
-  });
-
-  m.add_object("_st_cleanup", cleanup);
+
+#include <rpygen_wrapper.hpp>
+#include "nt_instance.h"
+
+RPYBUILD_PYBIND11_MODULE(m) {
+  initWrapper(m);
+
+  static int unused;
+  py::capsule cleanup(&unused, [](void *) {
+    pyntcore::resetAllInstances();
+  });
+
+  m.add_object("_st_cleanup", cleanup);
 }
```

## ntcore/src/py2value.cpp

 * *Ordering differences only*

```diff
@@ -1,180 +1,180 @@
-
-#include "py2value.h"
-
-#include <vector>
-
-// type casters
-#include <pybind11/stl.h>
-#include <wpi_span_type_caster.h>
-
-
-
-namespace pyntcore {
-
-const char * nttype2str(NT_Type type) {
-  switch (type) {
-  case NT_BOOLEAN:
-    return "bool";
-  case NT_DOUBLE:
-    return "double";
-  case NT_STRING:
-    return "string";
-  case NT_RAW:
-    return "raw";
-  case NT_BOOLEAN_ARRAY:
-    return "bool[]";
-  case NT_DOUBLE_ARRAY:
-    return "double[]";
-  case NT_STRING_ARRAY:
-    return "string[]";
-  case NT_INTEGER:
-    return "int";
-  case NT_FLOAT:
-    return "float";
-  case NT_INTEGER_ARRAY:
-    return "int[]";
-  case NT_FLOAT_ARRAY:
-    return "float[]";
-  default:
-    return "invalid";
-  }
-}
-
-
-py::object ntvalue2py(const nt::Value &ntvalue) {
-  auto &v = ntvalue.value();
-  switch (v.type) {
-  case NT_BOOLEAN:
-    return py::bool_(v.data.v_boolean);
-
-  case NT_DOUBLE:
-    return py::float_(v.data.v_double);
-
-  case NT_STRING:
-    return py::str(v.data.v_string.str, v.data.v_string.len);
-
-  case NT_RAW:
-    return py::bytes((const char *)v.data.v_raw.data, v.data.v_raw.size);
-
-  case NT_BOOLEAN_ARRAY: {
-    py::list l(v.data.arr_boolean.size);
-    for (size_t i = 0; i < v.data.arr_boolean.size; i++) {
-      auto b = py::bool_(v.data.arr_boolean.arr[i]);
-      PyList_SET_ITEM(l.ptr(), i, b.release().ptr());
-    }
-    return std::move(l);
-  }
-
-  case NT_DOUBLE_ARRAY: {
-    py::list l(v.data.arr_double.size);
-    for (size_t i = 0; i < v.data.arr_double.size; i++) {
-      auto d = py::float_(v.data.arr_double.arr[i]);
-      PyList_SET_ITEM(l.ptr(), i, d.release().ptr());
-    }
-    return std::move(l);
-  }
-  
-  case NT_STRING_ARRAY: {
-    return py::cast(ntvalue.GetStringArray());
-  }
-
-  case NT_INTEGER: {
-    return py::int_(v.data.v_int);
-  }
-
-  case NT_FLOAT: {
-    return py::float_(v.data.v_float);
-  }
-
-  case NT_INTEGER_ARRAY: {
-    py::list l(v.data.arr_int.size);
-    for (size_t i = 0; i < v.data.arr_int.size; i++) {
-      auto d = py::int_(v.data.arr_int.arr[i]);
-      PyList_SET_ITEM(l.ptr(), i, d.release().ptr());
-    }
-    return std::move(l);
-  }
-
-  case NT_FLOAT_ARRAY: {
-    py::list l(v.data.arr_float.size);
-    for (size_t i = 0; i < v.data.arr_float.size; i++) {
-      auto d = py::float_(v.data.arr_float.arr[i]);
-      PyList_SET_ITEM(l.ptr(), i, d.release().ptr());
-    }
-    return std::move(l);
-  }
-
-  default:
-    return py::none();
-  }
-}
-
-nt::Value py2ntvalue(py::handle h) {
-  if (py::isinstance<py::bool_>(h)) {
-    return nt::Value::MakeBoolean(h.cast<bool>());
-  } else if (py::isinstance<py::float_>(h)) {
-    return nt::Value::MakeDouble(h.cast<double>());
-  } else if (py::isinstance<py::int_>(h)) {
-    return nt::Value::MakeInteger(h.cast<int64_t>());
-  } else if (py::isinstance<py::str>(h)) {
-    return nt::Value::MakeString(h.cast<std::string>());
-  } else if (py::isinstance<py::bytes>(h)) {
-    return nt::Value::MakeRaw(h.cast<std::span<const uint8_t>>());
-  } else if (py::isinstance<py::none>(h)) {
-    throw py::value_error("Cannot put None into NetworkTable");
-  }
-
-  auto seq = h.cast<py::sequence>();
-  if (seq.size() == 0) {
-    throw py::type_error("If you use a list here, cannot be empty");
-  }
-  // check the first item
-  auto i1 = seq[0];
-  if (py::isinstance<py::bool_>(i1)) {
-    auto v = h.cast<std::vector<int>>();
-    return nt::Value::MakeBooleanArray(v);
-  } else if (py::isinstance<py::float_>(i1)) {
-    auto v = h.cast<std::vector<double>>();
-    return nt::Value::MakeDoubleArray(v);
-  } else if (py::isinstance<py::int_>(i1)) {
-    auto v = h.cast<std::vector<int64_t>>();
-    return nt::Value::MakeIntegerArray(v);
-  } else if (py::isinstance<py::str>(i1)) {
-    auto v = h.cast<std::vector<std::string>>();
-    return nt::Value::MakeStringArray(v);
-  } else {
-    throw py::value_error("Can only put bool/int/float/str/bytes or lists/tuples of them");
-  }
-}
-
-py::function valueFactoryByType(nt::NetworkTableType type) {
-  py::object PyNtValue = py::module::import("ntcore").attr("Value");
-  switch (type) {
-  case nt::NetworkTableType::kBoolean:
-    return PyNtValue.attr("makeBoolean");
-  case nt::NetworkTableType::kDouble:
-    return PyNtValue.attr("makeDouble");
-  case nt::NetworkTableType::kString:
-    return PyNtValue.attr("makeString");
-  case nt::NetworkTableType::kRaw:
-    return PyNtValue.attr("makeRaw");
-  case nt::NetworkTableType::kBooleanArray: 
-    return PyNtValue.attr("makeBooleanArray");
-  case nt::NetworkTableType::kDoubleArray: 
-    return PyNtValue.attr("makeDoubleArray");
-  case nt::NetworkTableType::kStringArray:
-    return PyNtValue.attr("makeStringArray");
-  case nt::NetworkTableType::kInteger:
-    return PyNtValue.attr("makeInteger");
-  case nt::NetworkTableType::kFloat:
-    return PyNtValue.attr("makeFloat");
-  case nt::NetworkTableType::kIntegerArray:
-    return PyNtValue.attr("makeIntegerArray");
-  case nt::NetworkTableType::kFloatArray:
-    return PyNtValue.attr("makeFloatArray");
-  default:
-    throw py::type_error("empty nt value");
-  }
-}
-
-}
+
+#include "py2value.h"
+
+#include <vector>
+
+// type casters
+#include <pybind11/stl.h>
+#include <wpi_span_type_caster.h>
+
+
+
+namespace pyntcore {
+
+const char * nttype2str(NT_Type type) {
+  switch (type) {
+  case NT_BOOLEAN:
+    return "bool";
+  case NT_DOUBLE:
+    return "double";
+  case NT_STRING:
+    return "string";
+  case NT_RAW:
+    return "raw";
+  case NT_BOOLEAN_ARRAY:
+    return "bool[]";
+  case NT_DOUBLE_ARRAY:
+    return "double[]";
+  case NT_STRING_ARRAY:
+    return "string[]";
+  case NT_INTEGER:
+    return "int";
+  case NT_FLOAT:
+    return "float";
+  case NT_INTEGER_ARRAY:
+    return "int[]";
+  case NT_FLOAT_ARRAY:
+    return "float[]";
+  default:
+    return "invalid";
+  }
+}
+
+
+py::object ntvalue2py(const nt::Value &ntvalue) {
+  auto &v = ntvalue.value();
+  switch (v.type) {
+  case NT_BOOLEAN:
+    return py::bool_(v.data.v_boolean);
+
+  case NT_DOUBLE:
+    return py::float_(v.data.v_double);
+
+  case NT_STRING:
+    return py::str(v.data.v_string.str, v.data.v_string.len);
+
+  case NT_RAW:
+    return py::bytes((const char *)v.data.v_raw.data, v.data.v_raw.size);
+
+  case NT_BOOLEAN_ARRAY: {
+    py::list l(v.data.arr_boolean.size);
+    for (size_t i = 0; i < v.data.arr_boolean.size; i++) {
+      auto b = py::bool_(v.data.arr_boolean.arr[i]);
+      PyList_SET_ITEM(l.ptr(), i, b.release().ptr());
+    }
+    return std::move(l);
+  }
+
+  case NT_DOUBLE_ARRAY: {
+    py::list l(v.data.arr_double.size);
+    for (size_t i = 0; i < v.data.arr_double.size; i++) {
+      auto d = py::float_(v.data.arr_double.arr[i]);
+      PyList_SET_ITEM(l.ptr(), i, d.release().ptr());
+    }
+    return std::move(l);
+  }
+  
+  case NT_STRING_ARRAY: {
+    return py::cast(ntvalue.GetStringArray());
+  }
+
+  case NT_INTEGER: {
+    return py::int_(v.data.v_int);
+  }
+
+  case NT_FLOAT: {
+    return py::float_(v.data.v_float);
+  }
+
+  case NT_INTEGER_ARRAY: {
+    py::list l(v.data.arr_int.size);
+    for (size_t i = 0; i < v.data.arr_int.size; i++) {
+      auto d = py::int_(v.data.arr_int.arr[i]);
+      PyList_SET_ITEM(l.ptr(), i, d.release().ptr());
+    }
+    return std::move(l);
+  }
+
+  case NT_FLOAT_ARRAY: {
+    py::list l(v.data.arr_float.size);
+    for (size_t i = 0; i < v.data.arr_float.size; i++) {
+      auto d = py::float_(v.data.arr_float.arr[i]);
+      PyList_SET_ITEM(l.ptr(), i, d.release().ptr());
+    }
+    return std::move(l);
+  }
+
+  default:
+    return py::none();
+  }
+}
+
+nt::Value py2ntvalue(py::handle h) {
+  if (py::isinstance<py::bool_>(h)) {
+    return nt::Value::MakeBoolean(h.cast<bool>());
+  } else if (py::isinstance<py::float_>(h)) {
+    return nt::Value::MakeDouble(h.cast<double>());
+  } else if (py::isinstance<py::int_>(h)) {
+    return nt::Value::MakeInteger(h.cast<int64_t>());
+  } else if (py::isinstance<py::str>(h)) {
+    return nt::Value::MakeString(h.cast<std::string>());
+  } else if (py::isinstance<py::bytes>(h)) {
+    return nt::Value::MakeRaw(h.cast<std::span<const uint8_t>>());
+  } else if (py::isinstance<py::none>(h)) {
+    throw py::value_error("Cannot put None into NetworkTable");
+  }
+
+  auto seq = h.cast<py::sequence>();
+  if (seq.size() == 0) {
+    throw py::type_error("If you use a list here, cannot be empty");
+  }
+  // check the first item
+  auto i1 = seq[0];
+  if (py::isinstance<py::bool_>(i1)) {
+    auto v = h.cast<std::vector<int>>();
+    return nt::Value::MakeBooleanArray(v);
+  } else if (py::isinstance<py::float_>(i1)) {
+    auto v = h.cast<std::vector<double>>();
+    return nt::Value::MakeDoubleArray(v);
+  } else if (py::isinstance<py::int_>(i1)) {
+    auto v = h.cast<std::vector<int64_t>>();
+    return nt::Value::MakeIntegerArray(v);
+  } else if (py::isinstance<py::str>(i1)) {
+    auto v = h.cast<std::vector<std::string>>();
+    return nt::Value::MakeStringArray(v);
+  } else {
+    throw py::value_error("Can only put bool/int/float/str/bytes or lists/tuples of them");
+  }
+}
+
+py::function valueFactoryByType(nt::NetworkTableType type) {
+  py::object PyNtValue = py::module::import("ntcore").attr("Value");
+  switch (type) {
+  case nt::NetworkTableType::kBoolean:
+    return PyNtValue.attr("makeBoolean");
+  case nt::NetworkTableType::kDouble:
+    return PyNtValue.attr("makeDouble");
+  case nt::NetworkTableType::kString:
+    return PyNtValue.attr("makeString");
+  case nt::NetworkTableType::kRaw:
+    return PyNtValue.attr("makeRaw");
+  case nt::NetworkTableType::kBooleanArray: 
+    return PyNtValue.attr("makeBooleanArray");
+  case nt::NetworkTableType::kDoubleArray: 
+    return PyNtValue.attr("makeDoubleArray");
+  case nt::NetworkTableType::kStringArray:
+    return PyNtValue.attr("makeStringArray");
+  case nt::NetworkTableType::kInteger:
+    return PyNtValue.attr("makeInteger");
+  case nt::NetworkTableType::kFloat:
+    return PyNtValue.attr("makeFloat");
+  case nt::NetworkTableType::kIntegerArray:
+    return PyNtValue.attr("makeIntegerArray");
+  case nt::NetworkTableType::kFloatArray:
+    return PyNtValue.attr("makeFloatArray");
+  default:
+    throw py::type_error("empty nt value");
+  }
+}
+
+}
```

## ntcore/src/py2value.h

 * *Ordering differences only*

```diff
@@ -1,25 +1,25 @@
-
-#include <robotpy_build.h>
-#include <networktables/NetworkTableValue.h>
-#include <networktables/NetworkTableType.h>
-#include <fmt/format.h>
-
-namespace pyntcore {
-
-const char * nttype2str(NT_Type type);
-
-py::object ntvalue2py(const nt::Value &ntvalue);
-
-nt::Value py2ntvalue(py::handle h);
-
-py::function valueFactoryByType(nt::NetworkTableType type);
-
-inline void ensure_value_is(NT_Type expected, nt::Value *v) {
-    if (v->type() != expected) {
-        throw py::value_error(fmt::format(
-            "Value type is {}, not {}", nttype2str(v->type()), nttype2str(expected)
-        ));
-    }
-}
-
+
+#include <robotpy_build.h>
+#include <networktables/NetworkTableValue.h>
+#include <networktables/NetworkTableType.h>
+#include <fmt/format.h>
+
+namespace pyntcore {
+
+const char * nttype2str(NT_Type type);
+
+py::object ntvalue2py(const nt::Value &ntvalue);
+
+nt::Value py2ntvalue(py::handle h);
+
+py::function valueFactoryByType(nt::NetworkTableType type);
+
+inline void ensure_value_is(NT_Type expected, nt::Value *v) {
+    if (v->type() != expected) {
+        throw py::value_error(fmt::format(
+            "Value type is {}, not {}", nttype2str(v->type()), nttype2str(expected)
+        ));
+    }
+}
+
 };
```

## ntcore/src/pyentry.cpp

 * *Ordering differences only*

```diff
@@ -1,141 +1,141 @@
-
-#include "pyentry.h"
-#include "py2value.h"
-
-#include <pybind11/stl.h>
-#include <wpi_span_type_caster.h>
-
-namespace pyntcore {
-
-py::object GetBooleanEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_BOOLEAN) return defaultValue;
-    return py::cast(value.GetBoolean());
-}
-
-py::object GetDoubleEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_DOUBLE) return defaultValue;
-    return py::cast(value.GetDouble());
-}
-
-py::object GetFloatEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_FLOAT) return defaultValue;
-    return py::cast(value.GetFloat());
-}
-
-py::object GetIntegerEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_INTEGER) return defaultValue;
-    return py::cast(value.GetInteger());
-}
-
-
-py::object GetStringEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_STRING) return defaultValue;
-    auto s = value.GetString();
-    return py::str(s.data(), s.size());
-}
-
-py::object GetRawEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_RAW) return defaultValue;
-    return py::cast(value.GetRaw());
-}
-
-py::object GetBooleanArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_BOOLEAN_ARRAY) return defaultValue;
-    // ntcore will return bit vector by default. Convert to List[bool]
-    auto v = value.value();
-    py::list l(v.data.arr_boolean.size);
-    for (size_t i = 0; i < v.data.arr_boolean.size; i++) {
-        auto b = py::bool_(v.data.arr_boolean.arr[i]);
-        PyList_SET_ITEM(l.ptr(), i, b.release().ptr());
-    }
-    return std::move(l);
-}
-
-py::object GetDoubleArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_DOUBLE_ARRAY) return defaultValue;
-    return py::cast(value.GetDoubleArray());
-}
-
-py::object GetFloatArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_FLOAT_ARRAY) return defaultValue;
-    return py::cast(value.GetFloatArray());
-}
-
-py::object GetIntegerArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_INTEGER_ARRAY) return defaultValue;
-    return py::cast(value.GetIntegerArray());
-}
-
-py::object GetStringArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value || value.type() != NT_STRING_ARRAY) return defaultValue;
-    std::span<const std::string> rval = value.GetStringArray();
-    return py::cast(rval);
-}
-
-py::object GetValueEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
-    nt::Value value;
-    {
-        py::gil_scoped_release release;
-        value = nt::GetEntryValue(entry.GetHandle());
-    }
-    if (!value) return defaultValue;
-    return ntvalue2py(value);
-}
-
-
-}; // pyntcore
+
+#include "pyentry.h"
+#include "py2value.h"
+
+#include <pybind11/stl.h>
+#include <wpi_span_type_caster.h>
+
+namespace pyntcore {
+
+py::object GetBooleanEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_BOOLEAN) return defaultValue;
+    return py::cast(value.GetBoolean());
+}
+
+py::object GetDoubleEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_DOUBLE) return defaultValue;
+    return py::cast(value.GetDouble());
+}
+
+py::object GetFloatEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_FLOAT) return defaultValue;
+    return py::cast(value.GetFloat());
+}
+
+py::object GetIntegerEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_INTEGER) return defaultValue;
+    return py::cast(value.GetInteger());
+}
+
+
+py::object GetStringEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_STRING) return defaultValue;
+    auto s = value.GetString();
+    return py::str(s.data(), s.size());
+}
+
+py::object GetRawEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_RAW) return defaultValue;
+    return py::cast(value.GetRaw());
+}
+
+py::object GetBooleanArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_BOOLEAN_ARRAY) return defaultValue;
+    // ntcore will return bit vector by default. Convert to List[bool]
+    auto v = value.value();
+    py::list l(v.data.arr_boolean.size);
+    for (size_t i = 0; i < v.data.arr_boolean.size; i++) {
+        auto b = py::bool_(v.data.arr_boolean.arr[i]);
+        PyList_SET_ITEM(l.ptr(), i, b.release().ptr());
+    }
+    return std::move(l);
+}
+
+py::object GetDoubleArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_DOUBLE_ARRAY) return defaultValue;
+    return py::cast(value.GetDoubleArray());
+}
+
+py::object GetFloatArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_FLOAT_ARRAY) return defaultValue;
+    return py::cast(value.GetFloatArray());
+}
+
+py::object GetIntegerArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_INTEGER_ARRAY) return defaultValue;
+    return py::cast(value.GetIntegerArray());
+}
+
+py::object GetStringArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value || value.type() != NT_STRING_ARRAY) return defaultValue;
+    std::span<const std::string> rval = value.GetStringArray();
+    return py::cast(rval);
+}
+
+py::object GetValueEntry(const nt::NetworkTableEntry &entry, py::object defaultValue) {
+    nt::Value value;
+    {
+        py::gil_scoped_release release;
+        value = nt::GetEntryValue(entry.GetHandle());
+    }
+    if (!value) return defaultValue;
+    return ntvalue2py(value);
+}
+
+
+}; // pyntcore
```

## ntcore/src/pyentry.h

 * *Ordering differences only*

```diff
@@ -1,21 +1,21 @@
-
-#include <robotpy_build.h>
-#include <networktables/NetworkTableEntry.h>
-#include <networktables/NetworkTableValue.h>
-
-namespace pyntcore {
-
-py::object GetBooleanEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetDoubleEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetFloatEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetIntegerEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetStringEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetRawEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetBooleanArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetDoubleArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetFloatArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetIntegerArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetStringArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-py::object GetValueEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
-
-};
+
+#include <robotpy_build.h>
+#include <networktables/NetworkTableEntry.h>
+#include <networktables/NetworkTableValue.h>
+
+namespace pyntcore {
+
+py::object GetBooleanEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetDoubleEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetFloatEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetIntegerEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetStringEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetRawEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetBooleanArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetDoubleArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetFloatArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetIntegerArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetStringArrayEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+py::object GetValueEntry(const nt::NetworkTableEntry &entry, py::object defaultValue);
+
+};
```

## Comparing `ntcore/__pycache__/__init__.cpython-39.pyc` & `ntcore/__pycache__/__init__.cpython-312.pyc`

 * *Format-specific differences are supported for Python .pyc files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: Byte-compiled Python module for CPython 3.9, timestamp-based, .py timestamp: Thu Mar 14 06:00:09 2024 UTC, .py size: 4483 bytes*

 * *Could not decompile bytecode: bad marshal data (unknown type code)*

 * *Files 11% similar despite different names*

```diff
@@ -1,174 +1,189 @@
-00000000: 610d 0d0a 0000 0000 6992 f265 8311 0000  a.......i..e....
-00000010: e300 0000 0000 0000 0000 0000 0000 0000  ................
-00000020: 0008 0000 0040 0000 0073 ca01 0000 6400  .....@...s....d.
-00000030: 6401 6c00 6d01 5a01 0100 6400 6402 6c02  d.l.m.Z...d.d.l.
-00000040: 6d03 5a03 6d04 5a04 6d05 5a05 6d06 5a06  m.Z.m.Z.m.Z.m.Z.
-00000050: 6d07 5a07 6d08 5a08 6d09 5a09 6d0a 5a0a  m.Z.m.Z.m.Z.m.Z.
-00000060: 6d0b 5a0b 6d0c 5a0c 6d0d 5a0d 6d0e 5a0e  m.Z.m.Z.m.Z.m.Z.
-00000070: 6d0f 5a0f 6d10 5a10 6d11 5a11 6d12 5a12  m.Z.m.Z.m.Z.m.Z.
-00000080: 6d13 5a13 6d14 5a14 6d15 5a15 6d16 5a16  m.Z.m.Z.m.Z.m.Z.
-00000090: 6d17 5a17 6d18 5a18 6d19 5a19 6d1a 5a1a  m.Z.m.Z.m.Z.m.Z.
-000000a0: 6d1b 5a1b 6d1c 5a1c 6d1d 5a1d 6d1e 5a1e  m.Z.m.Z.m.Z.m.Z.
-000000b0: 6d1f 5a1f 6d20 5a20 6d21 5a21 6d22 5a22  m.Z.m Z m!Z!m"Z"
-000000c0: 6d23 5a23 6d24 5a24 6d25 5a25 6d26 5a26  m#Z#m$Z$m%Z%m&Z&
-000000d0: 6d27 5a27 6d28 5a28 6d29 5a29 6d2a 5a2a  m'Z'm(Z(m)Z)m*Z*
-000000e0: 6d2b 5a2b 6d2c 5a2c 6d2d 5a2d 6d2e 5a2e  m+Z+m,Z,m-Z-m.Z.
-000000f0: 6d2f 5a2f 6d30 5a30 6d31 5a31 6d32 5a32  m/Z/m0Z0m1Z1m2Z2
-00000100: 6d33 5a33 6d34 5a34 6d35 5a35 6d36 5a36  m3Z3m4Z4m5Z5m6Z6
-00000110: 6d37 5a37 6d38 5a38 6d39 5a39 6d3a 5a3a  m7Z7m8Z8m9Z9m:Z:
-00000120: 6d3b 5a3b 6d3c 5a3c 6d3d 5a3d 6d3e 5a3e  m;Z;m<Z<m=Z=m>Z>
-00000130: 6d3f 5a3f 6d40 5a40 6d41 5a41 6d42 5a42  m?Z?m@Z@mAZAmBZB
-00000140: 6d43 5a43 6d44 5a44 6d45 5a45 6d46 5a46  mCZCmDZDmEZEmFZF
-00000150: 6d47 5a47 6d48 5a48 6d49 5a49 6d4a 5a4a  mGZGmHZHmIZImJZJ
-00000160: 6d4b 5a4b 6d4c 5a4c 6d4d 5a4d 6d4e 5a4e  mKZKmLZLmMZMmNZN
-00000170: 6d4f 5a4f 6d50 5a50 6d51 5a51 6d52 5a52  mOZOmPZPmQZQmRZR
-00000180: 6d53 5a53 6d54 5a54 6d55 5a55 6d56 5a56  mSZSmTZTmUZUmVZV
-00000190: 6d57 5a57 6d58 5a58 6d59 5a59 6d5a 5a5a  mWZWmXZXmYZYmZZZ
-000001a0: 6d5b 5a5b 0100 6700 6402 a201 5a5c 6400  m[Z[..g.d...Z\d.
-000001b0: 6403 6c02 6d5d 5a5d 6d5e 5a5e 0100 655c  d.l.m]Z]m^Z^..e\
-000001c0: 6404 6405 6702 3700 5a5c 7a10 6400 6406  d.d.g.7.Z\z.d.d.
-000001d0: 6c5f 6d5f 5a60 0100 5700 6e18 0400 6561  l_m_Z`..W.n...ea
-000001e0: 9001 79c4 0100 0100 0100 6407 5a60 5900  ..y.......d.Z`Y.
-000001f0: 6e02 3000 6408 5300 2909 e901 0000 0029  n.0.d.S.)......)
-00000200: 01da 0c5f 696e 6974 5f6e 7463 6f72 6529  ..._init_ntcore)
-00000210: 59da 1142 6f6f 6c65 616e 4172 7261 7945  Y..BooleanArrayE
-00000220: 6e74 7279 da15 426f 6f6c 6561 6e41 7272  ntry..BooleanArr
-00000230: 6179 5075 626c 6973 6865 72da 1642 6f6f  ayPublisher..Boo
-00000240: 6c65 616e 4172 7261 7953 7562 7363 7269  leanArraySubscri
-00000250: 6265 72da 1142 6f6f 6c65 616e 4172 7261  ber..BooleanArra
-00000260: 7954 6f70 6963 da0c 426f 6f6c 6561 6e45  yTopic..BooleanE
-00000270: 6e74 7279 da10 426f 6f6c 6561 6e50 7562  ntry..BooleanPub
-00000280: 6c69 7368 6572 da11 426f 6f6c 6561 6e53  lisher..BooleanS
-00000290: 7562 7363 7269 6265 72da 0c42 6f6f 6c65  ubscriber..Boole
-000002a0: 616e 546f 7069 63da 0e43 6f6e 6e65 6374  anTopic..Connect
-000002b0: 696f 6e49 6e66 6fda 1044 6f75 626c 6541  ionInfo..DoubleA
-000002c0: 7272 6179 456e 7472 79da 1444 6f75 626c  rrayEntry..Doubl
-000002d0: 6541 7272 6179 5075 626c 6973 6865 72da  eArrayPublisher.
-000002e0: 1544 6f75 626c 6541 7272 6179 5375 6273  .DoubleArraySubs
-000002f0: 6372 6962 6572 da10 446f 7562 6c65 4172  criber..DoubleAr
-00000300: 7261 7954 6f70 6963 da0b 446f 7562 6c65  rayTopic..Double
-00000310: 456e 7472 79da 0f44 6f75 626c 6550 7562  Entry..DoublePub
-00000320: 6c69 7368 6572 da10 446f 7562 6c65 5375  lisher..DoubleSu
-00000330: 6273 6372 6962 6572 da0b 446f 7562 6c65  bscriber..Double
-00000340: 546f 7069 63da 0545 7665 6e74 da0a 4576  Topic..Event..Ev
-00000350: 656e 7446 6c61 6773 da0f 466c 6f61 7441  entFlags..FloatA
-00000360: 7272 6179 456e 7472 79da 1346 6c6f 6174  rrayEntry..Float
-00000370: 4172 7261 7950 7562 6c69 7368 6572 da14  ArrayPublisher..
-00000380: 466c 6f61 7441 7272 6179 5375 6273 6372  FloatArraySubscr
-00000390: 6962 6572 da0f 466c 6f61 7441 7272 6179  iber..FloatArray
-000003a0: 546f 7069 63da 0a46 6c6f 6174 456e 7472  Topic..FloatEntr
-000003b0: 79da 0e46 6c6f 6174 5075 626c 6973 6865  y..FloatPublishe
-000003c0: 72da 0f46 6c6f 6174 5375 6273 6372 6962  r..FloatSubscrib
-000003d0: 6572 da0a 466c 6f61 7454 6f70 6963 da0c  er..FloatTopic..
-000003e0: 4765 6e65 7269 6345 6e74 7279 da10 4765  GenericEntry..Ge
-000003f0: 6e65 7269 6350 7562 6c69 7368 6572 da11  nericPublisher..
-00000400: 4765 6e65 7269 6353 7562 7363 7269 6265  GenericSubscribe
-00000410: 72da 1149 6e74 6567 6572 4172 7261 7945  r..IntegerArrayE
-00000420: 6e74 7279 da15 496e 7465 6765 7241 7272  ntry..IntegerArr
-00000430: 6179 5075 626c 6973 6865 72da 1649 6e74  ayPublisher..Int
-00000440: 6567 6572 4172 7261 7953 7562 7363 7269  egerArraySubscri
-00000450: 6265 72da 1149 6e74 6567 6572 4172 7261  ber..IntegerArra
-00000460: 7954 6f70 6963 da0c 496e 7465 6765 7245  yTopic..IntegerE
-00000470: 6e74 7279 da10 496e 7465 6765 7250 7562  ntry..IntegerPub
-00000480: 6c69 7368 6572 da11 496e 7465 6765 7253  lisher..IntegerS
-00000490: 7562 7363 7269 6265 72da 0c49 6e74 6567  ubscriber..Integ
-000004a0: 6572 546f 7069 63da 0a4c 6f67 4d65 7373  erTopic..LogMess
-000004b0: 6167 65da 0f4d 756c 7469 5375 6273 6372  age..MultiSubscr
-000004c0: 6962 6572 da0a 4e54 5365 6e64 6162 6c65  iber..NTSendable
-000004d0: da11 4e54 5365 6e64 6162 6c65 4275 696c  ..NTSendableBuil
-000004e0: 6465 72da 0c4e 6574 776f 726b 5461 626c  der..NetworkTabl
-000004f0: 65da 114e 6574 776f 726b 5461 626c 6545  e..NetworkTableE
-00000500: 6e74 7279 da14 4e65 7477 6f72 6b54 6162  ntry..NetworkTab
-00000510: 6c65 496e 7374 616e 6365 da14 4e65 7477  leInstance..Netw
-00000520: 6f72 6b54 6162 6c65 4c69 7374 656e 6572  orkTableListener
-00000530: da1a 4e65 7477 6f72 6b54 6162 6c65 4c69  ..NetworkTableLi
-00000540: 7374 656e 6572 506f 6c6c 6572 da10 4e65  stenerPoller..Ne
-00000550: 7477 6f72 6b54 6162 6c65 5479 7065 da0d  tworkTableType..
-00000560: 5075 6253 7562 4f70 7469 6f6e 73da 0950  PubSubOptions..P
-00000570: 7562 6c69 7368 6572 da08 5261 7745 6e74  ublisher..RawEnt
-00000580: 7279 da0c 5261 7750 7562 6c69 7368 6572  ry..RawPublisher
-00000590: da0d 5261 7753 7562 7363 7269 6265 72da  ..RawSubscriber.
-000005a0: 0852 6177 546f 7069 63da 1053 7472 696e  .RawTopic..Strin
-000005b0: 6741 7272 6179 456e 7472 79da 1453 7472  gArrayEntry..Str
-000005c0: 696e 6741 7272 6179 5075 626c 6973 6865  ingArrayPublishe
-000005d0: 72da 1553 7472 696e 6741 7272 6179 5375  r..StringArraySu
-000005e0: 6273 6372 6962 6572 da10 5374 7269 6e67  bscriber..String
-000005f0: 4172 7261 7954 6f70 6963 da0b 5374 7269  ArrayTopic..Stri
-00000600: 6e67 456e 7472 79da 0f53 7472 696e 6750  ngEntry..StringP
-00000610: 7562 6c69 7368 6572 da10 5374 7269 6e67  ublisher..String
-00000620: 5375 6273 6372 6962 6572 da0b 5374 7269  Subscriber..Stri
-00000630: 6e67 546f 7069 63da 1053 7472 7563 7441  ngTopic..StructA
-00000640: 7272 6179 456e 7472 79da 1453 7472 7563  rrayEntry..Struc
-00000650: 7441 7272 6179 5075 626c 6973 6865 72da  tArrayPublisher.
-00000660: 1553 7472 7563 7441 7272 6179 5375 6273  .StructArraySubs
-00000670: 6372 6962 6572 da10 5374 7275 6374 4172  criber..StructAr
-00000680: 7261 7954 6f70 6963 da0b 5374 7275 6374  rayTopic..Struct
-00000690: 456e 7472 79da 0f53 7472 7563 7450 7562  Entry..StructPub
-000006a0: 6c69 7368 6572 da10 5374 7275 6374 5375  lisher..StructSu
-000006b0: 6273 6372 6962 6572 da0b 5374 7275 6374  bscriber..Struct
-000006c0: 546f 7069 63da 0a53 7562 7363 7269 6265  Topic..Subscribe
-000006d0: 72da 1154 696d 6553 796e 6345 7665 6e74  r..TimeSyncEvent
-000006e0: 4461 7461 da12 5469 6d65 7374 616d 7065  Data..Timestampe
-000006f0: 6442 6f6f 6c65 616e da17 5469 6d65 7374  dBoolean..Timest
-00000700: 616d 7065 6442 6f6f 6c65 616e 4172 7261  ampedBooleanArra
-00000710: 79da 1154 696d 6573 7461 6d70 6564 446f  y..TimestampedDo
-00000720: 7562 6c65 da16 5469 6d65 7374 616d 7065  uble..Timestampe
-00000730: 6444 6f75 626c 6541 7272 6179 da10 5469  dDoubleArray..Ti
-00000740: 6d65 7374 616d 7065 6446 6c6f 6174 da15  mestampedFloat..
-00000750: 5469 6d65 7374 616d 7065 6446 6c6f 6174  TimestampedFloat
-00000760: 4172 7261 79da 1254 696d 6573 7461 6d70  Array..Timestamp
-00000770: 6564 496e 7465 6765 72da 1754 696d 6573  edInteger..Times
-00000780: 7461 6d70 6564 496e 7465 6765 7241 7272  tampedIntegerArr
-00000790: 6179 da0e 5469 6d65 7374 616d 7065 6452  ay..TimestampedR
-000007a0: 6177 da11 5469 6d65 7374 616d 7065 6453  aw..TimestampedS
-000007b0: 7472 696e 67da 1654 696d 6573 7461 6d70  tring..Timestamp
-000007c0: 6564 5374 7269 6e67 4172 7261 79da 1154  edStringArray..T
-000007d0: 696d 6573 7461 6d70 6564 5374 7275 6374  imestampedStruct
-000007e0: da16 5469 6d65 7374 616d 7065 6453 7472  ..TimestampedStr
-000007f0: 7563 7441 7272 6179 da05 546f 7069 63da  uctArray..Topic.
-00000800: 0954 6f70 6963 496e 666f da05 5661 6c75  .TopicInfo..Valu
-00000810: 65da 0e56 616c 7565 4576 656e 7444 6174  e..ValueEventDat
-00000820: 6129 02da 045f 6e6f 77da 075f 7365 744e  a)..._now.._setN
-00000830: 6f77 725c 0000 0072 5d00 0000 2901 da07  owr\...r]...)...
-00000840: 7665 7273 696f 6e5a 066d 6173 7465 724e  versionZ.masterN
-00000850: 2962 da00 7202 0000 005a 075f 6e74 636f  )b..r....Z._ntco
-00000860: 7265 7203 0000 0072 0400 0000 7205 0000  rer....r....r...
-00000870: 0072 0600 0000 7207 0000 0072 0800 0000  .r....r....r....
-00000880: 7209 0000 0072 0a00 0000 720b 0000 0072  r....r....r....r
-00000890: 0c00 0000 720d 0000 0072 0e00 0000 720f  ....r....r....r.
-000008a0: 0000 0072 1000 0000 7211 0000 0072 1200  ...r....r....r..
-000008b0: 0000 7213 0000 0072 1400 0000 7215 0000  ..r....r....r...
-000008c0: 0072 1600 0000 7217 0000 0072 1800 0000  .r....r....r....
-000008d0: 7219 0000 0072 1a00 0000 721b 0000 0072  r....r....r....r
-000008e0: 1c00 0000 721d 0000 0072 1e00 0000 721f  ....r....r....r.
-000008f0: 0000 0072 2000 0000 7221 0000 0072 2200  ...r ...r!...r".
-00000900: 0000 7223 0000 0072 2400 0000 7225 0000  ..r#...r$...r%..
-00000910: 0072 2600 0000 7227 0000 0072 2800 0000  .r&...r'...r(...
-00000920: 7229 0000 0072 2a00 0000 722b 0000 0072  r)...r*...r+...r
-00000930: 2c00 0000 722d 0000 0072 2e00 0000 722f  ,...r-...r....r/
-00000940: 0000 0072 3000 0000 7231 0000 0072 3200  ...r0...r1...r2.
-00000950: 0000 7233 0000 0072 3400 0000 7235 0000  ..r3...r4...r5..
-00000960: 0072 3600 0000 7237 0000 0072 3800 0000  .r6...r7...r8...
-00000970: 7239 0000 0072 3a00 0000 723b 0000 0072  r9...r:...r;...r
-00000980: 3c00 0000 723d 0000 0072 3e00 0000 723f  <...r=...r>...r?
-00000990: 0000 0072 4000 0000 7241 0000 0072 4200  ...r@...rA...rB.
-000009a0: 0000 7243 0000 0072 4400 0000 7245 0000  ..rC...rD...rE..
-000009b0: 0072 4600 0000 7247 0000 0072 4800 0000  .rF...rG...rH...
-000009c0: 7249 0000 0072 4a00 0000 724b 0000 0072  rI...rJ...rK...r
-000009d0: 4c00 0000 724d 0000 0072 4e00 0000 724f  L...rM...rN...rO
-000009e0: 0000 0072 5000 0000 7251 0000 0072 5200  ...rP...rQ...rR.
-000009f0: 0000 7253 0000 0072 5400 0000 7255 0000  ..rS...rT...rU..
-00000a00: 0072 5600 0000 7257 0000 0072 5800 0000  .rV...rW...rX...
-00000a10: 7259 0000 0072 5a00 0000 725b 0000 00da  rY...rZ...r[....
-00000a20: 075f 5f61 6c6c 5f5f 725c 0000 0072 5d00  .__all__r\...r].
-00000a30: 0000 725e 0000 00da 0b5f 5f76 6572 7369  ..r^.....__versi
-00000a40: 6f6e 5f5f da0b 496d 706f 7274 4572 726f  on__..ImportErro
-00000a50: 72a9 0072 6300 0000 7263 0000 00fa 5c44  r..rc...rc....\D
-00000a60: 3a5c 615c 6d6f 7374 726f 626f 7470 795c  :\a\mostrobotpy\
-00000a70: 6d6f 7374 726f 626f 7470 795c 7375 6270  mostrobotpy\subp
-00000a80: 726f 6a65 6374 735c 7079 6e74 636f 7265  rojects\pyntcore
-00000a90: 5c62 7569 6c64 5c6c 6962 2e77 696e 2d61  \build\lib.win-a
-00000aa0: 6d64 3634 2d33 2e39 5c6e 7463 6f72 655c  md64-3.9\ntcore\
-00000ab0: 5f5f 696e 6974 5f5f 2e70 79da 083c 6d6f  __init__.py..<mo
-00000ac0: 6475 6c65 3e01 0000 0073 1200 0000 0c03  dule>....s......
-00000ad0: ff00 6d5c 085c 1002 0c02 0201 1001 0e01  ..m\.\..........
+00000000: cb0d 0d0a 0000 0000 a763 3666 c010 0000  .........c6f....
+00000010: e300 0000 0000 0000 0000 0000 0004 0000  ................
+00000020: 0000 0000 00f3 ca01 0000 9700 6400 6401  ............d.d.
+00000030: 6c00 6d01 5a01 0100 6400 6402 6c02 6d03  l.m.Z...d.d.l.m.
+00000040: 5a03 6d04 5a04 6d05 5a05 6d06 5a06 6d07  Z.m.Z.m.Z.m.Z.m.
+00000050: 5a07 6d08 5a08 6d09 5a09 6d0a 5a0a 6d0b  Z.m.Z.m.Z.m.Z.m.
+00000060: 5a0b 6d0c 5a0c 6d0d 5a0d 6d0e 5a0e 6d0f  Z.m.Z.m.Z.m.Z.m.
+00000070: 5a0f 6d10 5a10 6d11 5a11 6d12 5a12 6d13  Z.m.Z.m.Z.m.Z.m.
+00000080: 5a13 6d14 5a14 6d15 5a15 6d16 5a16 6d17  Z.m.Z.m.Z.m.Z.m.
+00000090: 5a17 6d18 5a18 6d19 5a19 6d1a 5a1a 6d1b  Z.m.Z.m.Z.m.Z.m.
+000000a0: 5a1b 6d1c 5a1c 6d1d 5a1d 6d1e 5a1e 6d1f  Z.m.Z.m.Z.m.Z.m.
+000000b0: 5a1f 6d20 5a20 6d21 5a21 6d22 5a22 6d23  Z.m Z m!Z!m"Z"m#
+000000c0: 5a23 6d24 5a24 6d25 5a25 6d26 5a26 6d27  Z#m$Z$m%Z%m&Z&m'
+000000d0: 5a27 6d28 5a28 6d29 5a29 6d2a 5a2a 6d2b  Z'm(Z(m)Z)m*Z*m+
+000000e0: 5a2b 6d2c 5a2c 6d2d 5a2d 6d2e 5a2e 6d2f  Z+m,Z,m-Z-m.Z.m/
+000000f0: 5a2f 6d30 5a30 6d31 5a31 6d32 5a32 6d33  Z/m0Z0m1Z1m2Z2m3
+00000100: 5a33 6d34 5a34 6d35 5a35 6d36 5a36 6d37  Z3m4Z4m5Z5m6Z6m7
+00000110: 5a37 6d38 5a38 6d39 5a39 6d3a 5a3a 6d3b  Z7m8Z8m9Z9m:Z:m;
+00000120: 5a3b 6d3c 5a3c 6d3d 5a3d 6d3e 5a3e 6d3f  Z;m<Z<m=Z=m>Z>m?
+00000130: 5a3f 6d40 5a40 6d41 5a41 6d42 5a42 6d43  Z?m@Z@mAZAmBZBmC
+00000140: 5a43 6d44 5a44 6d45 5a45 6d46 5a46 6d47  ZCmDZDmEZEmFZFmG
+00000150: 5a47 6d48 5a48 6d49 5a49 6d4a 5a4a 6d4b  ZGmHZHmIZImJZJmK
+00000160: 5a4b 6d4c 5a4c 6d4d 5a4d 6d4e 5a4e 6d4f  ZKmLZLmMZMmNZNmO
+00000170: 5a4f 6d50 5a50 6d51 5a51 6d52 5a52 6d53  ZOmPZPmQZQmRZRmS
+00000180: 5a53 6d54 5a54 6d55 5a55 6d56 5a56 6d57  ZSmTZTmUZUmVZVmW
+00000190: 5a57 6d58 5a58 6d59 5a59 6d5a 5a5a 6d5b  ZWmXZXmYZYmZZZm[
+000001a0: 5a5b 0100 6700 6402 a201 5a5c 6400 6403  Z[..g.d...Z\d.d.
+000001b0: 6c02 6d5d 5a5d 6d5e 5a5e 0100 655c 6404  l.m]Z]m^Z^..e\d.
+000001c0: 6405 6702 7a0d 0000 5a5c 0900 6400 6406  d.g.z...Z\..d.d.
+000001d0: 6c5f 6d5f 5a60 0100 7908 2300 6561 2400  l_m_Z`..y.#.ea$.
+000001e0: 7205 0100 6407 5a60 5900 7908 7700 7803  r...d.Z`Y.y.w.x.
+000001f0: 5900 7701 2909 e901 0000 0029 01da 0c5f  Y.w.)......)..._
+00000200: 696e 6974 5f6e 7463 6f72 6529 59da 1142  init_ntcore)Y..B
+00000210: 6f6f 6c65 616e 4172 7261 7945 6e74 7279  ooleanArrayEntry
+00000220: da15 426f 6f6c 6561 6e41 7272 6179 5075  ..BooleanArrayPu
+00000230: 626c 6973 6865 72da 1642 6f6f 6c65 616e  blisher..Boolean
+00000240: 4172 7261 7953 7562 7363 7269 6265 72da  ArraySubscriber.
+00000250: 1142 6f6f 6c65 616e 4172 7261 7954 6f70  .BooleanArrayTop
+00000260: 6963 da0c 426f 6f6c 6561 6e45 6e74 7279  ic..BooleanEntry
+00000270: da10 426f 6f6c 6561 6e50 7562 6c69 7368  ..BooleanPublish
+00000280: 6572 da11 426f 6f6c 6561 6e53 7562 7363  er..BooleanSubsc
+00000290: 7269 6265 72da 0c42 6f6f 6c65 616e 546f  riber..BooleanTo
+000002a0: 7069 63da 0e43 6f6e 6e65 6374 696f 6e49  pic..ConnectionI
+000002b0: 6e66 6fda 1044 6f75 626c 6541 7272 6179  nfo..DoubleArray
+000002c0: 456e 7472 79da 1444 6f75 626c 6541 7272  Entry..DoubleArr
+000002d0: 6179 5075 626c 6973 6865 72da 1544 6f75  ayPublisher..Dou
+000002e0: 626c 6541 7272 6179 5375 6273 6372 6962  bleArraySubscrib
+000002f0: 6572 da10 446f 7562 6c65 4172 7261 7954  er..DoubleArrayT
+00000300: 6f70 6963 da0b 446f 7562 6c65 456e 7472  opic..DoubleEntr
+00000310: 79da 0f44 6f75 626c 6550 7562 6c69 7368  y..DoublePublish
+00000320: 6572 da10 446f 7562 6c65 5375 6273 6372  er..DoubleSubscr
+00000330: 6962 6572 da0b 446f 7562 6c65 546f 7069  iber..DoubleTopi
+00000340: 63da 0545 7665 6e74 da0a 4576 656e 7446  c..Event..EventF
+00000350: 6c61 6773 da0f 466c 6f61 7441 7272 6179  lags..FloatArray
+00000360: 456e 7472 79da 1346 6c6f 6174 4172 7261  Entry..FloatArra
+00000370: 7950 7562 6c69 7368 6572 da14 466c 6f61  yPublisher..Floa
+00000380: 7441 7272 6179 5375 6273 6372 6962 6572  tArraySubscriber
+00000390: da0f 466c 6f61 7441 7272 6179 546f 7069  ..FloatArrayTopi
+000003a0: 63da 0a46 6c6f 6174 456e 7472 79da 0e46  c..FloatEntry..F
+000003b0: 6c6f 6174 5075 626c 6973 6865 72da 0f46  loatPublisher..F
+000003c0: 6c6f 6174 5375 6273 6372 6962 6572 da0a  loatSubscriber..
+000003d0: 466c 6f61 7454 6f70 6963 da0c 4765 6e65  FloatTopic..Gene
+000003e0: 7269 6345 6e74 7279 da10 4765 6e65 7269  ricEntry..Generi
+000003f0: 6350 7562 6c69 7368 6572 da11 4765 6e65  cPublisher..Gene
+00000400: 7269 6353 7562 7363 7269 6265 72da 1149  ricSubscriber..I
+00000410: 6e74 6567 6572 4172 7261 7945 6e74 7279  ntegerArrayEntry
+00000420: da15 496e 7465 6765 7241 7272 6179 5075  ..IntegerArrayPu
+00000430: 626c 6973 6865 72da 1649 6e74 6567 6572  blisher..Integer
+00000440: 4172 7261 7953 7562 7363 7269 6265 72da  ArraySubscriber.
+00000450: 1149 6e74 6567 6572 4172 7261 7954 6f70  .IntegerArrayTop
+00000460: 6963 da0c 496e 7465 6765 7245 6e74 7279  ic..IntegerEntry
+00000470: da10 496e 7465 6765 7250 7562 6c69 7368  ..IntegerPublish
+00000480: 6572 da11 496e 7465 6765 7253 7562 7363  er..IntegerSubsc
+00000490: 7269 6265 72da 0c49 6e74 6567 6572 546f  riber..IntegerTo
+000004a0: 7069 63da 0a4c 6f67 4d65 7373 6167 65da  pic..LogMessage.
+000004b0: 0f4d 756c 7469 5375 6273 6372 6962 6572  .MultiSubscriber
+000004c0: da0a 4e54 5365 6e64 6162 6c65 da11 4e54  ..NTSendable..NT
+000004d0: 5365 6e64 6162 6c65 4275 696c 6465 72da  SendableBuilder.
+000004e0: 0c4e 6574 776f 726b 5461 626c 65da 114e  .NetworkTable..N
+000004f0: 6574 776f 726b 5461 626c 6545 6e74 7279  etworkTableEntry
+00000500: da14 4e65 7477 6f72 6b54 6162 6c65 496e  ..NetworkTableIn
+00000510: 7374 616e 6365 da14 4e65 7477 6f72 6b54  stance..NetworkT
+00000520: 6162 6c65 4c69 7374 656e 6572 da1a 4e65  ableListener..Ne
+00000530: 7477 6f72 6b54 6162 6c65 4c69 7374 656e  tworkTableListen
+00000540: 6572 506f 6c6c 6572 da10 4e65 7477 6f72  erPoller..Networ
+00000550: 6b54 6162 6c65 5479 7065 da0d 5075 6253  kTableType..PubS
+00000560: 7562 4f70 7469 6f6e 73da 0950 7562 6c69  ubOptions..Publi
+00000570: 7368 6572 da08 5261 7745 6e74 7279 da0c  sher..RawEntry..
+00000580: 5261 7750 7562 6c69 7368 6572 da0d 5261  RawPublisher..Ra
+00000590: 7753 7562 7363 7269 6265 72da 0852 6177  wSubscriber..Raw
+000005a0: 546f 7069 63da 1053 7472 696e 6741 7272  Topic..StringArr
+000005b0: 6179 456e 7472 79da 1453 7472 696e 6741  ayEntry..StringA
+000005c0: 7272 6179 5075 626c 6973 6865 72da 1553  rrayPublisher..S
+000005d0: 7472 696e 6741 7272 6179 5375 6273 6372  tringArraySubscr
+000005e0: 6962 6572 da10 5374 7269 6e67 4172 7261  iber..StringArra
+000005f0: 7954 6f70 6963 da0b 5374 7269 6e67 456e  yTopic..StringEn
+00000600: 7472 79da 0f53 7472 696e 6750 7562 6c69  try..StringPubli
+00000610: 7368 6572 da10 5374 7269 6e67 5375 6273  sher..StringSubs
+00000620: 6372 6962 6572 da0b 5374 7269 6e67 546f  criber..StringTo
+00000630: 7069 63da 1053 7472 7563 7441 7272 6179  pic..StructArray
+00000640: 456e 7472 79da 1453 7472 7563 7441 7272  Entry..StructArr
+00000650: 6179 5075 626c 6973 6865 72da 1553 7472  ayPublisher..Str
+00000660: 7563 7441 7272 6179 5375 6273 6372 6962  uctArraySubscrib
+00000670: 6572 da10 5374 7275 6374 4172 7261 7954  er..StructArrayT
+00000680: 6f70 6963 da0b 5374 7275 6374 456e 7472  opic..StructEntr
+00000690: 79da 0f53 7472 7563 7450 7562 6c69 7368  y..StructPublish
+000006a0: 6572 da10 5374 7275 6374 5375 6273 6372  er..StructSubscr
+000006b0: 6962 6572 da0b 5374 7275 6374 546f 7069  iber..StructTopi
+000006c0: 63da 0a53 7562 7363 7269 6265 72da 1154  c..Subscriber..T
+000006d0: 696d 6553 796e 6345 7665 6e74 4461 7461  imeSyncEventData
+000006e0: da12 5469 6d65 7374 616d 7065 6442 6f6f  ..TimestampedBoo
+000006f0: 6c65 616e da17 5469 6d65 7374 616d 7065  lean..Timestampe
+00000700: 6442 6f6f 6c65 616e 4172 7261 79da 1154  dBooleanArray..T
+00000710: 696d 6573 7461 6d70 6564 446f 7562 6c65  imestampedDouble
+00000720: da16 5469 6d65 7374 616d 7065 6444 6f75  ..TimestampedDou
+00000730: 626c 6541 7272 6179 da10 5469 6d65 7374  bleArray..Timest
+00000740: 616d 7065 6446 6c6f 6174 da15 5469 6d65  ampedFloat..Time
+00000750: 7374 616d 7065 6446 6c6f 6174 4172 7261  stampedFloatArra
+00000760: 79da 1254 696d 6573 7461 6d70 6564 496e  y..TimestampedIn
+00000770: 7465 6765 72da 1754 696d 6573 7461 6d70  teger..Timestamp
+00000780: 6564 496e 7465 6765 7241 7272 6179 da0e  edIntegerArray..
+00000790: 5469 6d65 7374 616d 7065 6452 6177 da11  TimestampedRaw..
+000007a0: 5469 6d65 7374 616d 7065 6453 7472 696e  TimestampedStrin
+000007b0: 67da 1654 696d 6573 7461 6d70 6564 5374  g..TimestampedSt
+000007c0: 7269 6e67 4172 7261 79da 1154 696d 6573  ringArray..Times
+000007d0: 7461 6d70 6564 5374 7275 6374 da16 5469  tampedStruct..Ti
+000007e0: 6d65 7374 616d 7065 6453 7472 7563 7441  mestampedStructA
+000007f0: 7272 6179 da05 546f 7069 63da 0954 6f70  rray..Topic..Top
+00000800: 6963 496e 666f da05 5661 6c75 65da 0e56  icInfo..Value..V
+00000810: 616c 7565 4576 656e 7444 6174 6129 02da  alueEventData)..
+00000820: 045f 6e6f 77da 075f 7365 744e 6f77 725d  ._now.._setNowr]
+00000830: 0000 0072 5e00 0000 2901 da07 7665 7273  ...r^...)...vers
+00000840: 696f 6eda 066d 6173 7465 724e 2962 da00  ion..masterN)b..
+00000850: 7203 0000 00da 075f 6e74 636f 7265 7204  r......_ntcorer.
+00000860: 0000 0072 0500 0000 7206 0000 0072 0700  ...r....r....r..
+00000870: 0000 7208 0000 0072 0900 0000 720a 0000  ..r....r....r...
+00000880: 0072 0b00 0000 720c 0000 0072 0d00 0000  .r....r....r....
+00000890: 720e 0000 0072 0f00 0000 7210 0000 0072  r....r....r....r
+000008a0: 1100 0000 7212 0000 0072 1300 0000 7214  ....r....r....r.
+000008b0: 0000 0072 1500 0000 7216 0000 0072 1700  ...r....r....r..
+000008c0: 0000 7218 0000 0072 1900 0000 721a 0000  ..r....r....r...
+000008d0: 0072 1b00 0000 721c 0000 0072 1d00 0000  .r....r....r....
+000008e0: 721e 0000 0072 1f00 0000 7220 0000 0072  r....r....r ...r
+000008f0: 2100 0000 7222 0000 0072 2300 0000 7224  !...r"...r#...r$
+00000900: 0000 0072 2500 0000 7226 0000 0072 2700  ...r%...r&...r'.
+00000910: 0000 7228 0000 0072 2900 0000 722a 0000  ..r(...r)...r*..
+00000920: 0072 2b00 0000 722c 0000 0072 2d00 0000  .r+...r,...r-...
+00000930: 722e 0000 0072 2f00 0000 7230 0000 0072  r....r/...r0...r
+00000940: 3100 0000 7232 0000 0072 3300 0000 7234  1...r2...r3...r4
+00000950: 0000 0072 3500 0000 7236 0000 0072 3700  ...r5...r6...r7.
+00000960: 0000 7238 0000 0072 3900 0000 723a 0000  ..r8...r9...r:..
+00000970: 0072 3b00 0000 723c 0000 0072 3d00 0000  .r;...r<...r=...
+00000980: 723e 0000 0072 3f00 0000 7240 0000 0072  r>...r?...r@...r
+00000990: 4100 0000 7242 0000 0072 4300 0000 7244  A...rB...rC...rD
+000009a0: 0000 0072 4500 0000 7246 0000 0072 4700  ...rE...rF...rG.
+000009b0: 0000 7248 0000 0072 4900 0000 724a 0000  ..rH...rI...rJ..
+000009c0: 0072 4b00 0000 724c 0000 0072 4d00 0000  .rK...rL...rM...
+000009d0: 724e 0000 0072 4f00 0000 7250 0000 0072  rN...rO...rP...r
+000009e0: 5100 0000 7252 0000 0072 5300 0000 7254  Q...rR...rS...rT
+000009f0: 0000 0072 5500 0000 7256 0000 0072 5700  ...rU...rV...rW.
+00000a00: 0000 7258 0000 0072 5900 0000 725a 0000  ..rX...rY...rZ..
+00000a10: 0072 5b00 0000 725c 0000 00da 075f 5f61  .r[...r\.....__a
+00000a20: 6c6c 5f5f 725d 0000 0072 5e00 0000 725f  ll__r]...r^...r_
+00000a30: 0000 00da 0b5f 5f76 6572 7369 6f6e 5f5f  .....__version__
+00000a40: da0b 496d 706f 7274 4572 726f 72a9 00f3  ..ImportError...
+00000a50: 0000 0000 fa7f 2f55 7365 7273 2f72 756e  ....../Users/run
+00000a60: 6e65 722f 776f 726b 2f6d 6f73 7472 6f62  ner/work/mostrob
+00000a70: 6f74 7079 2f6d 6f73 7472 6f62 6f74 7079  otpy/mostrobotpy
+00000a80: 2f73 7562 7072 6f6a 6563 7473 2f70 796e  /subprojects/pyn
+00000a90: 7463 6f72 652f 6275 696c 642f 6c69 622e  tcore/build/lib.
+00000aa0: 6d61 636f 7378 2d31 302e 392d 756e 6976  macosx-10.9-univ
+00000ab0: 6572 7361 6c32 2d63 7079 7468 6f6e 2d33  ersal2-cpython-3
+00000ac0: 3132 2f6e 7463 6f72 652f 5f5f 696e 6974  12/ntcore/__init
+00000ad0: 5f5f 2e70 79fa 083c 6d6f 6475 6c65 3e72  __.py..<module>r
+00000ae0: 6900 0000 0100 0000 73cc 0000 00f0 0301  i.......s.......
+00000af0: 0101 dd00 1af7 065a 0101 02f7 005a 0101  .......Z.....Z..
+00000b00: 02f7 005a 0101 02f7 005a 0101 02f7 005a  ...Z.....Z.....Z
+00000b10: 0101 02f7 005a 0101 02f7 005a 0101 02f7  .....Z.....Z....
+00000b20: 005a 0101 02f7 005a 0101 02f7 005a 0101  .Z.....Z.....Z..
+00000b30: 02f7 005a 0101 02f7 005a 0101 02f7 005a  ...Z.....Z.....Z
+00000b40: 0101 02f7 005a 0101 02f7 005a 0101 02f7  .....Z.....Z....
+00000b50: 005a 0101 02f7 005a 0101 02f7 005a 0101  .Z.....Z.....Z..
+00000b60: 02f7 005a 0101 02f7 005a 0101 02f7 005a  ...Z.....Z.....Z
+00000b70: 0101 02f7 005a 0101 02f5 005a 0101 02f2  .....Z.....Z....
+00000b80: 7802 5a01 0b02 8007 f778 0200 0123 e000  x.Z......x...#..
+00000b90: 0788 4690 49d0 0b1e d100 1e80 07f0 0403  ..F.I...........
+00000ba0: 011b de04 2ff8 d807 12f2 0001 011b d812  ..../...........
+00000bb0: 1a82 4bf0 0301 011b fa73 1200 0000 c311  ..K......s......
+00000bc0: 0643 1800 c318 0743 2203 c321 0143 2203  .C.....C"..!.C".
```

## Comparing `pyntcore-2024.3.2.0.dist-info/RECORD` & `pyntcore-2024.3.2.1.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-ntcore/__init__.py,sha256=_p8UuHOLoWYrPRZh0JxS72KKpTdHvhPRw__xHoHfVDo,4483
-ntcore/_init_ntcore.py,sha256=zkPw3P8ni6O8FivHv0h9x9YsAc_aqv7F-8AykRzRz4c,650
-ntcore/_logutil.py,sha256=IbcTVUOhoBNNUnm0Ib4rNvAKcFf7-J-EhFb0UzLd0LM,3642
-ntcore/_ntcore.cp39-win_amd64.pyd,sha256=czXxVGdrncmtwOZIphUsf4dt0VKKChZQ0UZyINpM7rw,2503168
-ntcore/pkgcfg.py,sha256=2zzUVyCbiJ2Nl4pPaFImMEDanRl08fa69iA7kZL90iA,561
+ntcore/__init__.py,sha256=SSV2kHK3Mk0SgKuNyFJGOY4FrwOs4mI3n2CJQOh1qXA,4288
+ntcore/_init_ntcore.py,sha256=63lPPSFs7gTrEWTXeYNcc9AxvQFqd7d8673iTYUR0RE,648
+ntcore/_logutil.py,sha256=PC6RV-AysrTexSVji8eb6YkhxYURSJEeuULtqVraUbI,3519
+ntcore/_ntcore.cpython-312-darwin.so,sha256=fGYAbTm_vExJnE8jaQaCy8gAUWqGnmDyw2IZKBeNSco,12191088
+ntcore/pkgcfg.py,sha256=K0KfNpZdMoseaoPMB19l63Mt-SXk258ZImaJqESqilM,543
 ntcore/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-ntcore/types.py,sha256=Ad2Ecp4EZ67EcIbIG8kOh-5MUo41sMWEC8lVmS1TkHg,196
-ntcore/util.py,sha256=_mFPxV81IH8izAZS4bdBq4Gx768ZH-KhoSqAT6PUTJE,7225
-ntcore/version.py,sha256=LnIr6j8Yrhhj1pNhqwRaZ7BkAJEnUr_L6fh-Kx0gVQk,175
-ntcore/__pycache__/__init__.cpython-39.pyc,sha256=5yB2bJZWZdTet9gIYwZhnWlKno2HvNOV4I4dHFNIZp4,2784
-ntcore/__pycache__/_init_ntcore.cpython-39.pyc,sha256=Z9T8XLtyrt2o076bxdwHhhaTcWCuTzYrMvyx4auErcY,749
-ntcore/__pycache__/version.cpython-39.pyc,sha256=sKQIqmitkITU_j2tRlxrF2qkZDjOscdSLTFr91ONyzk,287
-ntcore/_ntcore/__init__.pyi,sha256=jZFXv71A8n5RzDIr2g2zjPt6p3gptTUjIn3r5_9E-BM,274119
-ntcore/_ntcore/meta.pyi,sha256=eUleUBB6spL0IzxHLAbCUK6xYNL6TxHlFd9s30ELK1k,2987
+ntcore/types.py,sha256=1cN1AQ7mY5it4Al2JV0ij3Yr1DZ1TdwXvAVEF4rIF0M,183
+ntcore/util.py,sha256=2xHIYmJdIaoZBu727MPxozoz5NSK4ROqe7Nk1-Oer7A,7001
+ntcore/version.py,sha256=4KEd5pR0O-ld11WTy4JzbCijFRBGzONlAE_gu45WRRE,171
+ntcore/__pycache__/__init__.cpython-312.pyc,sha256=qTN1MPXw95at04KcHEyMLJzCnp0FunuYzQ88XGwb0uo,3024
+ntcore/__pycache__/_init_ntcore.cpython-312.pyc,sha256=_Ve5v2oiWUzwn5whNURmvXdEqOzWY0OD0Vu7Y2_p8fc,952
+ntcore/__pycache__/version.cpython-312.pyc,sha256=bF-pk8b3K5RuvTAP4gJTA4boTzFxdN6meU98-PlvFMg,349
+ntcore/_ntcore/__init__.pyi,sha256=y2Vps6TVvWLufk0spNxXlWmqFjN2PYwSEOf0wLJteBI,267107
+ntcore/_ntcore/meta.pyi,sha256=nXJ9L5Cq-hbG_0ihdpRHdxHhG10UglL0yar2gfDRDiU,2889
 ntcore/include/ntcore.h,sha256=HZd_v6HNAUE00NZ29whyunhfb6vSnNU-9XZe8---Hr4,331
 ntcore/include/ntcore_c.h,sha256=BpbXqFSCZxU-LFJrT0t0UPZYjZK1uy_JKQh3B-hGA-0,62006
 ntcore/include/ntcore_c_types.h,sha256=fGpOFEw3WE0mohWpNKm1NmZZENB0OqCL1L45AHV1gOE,33883
 ntcore/include/ntcore_cpp.h,sha256=aZtsF-mll_wBZJ98q9gTO2V2G5evazgxZFsV6DhUIvI,44061
 ntcore/include/ntcore_cpp_types.h,sha256=4JRfD8Fwv2gk07H0xV0zLdxk55CpURiI90WjyTGnCpo,30054
 ntcore/include/ntcore_test.h,sha256=EGVE0V6tL1mveNGplWQYyUXiQu6mQyLe0l2F6t1-zcg,2715
 ntcore/include/networktables/BooleanArrayTopic.h,sha256=EyMFAMcGLL_GGuqh67Us9uqnVFvf7DT18QGKhlJGwBs,13119
@@ -58,83 +58,82 @@
 ntcore/include/networktables/StringTopic.inc,sha256=qzzdZHiocIxK-kJ8jlOqNcdqC9Ic130_x2RD3pvghGU,4217
 ntcore/include/networktables/StructArrayTopic.h,sha256=p4eQBc5lv92edBbEqNXscoqHGbg41rRvnYy3A6-4YFs,22701
 ntcore/include/networktables/StructTopic.h,sha256=IvfC43nP2-5WNXQwEGlKWH_dQpEGJ0oxNcQKuHeU6ds,16217
 ntcore/include/networktables/Topic.h,sha256=Z3PWyudg5H4huQO9NhT7ViQYG82HKCt9460yhrLI42I,11263
 ntcore/include/networktables/Topic.inc,sha256=QfbWudWLffTG7hwmBYzpJazzeL787-LVQp_TIDAGe2o,2769
 ntcore/include/networktables/UnitTopic.h,sha256=w7XPlBRfi1WM_sEyXQDT9tRnWBgt1uSulEyq2nPvv_k,12126
 ntcore/include/networktables/UnitTopic.inc,sha256=CQttIE8aPM3_sPnQCkFm1C9vho_asU6NlhO3I8tyy60,4541
-ntcore/lib/ntcore.dll,sha256=DjbR-2ySUe0xJH4bPTtPFat8E8hSuEYjxTOurDezoQM,1582592
-ntcore/lib/ntcore.lib,sha256=pg0ovPrvZvS3CrCK4jqUzMB7nLAGRdo_NOxsTmK18uk,3246352
-ntcore/meta/__init__.py,sha256=sj150T5uocg25nKlRZsoO_hVpgcgIvWdAG3ReixeYKE,678
-ntcore/rpy-include/rpygen/StructArrayTopic_tmpl1.cpp,sha256=VixC6qiqUrTX7Ij27ZclOPHXPaF2AbHBtxLZsOJPqWQ,1095
-ntcore/rpy-include/rpygen/StructArrayTopic_tmpl2.cpp,sha256=gvwO2ZEpn8_XrIDvyacKyGYzjewLriGRLIxZ7OB_Hw8,1090
-ntcore/rpy-include/rpygen/StructArrayTopic_tmpl3.cpp,sha256=6mqaa1cFrxHdzqWRQqM24dMUL0SNWMf8IcoRwccUvrc,1070
-ntcore/rpy-include/rpygen/StructArrayTopic_tmpl4.cpp,sha256=FjqlWZWbLhzLf5HS62BG8xiXBuphcFYHOy1_Tbs3eCc,1070
-ntcore/rpy-include/rpygen/StructTopic_tmpl1.cpp,sha256=DEvReUPPmXP0lmNY7WNwCkDfDxWT_Njtwj3FgSxkx7c,1003
-ntcore/rpy-include/rpygen/StructTopic_tmpl2.cpp,sha256=gurRVDw6XzVkzS4sRttNIsd9QnR7-rmepgb08Nvears,998
-ntcore/rpy-include/rpygen/StructTopic_tmpl3.cpp,sha256=QOZ3mK-c4Mu-6pZLCSaGgU0j3wiBJiXXWK-LchAujwk,978
-ntcore/rpy-include/rpygen/StructTopic_tmpl4.cpp,sha256=hf37-Egb_oByV3uttcRi5cHSOJg-GaCiZsmsYJJHsSU,978
-ntcore/rpy-include/rpygen/nt__BooleanArrayPublisher.hpp,sha256=NPIPbb8oMbuqQ47Sy48an1flYc7Nw_ra0NAFwy80pvA,1721
-ntcore/rpy-include/rpygen/nt__BooleanArraySubscriber.hpp,sha256=8OPqz6tdCmPzFfB-XUV8-_XCJX3dTRM24QusYuYxGUk,1857
-ntcore/rpy-include/rpygen/nt__BooleanPublisher.hpp,sha256=HuMRc4Zi556XURqws-YAbWzURNlzodyz7Cp_CzD7Um0,1469
-ntcore/rpy-include/rpygen/nt__BooleanSubscriber.hpp,sha256=Gu6knvpvhBlF0eSJyZ7E2lg-sS94r10He01AiALq4ks,1483
-ntcore/rpy-include/rpygen/nt__DoubleArrayPublisher.hpp,sha256=KPSYauAdMNxmtJWD9Trk0IGPHiqbm53THeyWoFCdUSw,1707
-ntcore/rpy-include/rpygen/nt__DoubleArraySubscriber.hpp,sha256=z5xHShQ-T3iHDEy92DMXkQ2NuuWlZo7o1DJyTOwRFnk,1842
-ntcore/rpy-include/rpygen/nt__DoublePublisher.hpp,sha256=joBOhOiekwCvbl6Tm4vhfz4-k1CwmzPRrB0DVWzD-2s,1457
-ntcore/rpy-include/rpygen/nt__DoubleSubscriber.hpp,sha256=HMAaTfCkfiY72_sxGiEvPik43pfIr6JL4YjEkfiVHsE,1471
-ntcore/rpy-include/rpygen/nt__FloatArrayPublisher.hpp,sha256=wuvuUwhlxti9oLazBf9fqAuG2fCg2ea0__Qscmjliz4,1693
-ntcore/rpy-include/rpygen/nt__FloatArraySubscriber.hpp,sha256=ncxe5_YjjAwebjnJYIBIPhuRHOEPNzn0SaeMayAM6J4,1827
-ntcore/rpy-include/rpygen/nt__FloatPublisher.hpp,sha256=pFH0vFYfrKs2-GUfW7ImqzlasvtB_vitvU6j9nmlEoA,1445
-ntcore/rpy-include/rpygen/nt__FloatSubscriber.hpp,sha256=k2Cn5-etV1ij_fERYEs6t8Nmh8Dz9SaGDjkeoNWfm9Q,1459
-ntcore/rpy-include/rpygen/nt__GenericPublisher.hpp,sha256=cX3H4GpLIdNWCB9CwYBrBokmmBnLl3mliK7KjayJW14,1504
-ntcore/rpy-include/rpygen/nt__GenericSubscriber.hpp,sha256=qH47AdINYSedr--zoxhfA514CgcvnWMNyDCZY00zUXI,1518
-ntcore/rpy-include/rpygen/nt__IntegerArrayPublisher.hpp,sha256=d5Ze8HOb1M6cREOYl-9yUycyEAEpUnKc0CfHvXv63uU,1721
-ntcore/rpy-include/rpygen/nt__IntegerArraySubscriber.hpp,sha256=iUftlcvUDFg7Cz7nYOa_vXfLWV1lHedaq_cqhfeFvJY,1857
-ntcore/rpy-include/rpygen/nt__IntegerPublisher.hpp,sha256=RfgcXDh8g3caAZZICzq4BjuP0yF2bzuFzZ50lPr6o9A,1469
-ntcore/rpy-include/rpygen/nt__IntegerSubscriber.hpp,sha256=gdxeVoNAPy6hBnafBojzxWnoqeqnWs-9BtelWTF29Rc,1483
-ntcore/rpy-include/rpygen/nt__NTSendable.hpp,sha256=pFJ9ovI9luR2Yaiy5ySg495F6yTR-qONsJR27iQI6LE,2567
-ntcore/rpy-include/rpygen/nt__NTSendableBuilder.hpp,sha256=p5zPBeVYk8XcqxH_N5KJh7uFalWVXjaSr_6scc49ZAs,3140
-ntcore/rpy-include/rpygen/nt__Publisher.hpp,sha256=jCxDjwCdQruXZlrgqVl9Z4deToNd40koea4OXOYf844,820
-ntcore/rpy-include/rpygen/nt__RawPublisher.hpp,sha256=R0l8bmlCNPBhkftkvOoHBBJSj4ywvdBa5yLZsuyns8A,1630
-ntcore/rpy-include/rpygen/nt__RawSubscriber.hpp,sha256=3pdnWFASzclariQZCka58G9kW4jIKObbvd1iTFIJXeE,1757
-ntcore/rpy-include/rpygen/nt__StringArrayPublisher.hpp,sha256=z88RR4JvKwdirCY7_NNhgSucZloHRrZIwKpt2A9FTDY,1517
-ntcore/rpy-include/rpygen/nt__StringArraySubscriber.hpp,sha256=akS3n6s75SjQQqHDGL7pa5S00b7yE8unBEEdW6M_B3w,1531
-ntcore/rpy-include/rpygen/nt__StringPublisher.hpp,sha256=La5efigQNgufyBZAOGJMtxqQUkP_jgiMqbgMCvF96eU,1637
-ntcore/rpy-include/rpygen/nt__StringSubscriber.hpp,sha256=nBg3fcEF8zrN07EqujnVfdRfPBZRnfTyhh8CX187E9o,1767
-ntcore/rpy-include/rpygen/nt__StructArrayEntry.hpp,sha256=i_IwSnXH-IQAelYSGeND2VM3FwSGA6_I9O58iLAghW8,2771
-ntcore/rpy-include/rpygen/nt__StructArrayPublisher.hpp,sha256=iZb9srJLPYTfcGmPw1THo8ojsYajMJ3985axh1spGbA,4974
-ntcore/rpy-include/rpygen/nt__StructArraySubscriber.hpp,sha256=wdaWSru3PkEjJxKIwgJWvKJZvvBwC2kqDp5QNfXhfYc,6647
-ntcore/rpy-include/rpygen/nt__StructArrayTopic.hpp,sha256=jK8gfmcR6H7aO9rRQ8j1_bm7FgWbBxUZUuXt5H3nBw4,6081
-ntcore/rpy-include/rpygen/nt__StructEntry.hpp,sha256=fu1qTmjB7S9_jTnN_WANt-aiS8JOQD5jcxEnxva_aAQ,2593
-ntcore/rpy-include/rpygen/nt__StructPublisher.hpp,sha256=ShdVoR_eI4XvdB0E5eApw4tM1pfw-F5XFSSiAkKQyXE,4544
-ntcore/rpy-include/rpygen/nt__StructSubscriber.hpp,sha256=4u8IJiHYQwc_1EffHaHb3F0WFSQ8Zx0XeKLVbh4Q4SY,6339
-ntcore/rpy-include/rpygen/nt__StructTopic.hpp,sha256=4NVsenhwtEkpcJ2_r4Z_iQzcM-15FHJqtd2Bo9VxWN4,5684
-ntcore/rpy-include/rpygen/nt__Subscriber.hpp,sha256=b7KlqJ24i1Zw3hbWfA9ZgPMFFnqN3uu2jFg_m9vNia8,824
-ntcore/rpy-include/rpygen/nt__Timestamped.hpp,sha256=Tl2FcXUafYzBkvSB2-QZ5_OYVNfVyHV4ZyOlHOPEUX0,2008
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl1.cpp,sha256=j5VvYWJOecqSM1f9CMCs2kZt3mfKSw32xWhI_Yrd77M,730
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl10.cpp,sha256=dHt0P7e4w6FpfGMQz63DH47bw4pbPHFbke_ROTpItcI,745
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl11.cpp,sha256=U-hGR4B6duNGHkSkMS8a21ZmCssnUWkUY8sPaa1308I,753
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl12.cpp,sha256=bAHwI5syokIcCG7psywbwLl8pHHAiDMMMXGkOXyaW70,738
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl13.cpp,sha256=AMgtF8slX5hgK2thCwVGrk63TZ3H2ioOh827lLzm1og,751
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl2.cpp,sha256=sWBkAcfbTIVRaEZ8TkRESgAnb1G-F9FRNGpX2KF2EsI,733
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl3.cpp,sha256=XP_bTix-8yLHpNmDhlczFA-jDtGWBwYUp-XThJC-41o,731
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl4.cpp,sha256=oku2jq8odyhW_BvlWp5Ng3A5tq6wN_aj0OVuDWGRQOE,732
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl5.cpp,sha256=fWPOO-5wyBs85M5XdsNGAkHJGiytdIN9YV5brVK3mvQ,737
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl6.cpp,sha256=ri-uXXcUWptDQCg9R_ivwP1cbj3l8cuLsO7cGu2tYfU,746
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl7.cpp,sha256=xSWe9L9Hyvr3J8ddo3dtPV-o6sWaPRba5GSnlybvm7c,742
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl8.cpp,sha256=a6d0LwMX-s_eNyZ76I0KyxbPqJIO1Cu1O6zb_yoBqI0,746
-ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl9.cpp,sha256=NJ6VN07q3FWproMk1dSlFMCYtZoV7wX38hpn__yeBaE,744
-ntcore/src/NetworkTable.cpp.inl,sha256=JxJoVb1PnQxlAY8zGoioFNvGdTL9pXZMmq0LNhSfXw8,3132
-ntcore/src/NetworkTableEntry.cpp.inl,sha256=vbe-jf0K4CJzi5-hWSfLurM9dlKK1xGQjKoSdV3xCl8,2341
-ntcore/src/nt_instance.cpp,sha256=s1R8co7aUaOxEZh8Xj0k1Dz1vbSAfmXCK4xC--iA9Tk,1627
-ntcore/src/nt_instance.h,sha256=ukwC3hr7tBElc5TpZbBgAQAvSLHvc3ljrLeIpPgZRes,416
-ntcore/src/nt_type_caster.h,sha256=9n89KuqCOyaGkLiUeKlOfIPQU4FPsPbPciAH9siIZD8,1043
-ntcore/src/ntcore.cpp,sha256=U5Duz9851RgjIbj02Kj9ns-9UlnEwhvKDGIM4VnrYP8,267
-ntcore/src/py2value.cpp,sha256=_-Xtq0wmtbnjylIRY8jxiPV-3liOy_EgKouDIXV2y90,5160
-ntcore/src/py2value.h,sha256=F0CTplMTIYTfHrUKMJqimSGzhNKV3PZ0fTANJHaglFU,621
-ntcore/src/pyentry.cpp,sha256=Gwb0duZ4k9G9tY6wlvgKvyiYaOeOAXO5ZAo_ddvpjJI,4596
-ntcore/src/pyentry.h,sha256=kf0Fh_dKNpF3RE4IjrMhdzvdGv4n3z3mVn48_eGy2pc,1245
-pyntcore-2024.3.2.0.dist-info/METADATA,sha256=th8lNKY2P3B9dhn9RphHx0qWSGs3fQ3jRIIHyjOYlzU,514
-pyntcore-2024.3.2.0.dist-info/WHEEL,sha256=Z6c-bE0pUM47a70GvqO_SvH_XXU0lm62gEAKtoNJ08A,100
-pyntcore-2024.3.2.0.dist-info/entry_points.txt,sha256=F10Ce_Ywvji9ctDMjIqI1hCL01kIrmeK-M2VmsQdlnc,39
-pyntcore-2024.3.2.0.dist-info/top_level.txt,sha256=AAaE3j5A7CbLJ5iZKrJnK-vUXFxkjBDNiFljbUDu4m0,7
-pyntcore-2024.3.2.0.dist-info/RECORD,,
+ntcore/lib/libntcore.dylib,sha256=mqV4awc86AIWoAPMhtBRf7L2--sLYs6BLUjofjDOQqU,5649024
+ntcore/meta/__init__.py,sha256=Nw4USPH-d2SzKroBuZMvFJ55Uo_K2LyKx5JGFsdKonw,650
+ntcore/rpy-include/rpygen/StructArrayTopic_tmpl1.cpp,sha256=rXTDWEgZnpG0xL3r4jV5maHFlPN3DTeyhLuERyYO7j0,1045
+ntcore/rpy-include/rpygen/StructArrayTopic_tmpl2.cpp,sha256=TqWYXg5oR7B7ZeC3kaxzHiRa6GIs_yk6xrRC3AAfN0o,1040
+ntcore/rpy-include/rpygen/StructArrayTopic_tmpl3.cpp,sha256=73iqrh1lSwGAJiFzTU6qM8R3CEfxDq_z1uDgMN4l0c4,1020
+ntcore/rpy-include/rpygen/StructArrayTopic_tmpl4.cpp,sha256=XouhSsauZJyVOGMWQoSFbITnTVbKBPJ4YLg0xHjvW4g,1020
+ntcore/rpy-include/rpygen/StructTopic_tmpl1.cpp,sha256=FVMxAfB9bDmyy7pq5R_3QJRkdVQUAHhrr4ikXdud77Y,955
+ntcore/rpy-include/rpygen/StructTopic_tmpl2.cpp,sha256=ghEdqf0r6jTnbu29fRvH1LKo7tNxmSjiDE396iAPDq4,950
+ntcore/rpy-include/rpygen/StructTopic_tmpl3.cpp,sha256=TPgpG4VnzWkdbWs2XieGQBA1fGQFP9TxDWwY7BV_DwE,930
+ntcore/rpy-include/rpygen/StructTopic_tmpl4.cpp,sha256=TCnem3tAtK-Bx-RQChGM7cWRpI5-v2SpeBAbKMIpXVg,930
+ntcore/rpy-include/rpygen/nt__BooleanArrayPublisher.hpp,sha256=m4WK77WAhL0JwGovr_znqb-J8-ElFqyvhBSU0vw_3B8,1616
+ntcore/rpy-include/rpygen/nt__BooleanArraySubscriber.hpp,sha256=9r04iirqxsO9cqWBZhdC68_fjAat4HbTUUwhN5Kxbvo,1750
+ntcore/rpy-include/rpygen/nt__BooleanPublisher.hpp,sha256=6Q2oZNjJiQL1PiYV_LRIuy9NVfJn7Ud9cRQG3kCU4GA,1368
+ntcore/rpy-include/rpygen/nt__BooleanSubscriber.hpp,sha256=iiHjCq0LTGi-QRIzZQSo0DmZqc0tVBDX4Sfs-ge_2Ro,1382
+ntcore/rpy-include/rpygen/nt__DoubleArrayPublisher.hpp,sha256=Lu2ZUcbo6juW-4cXqxDleoQkp1qz3JZZUSyawMWt17U,1602
+ntcore/rpy-include/rpygen/nt__DoubleArraySubscriber.hpp,sha256=RLho146QtYnVuYk4ohI6EIDwRjSu7XlnxD_6M83_JKQ,1735
+ntcore/rpy-include/rpygen/nt__DoublePublisher.hpp,sha256=oLl_uv-Dp72qwxKSLHJisgZ9P1cjEd6FicrKE-QsQow,1356
+ntcore/rpy-include/rpygen/nt__DoubleSubscriber.hpp,sha256=5qFXj0WP1IPNoCBwOwzGrlsWfClwHIpYCsBXO4DuwBU,1370
+ntcore/rpy-include/rpygen/nt__FloatArrayPublisher.hpp,sha256=tVIof6q1RBhTb1KeB5WuqWqR17C2Jz942LSqH4yvz-s,1588
+ntcore/rpy-include/rpygen/nt__FloatArraySubscriber.hpp,sha256=qznVcDgB27pIKQwIi8g98gmZIFr4wsjX0zdqHGg4peA,1720
+ntcore/rpy-include/rpygen/nt__FloatPublisher.hpp,sha256=BNLJOEaHs5X5AS8rQ5OpDZPzZARrgLnp8dhVoDk-52Q,1344
+ntcore/rpy-include/rpygen/nt__FloatSubscriber.hpp,sha256=rIPMNXah1taYYxNxXokl18I2st1zsY7tNmWyGMvNYjU,1358
+ntcore/rpy-include/rpygen/nt__GenericPublisher.hpp,sha256=YbUSyK7v7xewDlo0vks1OljI5VTsPj2Di_s1fvQpw4c,1401
+ntcore/rpy-include/rpygen/nt__GenericSubscriber.hpp,sha256=_ipId_D2WahuhiirTu9S5V8H1lPUvwU5y2QU20SuCsw,1415
+ntcore/rpy-include/rpygen/nt__IntegerArrayPublisher.hpp,sha256=f2PGuc7xWB3Ak2zrNRmILTVPKgRL-zfxiIWhUdiuQs0,1616
+ntcore/rpy-include/rpygen/nt__IntegerArraySubscriber.hpp,sha256=DknFMTfw1iPHw_ztkxPdMJkS97b_3OzjCZA2GqLSiqo,1750
+ntcore/rpy-include/rpygen/nt__IntegerPublisher.hpp,sha256=yMpqXPwOuhDOx49VMpsVQCoDw1MB2zfgwgzH7vlQ3us,1368
+ntcore/rpy-include/rpygen/nt__IntegerSubscriber.hpp,sha256=_UggT5J3dbF0DWAeEQUDOWRV0ariObshAFO0J3NIsBY,1382
+ntcore/rpy-include/rpygen/nt__NTSendable.hpp,sha256=o3AfLKWrEnwumJfp4D4mD1G7Xcff6x2ZkvLpwbdysdc,2418
+ntcore/rpy-include/rpygen/nt__NTSendableBuilder.hpp,sha256=NTRIh0yvtemZx4n6LGpZNO3M849tyGVuaW8Ps8soKJw,2963
+ntcore/rpy-include/rpygen/nt__Publisher.hpp,sha256=8hmCxRnCmQzVnMfaMr26xn2i5UL6O4KlwED9n9EGgO0,743
+ntcore/rpy-include/rpygen/nt__RawPublisher.hpp,sha256=Tj9ClspGmWDAntOrm9S5WLRLpMPd7mINk1wHf8pMn4U,1523
+ntcore/rpy-include/rpygen/nt__RawSubscriber.hpp,sha256=u-ONmYE1U2-HsdfcJ7bVugchC3po-xgURBbAbtPG9jQ,1648
+ntcore/rpy-include/rpygen/nt__StringArrayPublisher.hpp,sha256=m34pXMmjZ_QATtHBjx5gpCJfZeUjZLANNs932f-jHBg,1416
+ntcore/rpy-include/rpygen/nt__StringArraySubscriber.hpp,sha256=P3bpnreiGhKE0Gl8D_PU_8om3o9KZVRtCSJnW9xpqk0,1430
+ntcore/rpy-include/rpygen/nt__StringPublisher.hpp,sha256=kJsYQJFrgHm6SRpunZGk1wIF5JkhZiX3mEnueRaIcQU,1532
+ntcore/rpy-include/rpygen/nt__StringSubscriber.hpp,sha256=pg30X9fwH-HoWx2IJ4SBnPLVAu0A3LW9rfnRWGGBva8,1660
+ntcore/rpy-include/rpygen/nt__StructArrayEntry.hpp,sha256=--irW45lwaf8g7TfweXOQ0j278jn8Zi-baJ6Tx_jJEE,2625
+ntcore/rpy-include/rpygen/nt__StructArrayPublisher.hpp,sha256=6zJWnqF7VX_NKrIqmgLt46sNXFrhzrfFRGKUtz1hPP0,4725
+ntcore/rpy-include/rpygen/nt__StructArraySubscriber.hpp,sha256=n3O8iDSmH1Go1deNMBZvv7Oo1INRxP5H2myQSBtULyQ,6348
+ntcore/rpy-include/rpygen/nt__StructArrayTopic.hpp,sha256=M3ukneHHruAbcPXs8mGPDqW8nSFFtKCF8_odEPL08SE,6169
+ntcore/rpy-include/rpygen/nt__StructEntry.hpp,sha256=RYPXrsxosT9wQqQWUvyBIqUpwdhciIoww0njkMNoDBI,2449
+ntcore/rpy-include/rpygen/nt__StructPublisher.hpp,sha256=D2ExedK25XSlbtTrvsQcFNX7w6Oowx0jK63Tnmdhga0,4299
+ntcore/rpy-include/rpygen/nt__StructSubscriber.hpp,sha256=9HGYYzjfMFZgItActna5mpDBGTlWgmvLvQBKP8yVhQ0,6042
+ntcore/rpy-include/rpygen/nt__StructTopic.hpp,sha256=_NXdNNqzu0qkSMKuX-0uerodYXo6F_lRtVemxsksi1I,5771
+ntcore/rpy-include/rpygen/nt__Subscriber.hpp,sha256=CYB-hReJdDJW-eFuMIsJ3xDnUHfuheaM1IHwLdpFsss,747
+ntcore/rpy-include/rpygen/nt__Timestamped.hpp,sha256=GVhrmG-DEut976WahSLXnheRuA6p_tlxKVLe8fnjrs4,1877
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl1.cpp,sha256=Sdmpv-z6e4pFwfgT0f36eH37XC4DdfsTGPXJWzdJxqA,688
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl10.cpp,sha256=Cj7Ri3E6etO6ln-7TP_-MQEZOzru9WLfi2dhiFEzmpE,703
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl11.cpp,sha256=SZW8gwepokocH6THVnGJGFfAHRE0gvjBbdw0CBBZTq8,711
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl12.cpp,sha256=KPjtIKuJzHhusY_zS7mPJKjGYfCxjD8DxlKrs1g2kyE,696
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl13.cpp,sha256=9xqZZXMujTVjLBGxm3cQpKUK1zSChwZy5Uo1nIDF6sw,709
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl2.cpp,sha256=9DyZlv1pyPjwqx65LdG4da4PHhNU0xg-5Jc6fQ0icq4,691
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl3.cpp,sha256=Vvqwh5FqXat1uY6O8vLd-7iyaCeuX-PMZXU8LSg05M4,689
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl4.cpp,sha256=YWefpMCS8F6ljnpddUUt4_iSk6j0zqQC3AWG20N3-8s,690
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl5.cpp,sha256=IGIrxuU-p3-tB9S7-kXj9hveVTHZq8ohMKVdvSOSZNE,695
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl6.cpp,sha256=Nug0zoao7dY9GpfYazIccGVPS_Y9g95GQEytMU6ZZfY,704
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl7.cpp,sha256=27zERkVS-cDpgdPCtoC2bVhX76jk6nQNQuw5_0RL1kU,700
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl8.cpp,sha256=44F0qC1vDkVr8btFep3pXTmAq2ROmmDZo-HmJC44VG8,704
+ntcore/rpy-include/rpygen/ntcore_cpp_types_tmpl9.cpp,sha256=UF-jR4ks46DbiolCXyACGZgJNfHinZsiYahTTrmjwfs,702
+ntcore/src/NetworkTable.cpp.inl,sha256=Ozt3Hk_IiF8pcNRAP5xr4uMsr4toXIjJgOPq9i-ByOQ,3076
+ntcore/src/NetworkTableEntry.cpp.inl,sha256=twvy029rTy-pQaYCSzEhgS79h8pjaVTAbxMWse7_EoE,2293
+ntcore/src/nt_instance.cpp,sha256=l5i18ulOsGUj6jlugId5pMmSZTVDXU8PMiPoccbgrG0,1572
+ntcore/src/nt_instance.h,sha256=gPRB1rc_kXv0fy27UCwGuHXt_7LZ6P_8zDBb079gkB4,400
+ntcore/src/nt_type_caster.h,sha256=mG8JmPVpTtqIpPysR7E6QwYw_fR_jvK35LtACtkMojw,1005
+ntcore/src/ntcore.cpp,sha256=S6yoHZGyo1tEkTPe573C62yt0kjijq6zhqTSK2sylKM,254
+ntcore/src/py2value.cpp,sha256=YMYF_OY_dNv88GNnuFEBGFCw2XWoDKxoegGfSHg5QrA,4980
+ntcore/src/py2value.h,sha256=VGzD8pa1-6b0d40Pe9g39cOndzDFsP308a_tYl-LI8A,597
+ntcore/src/pyentry.cpp,sha256=nI5kBYA_iABv75HLkJUPjRVneGfhbw2HjTe4f9fdMgM,4455
+ntcore/src/pyentry.h,sha256=PlJhRiwalCSlSdZyPoCIcaLpO3QiEyD9NqtXF-0vHsk,1224
+pyntcore-2024.3.2.1.dist-info/METADATA,sha256=t9DM6VzVGcIMl5eLeYFMaJbUiCXlGS-ZUIPIjEraUiM,476
+pyntcore-2024.3.2.1.dist-info/WHEEL,sha256=D4dkYCHz6QR6m-rj-ZKpj1lNui5A3_cghAvaCxPC74U,115
+pyntcore-2024.3.2.1.dist-info/entry_points.txt,sha256=8ot1lLI04Ka0hCkA9V0HbBTrCFCs5QMAUTgi7aoi6BU,38
+pyntcore-2024.3.2.1.dist-info/top_level.txt,sha256=AAaE3j5A7CbLJ5iZKrJnK-vUXFxkjBDNiFljbUDu4m0,7
+pyntcore-2024.3.2.1.dist-info/RECORD,,
```

